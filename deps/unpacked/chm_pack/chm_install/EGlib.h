/* ========================================================================== */
#ifndef __EGlib__
#define __EGlib__
/* config.h.  Generated from config.h.in by configure.  */
/* config.h.in.  Generated from configure.ac by autoheader.  */

/* first argument type for accept */
#define ACCEPT_TYPE_ARG1 int

/* second argument type for accept */
#define ACCEPT_TYPE_ARG2 struct sockaddr *

/* third argument type for accept */
#define ACCEPT_TYPE_ARG3 socklen_t *

/* Compilation-time debug level */
#define DEBUG 1

/* Define to 1 if want to use slab-based memory pool for gmp numbers */
#define EG_LPNUM_MEMSLAB 1

/* Define to one if yiu want long double support (if present in the system) */
#define ENABLE_LONG_DOUBLE 1

/* Define to 1 if you have the <assert.h> header file. */
#define HAVE_ASSERT_H 1

/* Define to 1 if the system has the type `BZFILE*'. */
#define HAVE_BZFILEP 1

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `clock' function. */
#define HAVE_CLOCK 1

/* Define to 1 if you have the declaration of `BZ2_bzclose', and to 0 if you
   don't. */
#define HAVE_DECL_BZ2_BZCLOSE 1

/* Define to 1 if you have the declaration of `BZ2_bzerror', and to 0 if you
   don't. */
#define HAVE_DECL_BZ2_BZERROR 1

/* Define to 1 if you have the declaration of `BZ2_bzopen', and to 0 if you
   don't. */
#define HAVE_DECL_BZ2_BZOPEN 1

/* Define to 1 if you have the declaration of `BZ2_bzread', and to 0 if you
   don't. */
#define HAVE_DECL_BZ2_BZREAD 1

/* Define to 1 if you have the declaration of `BZ2_bzwrite', and to 0 if you
   don't. */
#define HAVE_DECL_BZ2_BZWRITE 1

/* Define to 1 if you have the declaration of `gzclose', and to 0 if you
   don't. */
#define HAVE_DECL_GZCLOSE 1

/* Define to 1 if you have the declaration of `gzeof', and to 0 if you don't.
   */
#define HAVE_DECL_GZEOF 1

/* Define to 1 if you have the declaration of `gzerror', and to 0 if you
   don't. */
#define HAVE_DECL_GZERROR 1

/* Define to 1 if you have the declaration of `gzgets', and to 0 if you don't.
   */
#define HAVE_DECL_GZGETS 1

/* Define to 1 if you have the declaration of `gzopen', and to 0 if you don't.
   */
#define HAVE_DECL_GZOPEN 1

/* Define to 1 if you have the declaration of `gzwrite', and to 0 if you
   don't. */
#define HAVE_DECL_GZWRITE 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the <float.h> header file. */
#define HAVE_FLOAT_H 1

/* Define to 1 if you have the `floor' function. */
#define HAVE_FLOOR 1

/* Define to 1 if you have the `gethostbyname' function. */
#define HAVE_GETHOSTBYNAME 1

/* Define to 1 if you have the `getrusage' function. */
#define HAVE_GETRUSAGE 1

/* Define to 1 if you have the <gmp.h> header file. */
#define HAVE_GMP_H 1

/* Define to 1 if the system has the type `gzFile'. */
#define HAVE_GZFILE 1

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define if you have libbz2. */
#define HAVE_LIBBZ2 1

/* Define if you have libgmp */
#define HAVE_LIBGMP 1

/* Define to 1 if you have the `m' library (-lm). */
#define HAVE_LIBM 1

/* Define to 1 if you have the `nsl' library (-lnsl). */
/* #undef HAVE_LIBNSL */

/* Define if you have libpthread. */
#define HAVE_LIBPTHREAD 1

/* Define to 1 if you have the `resolv' library (-lresolv). */
#define HAVE_LIBRESOLV 1

/* Define if you have libz. */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if the system has the type `long double'. */
#define HAVE_LONG_DOUBLE 1

/* Define to 1 if your system has a GNU libc compatible `malloc' function, and
   to 0 otherwise. */
#define HAVE_MALLOC 1

/* Define to 1 if you have the <malloc.h> header file. */
#define HAVE_MALLOC_H 1

/* Define to 1 if you have the <math.h> header file. */
#define HAVE_MATH_H 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `memset' function. */
#define HAVE_MEMSET 1

/* Define to 1 if you have the <netdb.h> header file. */
#define HAVE_NETDB_H 1

/* Define to 1 if you have the <netinet/in.h> header file. */
#define HAVE_NETINET_IN_H 1

/* Define to 1 if you have the `posix_memalign' function. */
#define HAVE_POSIX_MEMALIGN 1

/* Define to 1 if you have the `pow' function. */
#define HAVE_POW 1

/* Define to 1 if you have the <pthread.h> header file. */
#define HAVE_PTHREAD_H 1

/* Define to 1 if your system has a GNU libc compatible `realloc' function,
   and to 0 otherwise. */
#define HAVE_REALLOC 1

/* Define to 1 if you have the <setjmp.h> header file. */
#define HAVE_SETJMP_H 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the `signal' function. */
#define HAVE_SIGNAL 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the `sleep' function. */
#define HAVE_SLEEP 1

/* Define to 1 if you have the `socket' function. */
#define HAVE_SOCKET 1

/* Define to one if you want software-based 128-bit floating point numbers */
/* #undef HAVE_SOFTFLOAT */

/* Define to 1 if you have the `sqrt' function. */
#define HAVE_SQRT 1

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stddef.h> header file. */
#define HAVE_STDDEF_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdio.h> header file. */
#define HAVE_STDIO_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/resource.h> header file. */
#define HAVE_SYS_RESOURCE_H 1

/* Define to 1 if you have the <sys/socket.h> header file. */
#define HAVE_SYS_SOCKET_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/times.h> header file. */
#define HAVE_SYS_TIMES_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the `times' function. */
#define HAVE_TIMES 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if typeof works with your compiler. */
#define HAVE_TYPEOF 1

/* Define to 1 if you have the `uname' function. */
#define HAVE_UNAME 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to the address where bug reports for this package should be sent. */
#define PACKAGE_BUGREPORT "daespino@gmail.com"

/* Define to the full name of this package. */
#define PACKAGE_NAME "EGlib"

/* Define to the full name and version of this package. */
#define PACKAGE_STRING "EGlib 2.6.20"

/* Define to the one symbol short name of this package. */
#define PACKAGE_TARNAME "-eglib-"

/* Define to the home page for this package. */
#define PACKAGE_URL ""

/* Define to the version of this package. */
#define PACKAGE_VERSION "2.6.20"

/* Define as the return type of signal handlers (`int' or `void'). */
#define RETSIGTYPE void

/* Define to 1 if you have the ANSI C header files. */
#define STDC_HEADERS 1

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif


/* Compilation-time verbose level */
#define VERBOSE_LEVEL 100

/* Define to 1 if on MINIX. */
/* #undef _MINIX */

/* Define to 2 if the system does not provide POSIX.1 features except with
   this defined. */
/* #undef _POSIX_1_SOURCE */

/* Define to 1 if you need to in order for `stat' and other things to work. */
/* #undef _POSIX_SOURCE */

/* Define for Solaris 2.5.1 so the uint32_t typedef from <sys/synch.h>,
   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
   #define below would cause a syntax error. */
/* #undef _UINT32_T */

/* Define for Solaris 2.5.1 so the uint64_t typedef from <sys/synch.h>,
   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
   #define below would cause a syntax error. */
/* #undef _UINT64_T */

/* Define for Solaris 2.5.1 so the uint8_t typedef from <sys/synch.h>,
   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
   #define below would cause a syntax error. */
/* #undef _UINT8_T */

/* Required for correct definition of functions like exp2 */
#define _XOPEN_SOURCE 600

/* Define to 1 if want to check free of zero and small pointers */
#define __EG_MEM_FREE_CHECK__ 0

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `__inline__' or `__inline' if that's what the C compiler
   calls it, or to nothing if 'inline' is not supported under any name.  */
#ifndef __cplusplus
/* #undef inline */
#endif

/* Define to the type of a signed integer type of width exactly 16 bits if
   such a type exists and the standard includes do not define it. */
/* #undef int16_t */

/* Define to the type of a signed integer type of width exactly 32 bits if
   such a type exists and the standard includes do not define it. */
/* #undef int32_t */

/* Define to the type of a signed integer type of width exactly 64 bits if
   such a type exists and the standard includes do not define it. */
/* #undef int64_t */

/* Define to the type of a signed integer type of width exactly 8 bits if such
   a type exists and the standard includes do not define it. */
/* #undef int8_t */

/* Define to rpl_malloc if the replacement function should be used. */
/* #undef malloc */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef pid_t */

/* Define to rpl_realloc if the replacement function should be used. */
/* #undef realloc */

/* Define to the equivalent of the C99 'restrict' keyword, or to
   nothing if this is not supported.  Do not define if restrict is
   supported directly.  */
#define restrict __restrict
/* Work around a bug in Sun C++: it does not support _Restrict or
   __restrict__, even though the corresponding Sun C compiler ends up with
   "#define restrict _Restrict" or "#define restrict __restrict__" in the
   previous line.  Perhaps some future version of Sun C++ will work with
   restrict; if so, hopefully it defines __RESTRICT like Sun C does.  */
#if defined __SUNPRO_CC && !defined __RESTRICT
# define _Restrict
# define __restrict__
#endif

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to __typeof__ if your compiler spells it that way. */
/* #undef typeof */

/* Define to the type of an unsigned integer type of width exactly 16 bits if
   such a type exists and the standard includes do not define it. */
/* #undef uint16_t */

/* Define to the type of an unsigned integer type of width exactly 32 bits if
   such a type exists and the standard includes do not define it. */
/* #undef uint32_t */

/* Define to the type of an unsigned integer type of width exactly 64 bits if
   such a type exists and the standard includes do not define it. */
/* #undef uint64_t */

/* Define to the type of an unsigned integer type of width exactly 8 bits if
   such a type exists and the standard includes do not define it. */
/* #undef uint8_t */

/* Define to empty if the keyword `volatile' does not work. Warning: valid
   code using `volatile' can become incorrect without. Disable with care. */
/* #undef volatile */
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @mainpage EGlib Home Page
 *
 * @section Introduction
 
 <P>This is a joint project of <A HREF=http://www.dii.uchile.cl/~daespino TARGET=_top>Daniel Espinoza</A> and <A HREF=http://mgoycool.uai.cl TARGET=_top>Marcos Goycoolea</A> where a number of people have contributed, including <A HREF=http://www.isye.gatech.edu/~rgarcia TARGET=_top>Renan Garcia</A>, <A HREF=http://www.isye.gatech.edu/~ddogan TARGET=_top>Deniz Dogan</A>, <A HREF=http://www.isye.gatech.edu/~fenginee TARGET=_top>Faram Engineer</A> and <A HREF=http://www.isye.gatech.edu/~jvielma TARGET=_top>Juan Pablo Vielma</A>.</P>

<P>The problem that this project intend to solve (or at least help to solve) is
that in any computer implementation
there is a lot of overlap in the basic structures and utilities used, such as
graph structures, linked lists, hash tables, heaps among others, as well as a
number of algorithms wich are very useful as sub-routines for more complicated
programs. We have used this library in a number of applied and research projects and have been
in development since 2003. I am sure that it is not a perfect
solution, and that there might be a lot of obscure features in here, but we
think that it might be usefull  for other people, at least as a place where to
learn some of the tricks that are needed while trying to get efficient
algorithms. And how to use some tools like unix sockets and memory managment.
Most of the ideas in this code aren't new, and we have tried to give due credit
where needed, but if you feel that we should aknlowledge something, please send me an e-mail
and I will try to fix it as soon as posible.</P>

<P>Much of the ideas used here come from <A HREF=http://www.tsp.gatech.edu/concorde.html TARGET=_top>Concorde</A>, from the <A HREF=http://www.kernel.org/ TARGET=_top>Linux Kernel</A>, and from a number of books like <A HREF=http://www.amazon.com/exec/obidos/tg/detail/-/0898711878/ref=wl_it_dp/104-1187958-7592743?%5Fencoding=UTF8&coliid=I14K4ED1JB3KTX&v=glance&colid=38CHMLSKMPOQV TARGET=_top>Data Structures and Network Algorithms</A>, <A HREF=http://www.amazon.com/exec/obidos/tg/detail/-/013617549X/ref=wl_it_dp/104-1187958-7592743?%5Fencoding=UTF8&coliid=I3FWMVP8FZAA9F&v=glance&colid=38CHMLSKMPOQV TARGET=_top>Network Flows: Theory, Algorithms, and Applications</A> and <A HREF=http://www.amazon.com/exec/obidos/tg/detail/-/0262032937/qid=1117732253/sr=8-1/ref=pd_csp_1/104-1187958-7592743?v=glance&s=books&n=507846 TARGET=_top>Introduction to Algorithms</A> and <A HREF=http://www-cs-faculty.stanford.edu/~knuth/taocp.html TARGET=_top>The Art of Computer Programming</A> among others.</P>

<P>You can see the <A HREF=EGlib_doc/modules.html TARGET=info>documentation</A>  or download the <A HREF=http://www.dii.uchile.cl/~daespino/SOurce/EGlib.tar.bz2 TARGET=_top>full source code</A> for it.</P>
<P>We also have made available binaries for <A HREF=http://www.dii.uchile.cl/~daespino/SOurce/EGlib-32.tar.bz2 TARGET=_top>linux 32 bit</A> and for <A HREF=http://www.dii.uchile.cl/~daespino/SOurce/EGlib-64.tar.bz2 TARGET=_top>linux 64 bit</A>

<P>Almost all the code is <A HREF=http://www.dii.uchile.cl/~daespino/files/Iso_C_1999_definition.pdf TARGET=_top> ISO-C99 </A> compliant, with some <A HREF=http://www.gnu.org TARGET=_top>GNU</A> <A HREF=http://gcc.gnu.org/onlinedocs TARGET=_top>C-extensions</A>, and thus compile
with any recent version of <A HREF=http://gcc.gnu.org/ TARGET=_top>gcc</A>. (i.e. at least GCC-3.4.1). We haven't tested the code outside the
Linux/Unix realm, and for sure some modules (like timers) won't run on other
plataforms.</P>

 * @section A General Structures
 * 
 * This library provide some of the most common structures and some structures
 * have been implemented in more than one form (depending on the coding 
 * philosophy to be used), here is a lists:
 * - Bynary Trees (@ref EGeBTree).
 * - Directed Graphs (@ref EGeDgraph).
 * - Double Linked Lists (@ref EGeList).
 * - General-Length bitfields (@ref eg_bit.h).
 * - Hash Tables (@ref eg_ehash.h).
 * - Heaps (@ref EGeHeap).
 * - Sets (@ref EGeSet).
 * - Simple Shrinkable graphs (@ref EGsrkGraph).
 * - Simple imput Parser (@ref eg_io.h).
 * - Timers (@ref EGtimer).
 * - Undirected Graphs (@ref EGeUgraph).
 * - Dense Matrices (@ref EGdMatrix).
 *
 * @section B  Parallel Support
 * 
 * We also provide a basic network interface @ref EGnet (with a simple 
 * example) that we use on our parallel algorithms/implementations, it is 
 * simple enough to use, and also provide some details of how it works, We 
 * are not sure regarding portability of this library outside POSIX systems, it
 * has been tested on 32 and 64 bit UNIX and LINUX systems.... but in the worst
 * case it should provide a starting point to work with.
 *
 * @section  C Basic Algorithms
 *
 * Some common algorithms are implemented:
 * - Push-Relabel max-flow (@ref EGalgPushRelabel).
 * - Minimum Global Cut (@ref EGalgMinCut).
 * - Simple Gausian Elimination over Dense Matrices (@ref EGdMatrixGaussianElimination).
 * - LLL Basis Reduction (@ref EGdBsRed).
 *
 * @section  D Memory Managment
 *
 * For different reasons we have needed some type of memory managment, from
 * macros to simplify memory allocation/free procedures, to actual pool
 * mechanism. There is one general set of macros defined in @ref EGmem, and a Slab-Allocator pool
 * implementation that up to now is in testing phase @ref EGmemSlab.
 *
 * @section  E Simple Templates on C
 *
 * Beyond the fact that Templates are implemented on C++, for those that like
 * to stick with C, we developed a general way of programming templates for
 * numbers in such a way as to implement at once different versions of the same
 * code with different underlying number definitions, this arose as a necesity
 * while porting <A HREF=http://www.isye.gatech.edu/~wcook/qsopt TARGET=_top>QSopt</A> to
 * work on exact arithmetic, and also on multiple precision floating point
 * numbers (as provided by <A HREF=http://www.swox.com/gmp TARGET=_top>GNUMP library</A>)
 * so that we have only one code for Minimum Global Cuts, but we get
 * implementations for doubles, fixed point arithmetic, GMP's integers,
 * floating points, rationals, and so on. This is done through the Makefile,
 * utilities lake ctags and awk, but uses the general interface @ref EGlpNum 
 * as a way to work with numbers.
 * 
 * @section  F Final Comments
 *
 * This library hopes to be usefull in general both to teach some programming
 * tricks, structures and algorithms, and also by providing (we think) usable
 * code, in fact we allways test our code with <A HREF=http://valgrind.org/ TARGET=_top>valgrind</A> (one of the best memory
 * debugger available today in my opinion), and check for any
 * memory leaks and illegal access to memory.
 * 
 * */
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** Main Configuration for the library, as debug levels and so on
 * 
 * @par History:
 * - 2010-08-13
 * 						- Add suport for autoconf and configure for header and feature
 * 						selection
 * - 2006-01-27
 *					- Handle some problems with stdint.h in SUN
 * - 2005-08-17
 * 					- Set memory aligment to 8 bits
 * - 2003-06-02
 * 					- First Implementation
 * @version 0.0.1 
 * */
/* ========================================================================= */
#ifndef __EG_CONFIG_H__
#define __EG_CONFIG_H__
#ifdef HAVE_STDIO_H
# include <stdio.h>
#endif
#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef HAVE_SYS_TYPES_H
# include <sys/types.h>
#endif
#ifdef HAVE_SYS_STAT_H
# include <sys/stat.h>
#endif
#ifdef STDC_HEADERS
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
# include <stdlib.h>
# endif
#endif
#ifdef HAVE_STRING_H
# if !defined STDC_HEADERS && defined HAVE_MEMORY_H
# include <memory.h>
# endif
# include <string.h>
#endif
#ifdef HAVE_STRINGS_H
# include <strings.h>
#endif
#ifdef HAVE_INTTYPES_H
# include <inttypes.h>
#endif
#ifdef HAVE_STDINT_H
# include <stdint.h>
#endif
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif
#ifdef HAVE_ERRNO_H
# include <errno.h>
#endif
#ifdef HAVE_LIMITS_H
# include <limits.h>
#endif
#ifdef HAVE_MATH_H
# include <math.h>
#endif
#ifdef HAVE_FLOAT_H
# include <float.h>
#endif
#ifdef HAVE_GETOPT_H
# include <getopt.h>
#endif
#ifdef HAVE_NETINET_IN_H
# include <netinet/in.h>
#endif
#ifdef HAVE_NETINET_TCP_H
# include <netinet/tcp.h>
#endif
#ifdef HAVE_NETDB_H
# include <netdb.h>
#endif
#ifdef HAVE_FCNTL_H
# include <fcntl.h>
#endif
#ifdef HAVE_SYS_RESOURCE_H
# include <sys/resource.h>
#endif
#ifdef HAVE_SYS_PARAM_H
# include <sys/param.h>
#endif
#ifdef TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# ifdef HAVE_SYS_TIME_H
# include <sys/time.h>
# else
# include <time.h>
# endif
#endif
#ifdef HAVE_SYS_TIMES_H
# include <sys/times.h>
#endif
#ifdef HAVE_STDARG_H
# include <stdarg.h>
#endif
#ifdef HAVE_SYS_UTSNAME_H
# include <sys/utsname.h>
#endif
#ifdef HAVE_SIGNAL_H
# include <signal.h>
#endif
#ifdef HAVE_SETJMP_H
# include <setjmp.h>
#endif
#ifdef HAVE_PTHREAD_H
# include <pthread.h>
#endif
#ifdef HAVE_SOFTFLOAT
#endif

/* ========================================================================= */
/** @brief We check for the GNU C extension typeof if necesary. */
#ifndef HAVE_TYPEOF
# if !HAVE_TYPEOF
#  error Can not compile EGlib without ``typeof'' support
# endif
#endif

/* ========================================================================= */
/** @brief if libbz2 define (if not available) the required function prototypes
 */
#ifdef HAVE_LIBBZ2
# if HAVE_LIBBZ2
#  ifdef HAVE_BZLIB_H
#   include <bzlib.h>
#  else 
/* define BZFILE */
#   ifndef HAVE_BZFILEP
typedef void BZFILE;
#   endif
/* define functions */
#   ifndef HAVE_DECL_BZ2_BZCLOSE
extern void BZ2_bzclose(BZFILE* b);
#   endif
#   ifndef HAVE_DECL_BZ2_BZERROR
extern const char* BZ2_bzerror(BZFILE*b,int*errnum);
#   endif
#   ifndef HAVE_DECL_BZ2_BZOPEN
extern BZFILE* BZ2_open(const char*path,const char*mode);
#   endif
#   ifndef HAVE_DECL_BZ2_BZREAD
extern int BZ2_bzread(BZFILE*b,void*buf,int len);
#   endif
#   ifndef HAVE_DECL_BZ2_BZWRITE
extern int BZ2_bzwrite(BZFILE*b,void*bug,int len);
#   endif
#  endif
# endif
#endif
/* ========================================================================= */
/** @brief ig libz define (if not available) the required prototypes */
#ifdef HAVE_LIBZ
# if HAVE_LIBZ
#  ifdef HAVE_ZLIB_H
#   include <zlib.h>
#  else 
/* define gzFile */
#   ifndef HAVE_GZFILE
typedef void* gzFIle;
#   endif
/* define functions */
#   ifndef HAVE_DECL_GZCLOSE
extern int gzclose(gzFile b);
#   endif
#   ifndef HAVE_DECL_GZEOF
extern int gzeof(gzFile b);
#   endif
#   ifndef HAVE_DECL_GZERROR
extern const char* gzerror(gzFile b,int*errnum);
#   endif
#   ifndef HAVE_DECL_GZOPEN
extern gzFile gzopen(const char*path,const char*mode);
#   endif
#   ifndef HAVE_DECL_GZREAD
extern int gzread(gzFile b,void*buf,unsigned len);
#   endif
#   ifndef HAVE_DECL_GZWRITE
extern int gzwrite(gzFile b,void*const bug,unsigned len);
#   endif
#  endif
# endif
#endif
/* ========================================================================= */
/** @brief see if we have both pthread library and header file available, if
 * so, define HAVE_EG_THREAD */
#if defined HAVE_PTHREAD_H && HAVE_PTHREAD_H && defined HAVE_LIBPTHREAD && HAVE_LIBPTHREAD
#define HAVE_EG_THREAD 1
#else
#define HAVE_EG_THREAD 0
#endif
/* ========================================================================= */
/** @brief if no gmp support, we do not include gmp.h, if on the otherhand, we
 * have libgmp, we MUST have gmp.h */
#ifdef HAVE_LIBGMP
# if HAVE_LIBGMP
#  ifdef HAVE_GMP_H
#   include <gmp.h>
#  else
#   error Must have gmp.h if comiling gmp-support, change configure options accordingly or instal gmp-dev in your system 
#  endif
# endif
#endif
/* ========================================================================= */
/** @brief assert Debug options definitions, by defoult set on */
#ifndef DEBUG
#warning you should define DEBUG, assuming it to be 1
#define DEBUG 1
#endif

/* ========================================================================= */
/** @brief assert Verbose options definition, by default set on */
#ifndef VERBOSE_LEVEL
#warning you should define VERBOSE_LEVEL, assuming it to be 1
#define VERBOSE_LEVEL 1
#endif

/* ========================================================================= */
/** @brief if no posix_memalign function is present, we must turn off memslab
 * support by reducing it to malloc */
#ifndef HAVE_POSIX_MEMALIGN
#define EG_SLAB_REDUCE_TO_MALLOC 1
#endif
/* ========================================================================= */
/** @brief internal newline string */
#define EG_NEWLINE "\n"
/* end eg_config.h */
#endif
/* ========================================================================= */
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGmacros General Macros
 * global macros and types for EGlib
 *
 * @version 0.9.2 
 * @par History:
 * - 2011-12-06
 * 						- Add generic signal handler and necesary macros
 * - 2011-05-16
 * 						- Add WARNIF(xxx) to warn (on screen) non-zero return values
 * - 2010-08-31
 * 						- Add EGcallD(xxx) short hand to EGcall(rval,CLEANUP,xxx)
 * - 2010-04-30
 * 						- Add IFMESSAGE messaging macro
 * - 2010-02-20
 * 						- Add EGcall macro to resume tracing calls.
 * - 2009-07-21
 * 						- Change macro-variables to __name convention to avoid name
 * 						clashes
 * - 2008-08-29
 * 						- Add EG_RETURN
 * - 2008-07-24
 * 						- Add TESTGL
 * - 2007-12-07
 * 						- Add FTESTG and FTEST, that always test the parameters
 * 							regardless of the debug level
 * - 2007-01-19
 * 						- Delete EGosGetOffset
 * - 2006-09-28
 * 						- Add function that display basic process information, including
 * 						version and date of compilation of EGlib
 * - 2005-12-19
 * 						- Add float128 support ussing SoftFloat.
 * - 2005-10-28
 * 						- Add some status definitions for algorithms.
 * - 2005-06-14
 * 						- Add strdup definition, just for cleanliness when compiling
 * - 2005-05-23
 * 						- Add EGcontainerOf
 * - 2005-05-03
 * 						- Add typeof definition;
 * - 2004-07-14
 * 						- Add GNU_MP_Z GNU_MP_F and GNU_MP_Q to the type definitions.
 * - 2004-07-12
 * 						- Add EGRAT_TYPE to the type definitions.
 * - 2004-03-17
 * 						- Add TESTG that if recives something that is nonzero print an
 * 							user message and the go to the given location.
 * - 2004-02-05
 * 						- Add CHECKRVALG that checks a return value, display a mesage,
 * 							and then perform a goto.
 * - 2003-12-01
 * 						- Add definition of a 'copy' function and its MP version.
 * - 2003-11-20
 * 						- Add PTRTEST that check if a pointer points to the first 64Kb of
 * 							memory internal memory. Althought such situation may happend 
 * 							(if we work in kernel-related stuff), it is usually an error 
 * 							when we try to access such a memory.
 * - 2003-09-08
 * 						- Add ADVTESTL
 * - 2003-07-10
 * 						- Add MESSAGEF, ADVCHECKRVAL
 * - 2003-07-02
 * 						- Add EGosGetData, EGosSetData, EGosGetOffset
 * - 2003-06-16
 * 						- Add EXITL macro
 * - 2003-06-06 
 * 						- Add TESTL macro to test conditions but only when the debug
 * 							level is at least some value
 * - 2003-05-22 
 * 						- Add EXITRVAL
 * - 2003-05-15 
 * 						- Add CHECKRVAL MESSAGE and WARNING macros.
 * - 2003-05-08 
 * 						- Add support for variadic macros for EXIT and TEST
 * 						- Define EGRAND_MAX for SUN and LINUX acordingly, this is becouse 
 * 							for some reason the value of RAND_MAX in SUN is not as 
 * 							specified in stdlib.h but rather 1 << 31 - 1. Still I am not 
 * 							sure about the maximum value of rand() on sun... will fix that 
 * 							later on to.
 * 						- Add a mesage macro, it only print if the debug level is as high
 * 							as required by the first field. Again the definition is
 * 							variadric and if the debug level is 0 we reduce the macro to 
 * 							the empty instruction.
 *
 * */
/**  @{ */
/** @file 
 * */
/* ========================================================================= */

#ifndef __EG_MACROS_H__
#define __EG_MACROS_H__

/* ========================================================================= */
/** @brief return the offset of a member inside a structure.
 * @param type the type of the containing structure.
 * @param member the name of the member that we are interested in compute the
 * offset.
 * @return the number of bytes between the member and the beginning of the
 * structure. */
#define EGoffsetOf(__type,__member) ((size_t) &((__type *)0)->__member)

/* ========================================================================= */
/** @brief given a pointer to a member of a structure, return the pointer to
 * the head of the structure. (idea taken from Linux Kernel).
 * @param __ptr pointer to the member of the containing structure.
 * @param __type name type of the containing structure.
 * @param __member name of the given member in the containing structure.
 * @return pointer to the containing structure.
 * */
#define EGcontainerOf(__ptr,__type,__member) ({\
	typeof(((__type *)0)->__member) *const __EGcOf_ptr = (__ptr);\
	(__type *)( (char*)__EGcOf_ptr - ((size_t) &((__type *)0)->__member));})

/* ========================================================================= */
/** @name Code Location Utility:
 * this are utility macros to print information about where we are.
 * @note For some reason __func__ don't work correctly for sun's cc in inline
 * functions, so we don't use in SUN architecture */
/*  @{  */
#define __EG_PRINTLOCF__(/*@null@*/__F)  fprintf(((__F==((FILE*)0))?stderr:__F),", in %s (%s:%d)\n",__func__,__FILE__,__LINE__)
#define __EG_PRINTLOC__      __EG_PRINTLOCF__(stderr)
#define __EG_PRINTLOC2F__(/*@null@*/__F) fprintf(((__F==((FILE*)0))?stderr:__F),"in %s (%s:%d)\n",__func__,__FILE__,__LINE__)
#define __EG_PRINTLOC2__     __EG_PRINTLOC2F__(stderr)
/*  @}  */
/* ========================================================================= */
/** @brief if the given display level is over the given treshold, display the
 * given message and location information */
#define IFMESSAGE(__display,...) do{\
	if((__display)>0){\
		fprintf(stderr,__VA_ARGS__);\
		__EG_PRINTLOC__;}}while(0)

/* ========================================================================= */
/** @brief if return value is non-zero warn on screen */
#define WARNIF(__L__) do{\
	const int __Wval__= (__L__);\
	if(__Wval__){fprintf(stderr,"WARNING: In %s (%s:%d) "#__L__" = %d\n",__func__,__FILE__,__LINE__,__Wval__);}}while(0)
#if DEBUG>=1
/* ========================================================================= */
/** @brief This macro is to print error messages and to return with value one
 * from the current function, it also print the file and line where this 
 * happend, but the condition is looked only if the debug level is at least __L
 * */
#define EXITL(__L,__A,...) ({\
	if(__L<=DEBUG){\
	if(__A){\
		fprintf(stderr,__VA_ARGS__);\
		__EG_PRINTLOC__;\
		_exit(1);}}})

/* ========================================================================= */
/** @brief This macro is to print error messages and to return with value one 
 * from the current function, it also print the file and line where this 
 * happend, but the condition is looked only if the debug level is at least __L 
 * */
#define TESTL(__L,__A,...) ({\
	if(__L<=DEBUG){\
	if(__A){\
		fprintf(stderr,__VA_ARGS__);\
		__EG_PRINTLOC__;\
		return 1;}}})

/* ========================================================================= */
/** @brief this macro check if the value of a pointer is not bellow the first 
 * 64Kb, if so it return the given value */
#define PTRTEST(__PTR,__RVAL) {\
	if(__PTR) ADVTESTL(0,((size_t)(__PTR)) < (1U<<16),__RVAL, \
								 "%s=%p is not a valid pointer",\
									#__PTR, (void*)(__PTR));}

/* ========================================================================= */
/** @brief This macro is to print error messages and jump to the given point
 * in the code, it also print the file and line where this happend */
#define TESTGL(__L,__A,__B,...) ({\
	if((__L)<=DEBUG && (__A)){\
		fprintf(stderr,"ERROR: " __VA_ARGS__);\
		__EG_PRINTLOC__;\
		goto __B;}})

/* ========================================================================= */
/** @brief return value macro, if the value is non-zero, write to standard
 * error the returning code and where this happen */
#define EG_RETURN(__A) {\
	const int __RVAL__ = (__A);\
	if(__RVAL__){\
		fprintf(stderr,"rval %d",__RVAL__);\
		__EG_PRINTLOC__;}\
	return __RVAL__;}
/* ========================================================================= */
/** @brief This macro is to print error messages and jump to the given point
 * in the code, it also print the file and line where this happend */
#define TESTG(__A,__B,...) ({\
	if(__A){\
		fprintf(stderr,"ERROR: " __VA_ARGS__);\
		__EG_PRINTLOC__;\
		goto __B;}})

/* ========================================================================= */
/** @brief This macro is to print error messages and to return with value one 
 * from the current function, it also print the file and line where this 
 * happend */
#define TEST(__A,...) ({\
	if(__A){\
		fprintf(stderr,__VA_ARGS__);\
		__EG_PRINTLOC__;\
		return 1;}})

/* ========================================================================= */
/** @brief This macro print messages to the screen when the debug level is as 
 * big as the first parameter, if the debug level is zero we eliminate the 
 * code and reduce it to the empty instruction. */
#define MESSAGEF(__A,__F,...) ({\
	if(__A <= DEBUG ){\
		fprintf(((__F==0)?stderr:__F),__VA_ARGS__);\
		__EG_PRINTLOCF__(__F);}})

/* ========================================================================= */
/** @brief This macro print messages to the screen when the debug level is as 
 * big as the first parameter, if the debug level is zero we eliminate the 
 * code and reduce it to the empty instruction. */
#define MESSAGE(__A,...) ({\
	if(__A <= DEBUG ){\
		fprintf(stderr,__VA_ARGS__);\
		__EG_PRINTLOC__;}})

#if VERBOSE_LEVEL >= 1
/* ========================================================================= */
/** @brief This macro print messages to the screen when the verbose level is as 
 * big as the first parameter, if the verbose level is zero we eliminate the 
 * code and reduce it to the empty instruction. */
#define OUTPUT(__A,...) ({\
	if(__A <= VERBOSE_LEVEL ){\
		fprintf(stderr,__VA_ARGS__);}})
#else
#define OUTPUT(__A,...) ;
#endif

/* ========================================================================= */
/** @brief This macro print messages to the screen when the condition __A is 
 * true .if the debug level is one we don't print any warning message. if 
 * the debug level is zero we eliminate the code and reduce it to the empty 
 * instruction. */
#define WARNINGL(__L,__A,...) ({\
	if((__A)&&(DEBUG>=__L)){\
		fprintf(stderr,"WARNING: ");\
		fprintf(stderr,__VA_ARGS__);\
		__EG_PRINTLOC__;}})

#else
#define TESTL(__L,__A,...) ;
#define EXITL(__L,__A,...) ;
#define TEST(__A,...) ;
#define TESTG(__A,__B,...) ;
#define TESTGL(__A,__B,...) ;
#define MESSAGE(__A,...) ;
#define MESSAGEF(__A,__F,...) ;
#define WARNINGL(__L,__A,...) ;
#define EG_RETURN(__A) do{return (__A);}while(0)
#define PTRTEST(__PTR,__RVAL) ;
#endif

/* ========================================================================= */
/** @brief This macro is to print error messages and to return with value one 
 * from the current function, it also print the file and line where this 
 * happend */
#define FTEST(__A,...) ({\
	if(__A){\
		fprintf(stderr,__VA_ARGS__);\
		__EG_PRINTLOC__;\
		return 1;}})

/* ========================================================================= */
/** @brief This macro is to print error messages and to return with value one 
 * from the current function, it also print the file and line where this 
 * happend */
#define FTESTG(__A,__B,...) ({\
	if(__A){\
		fprintf(stderr,"ERROR: " __VA_ARGS__);\
		__EG_PRINTLOC__;\
		goto __B;}})

/* ========================================================================= */
/** @brief This macro print messages to the screen when the condition __A is 
 * true. */
#define WARNING(__A,...) ({if(__A){\
		fprintf(stderr,"WARNING: ");\
		fprintf(stderr,__VA_ARGS__);\
		__EG_PRINTLOC__;}})

/* ========================================================================= */
/** @brief this macro test if a value is non zero, if it is it print where is 
 * it and exit EXIT_FAILURE. The idea is to use it to check return values of functions, 
 * and the calling function can't return a status, and then we are forced to 
 * exit. */
#define EXITRVAL(__A) ({\
	if(__A){\
		__EG_PRINTLOC2__;\
		exit(EXIT_FAILURE);}})

/* ========================================================================= */
/** @brief This macro is to print error messages and exit the program with 
 * code one from the current function, it also print the file and line where 
 * this happend */
#define EXIT(__A,...) ({if(__A){\
		fprintf(stderr,"EXIT: ");\
		fprintf(stderr,__VA_ARGS__);\
		__EG_PRINTLOC__;\
		exit(EXIT_FAILURE);}})

/* ========================================================================= */
/** @brief this macro test if a value is non zero, if it is it print where is 
 * it and return __B. The idea is to use it to check return values of functions 
 * */
#define ADVCHECKRVAL(__A,__B) ({\
	if(__A){\
		__EG_PRINTLOC2__;\
		return __B;}})

/* ========================================================================= */
/** @brief This macro test a condition '__A' when the debug level used at 
 * compile time is at least '__L'. If the condition is true, it print the 
 * message and return the '__RVAL' value. */
#define ADVTESTL(__L,__A,__RVAL,...) ({\
	if((DEBUG>=__L)&&(__A)){\
		fprintf(stderr,__VA_ARGS__);\
		__EG_PRINTLOC__;\
		return __RVAL;}})

/* ========================================================================= */
/** @brief this macro test if a value is non zero, if it is it print where is 
 * it and return 1. The idea is to use it to check return values of functions 
 * */
#define CHECKRVAL(__A) ({\
	if(__A){\
		__EG_PRINTLOC2__;\
		return __A;}})

/* ========================================================================= */
/** @brief, if a non-zero value is given as an argument, check the errno stored
 * in the system, print the related message, and return the non-zero given
 * parameter, otherwise, do nothing.
 * @param __value if non-zero check systems errors, and return this value
 * */
#define TESTERRNOIF(__value) do{\
	if(__value){\
		const int __EGserrno = errno;\
		fprintf(stderr,"failed with errno %d, %s\n",__EGserrno, strerror(__EGserrno));\
		__EG_PRINTLOC2__;\
		return __value;}}while(0)
/* ========================================================================= */
/** @brief this function, if the input is non zero, print a message of 
 * function, file and line and then goto the second parameter */
#define CHECKRVALG(__A,__B) do{if(__A){__EG_PRINTLOC2__;goto __B;}}while(0)

/* ========================================================================= */
/** @brief retrieve the data of type '__TYPE' in the structure '__DATA' that is 
 * located in the offset '__OFFS'. */
#define EGosGetData(__DATA,__OFFS,__TYPE) (*((__TYPE*)(((char*)__DATA)+__OFFS)))

/* ========================================================================= */
/** @brief set the data of type '__TYPE' in the structure '__DATA' that is 
 * located in the offset '__OFFS' to the value 'val'. */
#define EGosSetData(__DATA,__OFFS,__TYPE,val) (EGosGetData(__DATA,__OFFS,__TYPE)=val)

/* ========================================================================= */
/** @brief Defione copy functions, these functions
 * return copy of objects but with independent storage space, there are two
 * versions, one that require a memory pool from where to look for memory, and
 * another where we don't care about that.... the place from where the memory
 * was asked for depend on the function, se the function definition for 
 * details.
 * Note that if the is no more memory available the function should call
 * exit(EXIT_FAILURE).
 * This is only intended as a readibility help */
typedef void *(*EGcopy_f) (void *p);

/* ========================================================================= */
/** @brief Define a null copy function */
#define nullCopy ((EGcopy_f)0)

/* ========================================================================= */
/** @name Algorithms Return Status
 * Here we define some general status for algorithms, the exact meaning should
 * be sought in the actual algorithm definition, but the definitions here
 * provide a first overview of their meaning. */
/*  @{  */
/** @brief the algorithm finish successfully. */
#define EG_ALGSTAT_SUCCESS 0
/** @brief the algorithm could only partially finish */
#define EG_ALGSTAT_PARTIAL 1
/** @brief the algorithm stop because of some numerical problem */
#define EG_ALGSTAT_NUMERROR 2
/** @brief the algorithm stop because of some unforeseen error */
#define EG_ALGSTAT_ERROR 3
/* @} */

/* ========================================================================= */
/** @name Mathematical Constants 
 * Here we define some mathematical constants needed in some parts of the code
 * that are of general use */
/* @{ */
/** @brief definition of \f$\pi\f$ as a constant, suitable for quad-IEEE
 * operations. */
#define EG_M_PI 3.1415926535897932384626433832795029L
/* @} */

/* ========================================================================= */
/** @brief Call macro. The idea is to replace the following call:
 * rval = myfunction(mypar);
 * CHECKRVALG(rval,mygoto);
 * with the call
 * EGcall(rval,mygoto,myfunction(mypar));
 * this should help simplify calls and clean-up the code
 * @note each parameter is evaluated once, thus ensuring correct evaluation of
 * parameters, even if they are an expresion. */
#define EGcall(__rval__,__cleanup__,__myfunc__) do{const int __EGrval__=__myfunc__;(__rval__)=__EGrval__;TESTG(__EGrval__,__cleanup__,"Function " #__myfunc__ " failed with code %d ",__EGrval__);}while(0)
/* ========================================================================= */
/** @brief call macro with default arguments, it assumes that rval is an
 * integer variable to be used to store return value, and CLEANUP is a valid
 * label for an exit point in the code */
#define EGcallD(__myfunc2__) EGcall(rval,CLEANUP,__myfunc2__)
/* ========================================================================= */
/** @brief Display information about the library and the running process */
void EGlib_info(void);
/* ========================================================================= */
/** @brief print versioning info of the library */
void EGlib_version(void);
/* ========================================================================= */
/** @brief needed global jump-control variable */
extern jmp_buf __EGljmp;
/* ========================================================================= */
/** @brief a generic signal handler, it can handle SIGXCPU, SIGINT and SIGSEGV
 * signals by displaying a proper indication to stderr; note that a call to
 * #EGsigSetjmp should be performed at the very beggining of the main function
 * for this to be robust.
 * When receiving a SIGXCPU, SIGINT signal, the function report the signal and jump-back
 * to the setjmp position.
 * When receiving a SIGINT signal, the function report the signal and jump-back
 * @param s the signal number received
 * */
void EGsighandler(int s);
/* ========================================================================= */
/** @brief use #EGsighandler for SIGXCPU, SIGINT and SIGSEGV as signal handler.
 * */
void __EGsigSetSignal(void);
/* ========================================================================= */
/** @brief set the jump point, and the sginal handler.
 * it must receive a label where to jump, and where
 * to save the returning status, typically this will be the clean-up section 
 * of the main function and the status variable in the mian program.
 * @param __status__ the returning status of the call, zero when set, non-zero
 * when comming back from a long-jump.
 * @param __LABEL__ where to jump when returning from a long-jump. */
#define EGsigSet(__status__,__LABEL__) do{MESSAGE(0,"setjmp here");if((__status__=setjmp(__EGljmp))) goto __LABEL__;__EGsigSetSignal();}while(0)
/* ========================================================================= */
/** @brief set memory and run-time limits (soft and hard); if the current
 * limits are bellow the porposed limits, it will warn on screen, but will not
 * fail. Note that this function will set RLMIT_CORE to zero.
 * @param max_rtime maximum running time.
 * @param mem_limit maximum memory allowed for the process, this include
 * RLIMIT_AS and RLIMIT_DATA.
 * */
void EGsetLimits(double max_rtime, unsigned long memlimit);
/* ========================================================================= */
/**  @}  */
/* end of eg_macros.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef __EG_ELINK_H__
#define __EG_ELINK_H__
/* ========================================================================= */
/** @defgroup EGeLink EGeLink
 * This header contains the definition of an embeded link, this simple
 * structure can be used to build trees that only have the information of the
 * parent, and in many other basic structures.
 * @version 0.0.1
 * @par History:
 * 	- 2005-05-25
 * 						- First Implementation
 * */
/** @{ */
/** @file 
 * */
/* ========================================================================= */

/* ========================================================================= */
/** @brief Define a simple link structure. */
typedef struct EGeLink_t
{
	struct EGeLink_t *link;
}
EGeLink_t;

/* ========================================================================= */
/** @brief Set to null the given link.
 * @param __lpt pointer to the structure to set to NULL.
 * @return the given link pointer. */
#define EGeLinkReset(__lpt) ({\
	EGeLink_t*const __lnk__ = (__lpt);\
	__lnk__->link = 0;\
	__lnk__;})

/* ========================================================================= */
/** @brief Set the link to point to itself.
 * @param __lpt pointer to the structure to set.
 * @return the given pointer. */
#define EGeLinkSetSelf(__lpt) ({\
	EGeLink_t*const __lnk__ = (__lpt);\
	__lnk__->link = __lnk__;})

/* ========================================================================= */
/** @brief test wether the given link point to itself.
 * @param __lpt pointer to the link to test.
 * @return one if the link point to itself, zero otherwise. */
#define EGeLinkIsSelf(__lpt) ({\
	EGeLink_t*const __lnk__ = (__lpt);\
	__lnk__->link == __lnk__ ? 1 : 0;})

/* ========================================================================= */
/** @brief test wether the given link is null.
 * @param __lpt pointer to the link to test.
 * @return one if the pointer is null, zero otherwise. */
#define EGeLinkIsNull(__lpt) ({\
	(__lpt)->link ? 0 : 1;})

/* ========================================================================= */
/** @brief Set the given pointer to the given value.
 * @param __lpt pointer to the link to set.
 * @param __inf information to store.
 * @return pointer to the given link structure.
 * @note We don't require the given information to be of type (EGeLink_t)*,
 * but to use that information as a link, it should. */
#define EGeLinkSet(__lpt,__inf) ({\
	EGeLink_t*const __lnk__ = (__lpt);\
	__lnk__->link = (EGeLink_t*)(__inf);\
	__lnk__;})

/* ========================================================================= */
/** @}
 * end of eg_elink.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef __EG_NUMMACROS_H__
#define __EG_NUMMACROS_H__

/* ========================================================================= */
/** @defgroup EGlpNumMacros General Number Utilities
 * Here we put some utilities common for number.
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2007-10-08
 *  					- Move EGabs, EGswap, EGmin and EGmax to this file
 * */
/** @{*/
/** @file
 * @brief This file provide the user interface and function definitions 
 * for general number utilities.
 * */

/* ========================================================================= */
/** @brief Given tree numbers N1, N2 and Ntmp, swap values of N1 and N2 using
 * Ntmp as a temporal number. The variables should be of some primitive type of
 * C for this macro to work.
 * @param N1 first number.
 * @param N2 second number.
 * @param Ntmp temporal variable.
 * */
#define EGswap(N1,N2,Ntmp) do{\
	Ntmp = N1;\
	N1 = N2;\
	N2 = Ntmp;} while(0)

/* ========================================================================= */
/** @brief given two variables (of the same type, and of some predefined type)
 * return the maximum value among the two of them. */
#define EGmax(a,b) ({\
	const typeof(a) __EGma = (a);\
	const typeof(b) __EGmb = (b);\
	(__EGma > __EGmb ? __EGma : __EGmb);})

/* ========================================================================= */
/** @brief given two variables (of the same type, and of some predefined type)
 * return the minimum value among the two of them. */
#define EGmin(a,b) ({\
	const typeof(a) __EGma = (a);\
	const typeof(b) __EGmb = (b);\
	(__EGma < __EGmb ? __EGma : __EGmb);})

/* ========================================================================= */
/** @brief a general macro to return the absolute value of the given variable
 * @param var variable whose absolute value we want to compute.
 * @return value of the absolute value of the given variable, note that this
 * macro will only work in built-in types, and will use the default comparison
 * for those internal types. */
#define EGabs(var) ({\
		const typeof(var) __EGav = (var);\
		(__EGav < 0) ? -__EGav : __EGav;})

/* ========================================================================= */
/** @}*/
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGmem EGmem
 *
 * Here we define some usefull macros to deal with memory issues, for example,
 * assert that we always return memory when posible, and if no memory is found,
 * then we just exit to the system (because if there is trully no memory....
 * there is no much else to do... unless we start using shrinkable memory
 * pools, like for example @ref EGmemSlab , but that is still a long way off,
 * it will also perform (if debugging enabled) some allocation / freeing
 * checkings and so on.
 *
 * @version 0.0.1
 * @par History:
 * -2005-09-05
 * 					- Add EGrealloc, wich is a wrapper of realloc but that assures us
 * 					to have memory, if there is no  memory, we exit. The idea of these
 * 					functions is that in the future they would interact with the
 * 					memory pools to use any memory still in the pools.
 * -2005-08-20
 * 					- Move memory align definitions here, and set the aligment of
 * 						memory to 8 bytes (i.e. 64 bits). This is to simplify compilation
 * 						in diferent architectures like Sun, opteron 64 and intel 32.
 * -2005-08-01
 * 					- Fix calloc call to the right type (size_t), and some printing
 * 						issues while compiling on 64-bit architectures.
 * -2005-07-30
 * 					- First Implementation
 * */
/** @file
 * @ingroup EGmem */
/** @addtogroup EGmem */
/** @{ */
#ifndef __EG_MEM_H__
#define __EG_MEM_H__

/* ========================================================================= */
/** @brief size of a normal word in this machine (a word is just big enough to
 * store a pointer) */
#define EG_MEM_WORD_SIZE (sizeof(void*))
/* ========================================================================= */
/** @brief memory aligment used by EG alloc functions. */
#define EG_MEM_ALIGNMENT 8U

/* ========================================================================= */
/** @brief \f$log_2(EG_MEM_ALIGNMENT)\f$. */
#define EG_MEM_ALIGNMENT_SHIFT 3U

/* ========================================================================= */
/** @brief Given a pointer, return it's aligned value. */
#define EG_MEM_ALIGN(__ptr) \
	((((size_t)__ptr)+EG_MEM_ALIGNMENT-1)&(~(EG_MEM_ALIGNMENT-1)))

/* ========================================================================= */
/** @brief type of the free functions that recive only one parameter */
typedef void (*EGfree_f) (void *);

/* ========================================================================= */
/** @brief this is the the data free that does nothing, use it when you don't 
 * want/need to free the internal list data becouse you will do it 
 * elsewere */
#define nullFree ((EGfree_f)0)

/* ========================================================================= */
/** @brief custom allocation functions prototype: This class of functions
 * receive some user-provided data (udata), and given a size (psz), return a pointer of the given size */
typedef void*(*EGualloc_f)(void*udata,size_t psz);

/* ========================================================================= */
/** @brief custom free functions prototype: This class of functions receive
 * some user-provided data (udata), and a pointer (ptr), and should free (or
 * manage de-alocation) of the provided pointer. */
typedef void (*EGufree_f)(void*udata,void*ptr);

/* ========================================================================= */
/** @brief type for constructor functions. Given a pointer to an element of
 * some type, do the internal initialization necesary so that we can work with
 * the lement, such initialization may include allocating some internal memory
 * needed by the structure (not done by the user). This functions must never
 * fail. if some unexpected error does happen inside, then the function should
 * not return. (a call to exit(1) would do the trick). */
typedef void (*EGconstructor_f) (void *);

/* ========================================================================= */
/** @brief Null constructor function (do nothing) */
#define nullConstructor ((EGconstructor_f)0)

/* ========================================================================= */
/** @brief type for destructor functions. Given a pointer to an element of some
 * type, free all internal memory related to the element allocated during the
 * construction phase. (but not the pointer itself). This function must always
 * succed, if an error happen, the function should never return. (a call to
 * exit(1) would do the trick). */
typedef void (*EGdestructor_f) (void *);

/* ========================================================================= */
/** @brief Null destructor function (do nothing) */
#define nullDestructor ((EGdestructor_f)0)

/* ========================================================================= */
/** @brief this function replace malloc, check if the memory is not zero, if 
 * it is, it exit from the program, and display who called it and how much 
 * memory it tryed to alloc.
 * @param __A number of bytes to allocate.
 * @return a void* pointer to the newly allocated memory, note that if the 
 * function returns at all, it will return with the amount of memory required, 
 * so no NULL checking is ever necesary after an EGmalloc call. 
 * */
#define EGmalloc(__A) ({\
	size_t const _EGmp_sz_ = (size_t)(__A);\
	void * _EGmp_res_ = 0;\
	/*WARNINGL(0,!_EGmp_sz_,"Allocating 0 bytes");*/\
	if(_EGmp_sz_)\
	{\
		_EGmp_res_ = calloc((size_t)1,_EGmp_sz_);\
		EXIT(!_EGmp_res_,"Not enough memory while allocating %zd bytes",_EGmp_sz_);\
	}\
	_EGmp_res_;})

/* ========================================================================= */
/** @brief This function allocate 'count' elements of type 'type' and return 
 * a pointer of type 'type*'. If the memory is not available the program will 
 * exit indicating where it was trying to get memory and how much, it will also
 * check some common errors like allocating zero bytes.
 * @param __type type of the element required.
 * @param __count number of contiguous elements of the given type required.
 * @return pointer to the beggining of the allocated array of the apropiate
 * type (so no casting is needed). Note that if this function returns at all,
 * then the memory has been allocated and thus no NULL checking return is
 * necesary. */
#define EGsMalloc(__type,__count) (__type*)EGmalloc(sizeof(__type)*((size_t)(__count)))

/* ========================================================================= */
/** @brief Realloc a given pointer to the new size, and check that we find
 * enough memory to return. If we don't, we exit the execution.
 * @param __ptr pointer to reallocate.
 * @param __sz new number of bytes to reallocate.
 * @return pointer to the new block of memory */
#define EGrealloc(__ptr,__sz) ({\
	const size_t ____sz = (size_t)(__sz);\
	(__ptr) = realloc((__ptr),____sz);\
	EXIT(!(__ptr)&&(____sz),"not enough memory while reallocating %zd",____sz);\
	(__ptr);})

/* ========================================================================= */
/** @brief this is used to enable malloc/free tracking and extra debugging */
#ifndef __EG_MEM_FREE_CHECK__
#define __EG_MEM_FREE_CHECK__  (1 && DEBUG)
#endif

/* ========================================================================= */
/** @brief This function replace free, the idea of this is to HOPEFULLY later 
 * develop a memory leack checker that tell us who and where asked for memory 
 * and didn't free it, in hte meantime they do nothing.
 * @param __A pointer to the piece of memory to be freed, if debuging is enabled,
 * the function will test for freing NULL pointers, for suspicios address
 * freing and so on. note that the given pointer will point to NULL after this
 * call, thus reducing the posibility of freeing multiple times the same piece
 * of memory, or of allocating it after freeing it. */
#if __EG_MEM_FREE_CHECK__
#define EGfree(__A) ({\
		EXIT(((__A) && !(((size_t)(__A))>>19)),"Trying to free pointer "#__A\
				" with value %zd\nThis is probably an error",(size_t)(__A));\
		if(__A) free(__A);\
		else WARNING(1,"Trying to free "#__A", a NULL pointer");\
		(__A) = 0;})
#else
#define EGfree(__A) ({free(__A);(__A)=0;})
#endif

/* ========================================================================= */
/* end of eg_mem.h */
/** @} */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received __A copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/* This header include definitions of macros to work with fixed point
 * representation of decimal numbers.
 *
 * - 2003-06-26
 * 					- First Implementation
 * */
/* ========================================================================= */
#ifndef __EG_FP_H__
#define __EG_FP_H__
/* ========================================================================= */
/* EG_FP options */
/* ========================================================================= */
/* this enable check of overflows in the EGfp_t operations, this means that if
 * we perform an overflow operation, or work with overflow numbers, the resoult
 * will have the overflow bit set. */
#ifndef __EGFP_CHECK_OVERFLOW__
#define __EGFP_CHECK_OVERFLOW__ 0
#endif

/* this enable (on top of overflow check) varbose messages when overflow is
 * detected */
#ifndef __EGFP_CHECK_VERBOSE__
#define __EGFP_CHECK_VERBOSE__ 0
#endif


/* ========================================================================= */
/* local definitions, this implies acuracy */
/* ========================================================================= */

/* we choose the size_t integers because this is the usual natural length for
 * the machine, thus should be fastest choice. */
typedef long EGfp10_t;
typedef long EGfp20_t;
typedef long EGfp25_t;
typedef long EGfp28_t;

/* define how many bits there are in our structure */
#define EGFP_BIT CHAR_BIT*sizeof(long)

/* we reserve the second to last bit as an overflow mark, we are assuming that
 * the sign bit is the last one... this may be ot true in some machines, but
 * should be according to the STDC99 */
#define EGFP_OFBIT (((long)1)<<(EGFP_BIT-2))

/* this is the sign bit of the representation */
#define EGFP_SGBIT (1<<(EGFP_BIT-1))

/* this is how many bits we use for fractional representation */
#define EGFP_FRBIT10 10
#define EGFP_FRBIT20 20
#define EGFP_FRBIT25 25
#define EGFP_FRBIT28 28

/* this is how many bits we use for the integer parrt, we compute it as the
 * resoult of substract the other's fields to the total space */
#define EGFP_INBIT10 (EGFP_BIT-2-EGFP_FRBIT10)
#define EGFP_INBIT20 (EGFP_BIT-2-EGFP_FRBIT20)
#define EGFP_INBIT25 (EGFP_BIT-2-EGFP_FRBIT25)
#define EGFP_INBIT28 (EGFP_BIT-2-EGFP_FRBIT28)

/* now we define the maximum representable number */
#define EGFP_MAX10 ((double)((((long)1)<<30)-1))/((long)1<<EGFP_FRBIT10)
#define EGFP_MAX20 ((double)((((long)1)<<30)-1))/((long)1<<EGFP_FRBIT20)
#define EGFP_MAX25 ((double)((((long)1)<<30)-1))/((long)1<<EGFP_FRBIT25)
#define EGFP_MAX28 ((double)((((long)1)<<30)-1))/((long)1<<EGFP_FRBIT28)

/* now the minimum representable value */
#define EGFP_MIN10 (-EGFP_MAX10)
#define EGFP_MIN20 (-EGFP_MAX20)
#define EGFP_MIN25 (-EGFP_MAX25)
#define EGFP_MIN28 (-EGFP_MAX28)

/* this is the conversion factor used to transform __A real type to our fixed
 * point representation. */
#define EGFP_FACTOR10 (1LL<<EGFP_FRBIT10)
#define EGFP_FACTOR20 (1LL<<EGFP_FRBIT20)
#define EGFP_FACTOR25 (1LL<<EGFP_FRBIT25)
#define EGFP_FACTOR28 (1LL<<EGFP_FRBIT28)

/* the difference between one and the nearest representable number. Note that in
 * our case this number may be seen as the discretization for the numbers that
 * can be represented */
#define EGFP10_EPSILON (((double)1)/(EGFP_FACTOR10))
#define EGFP20_EPSILON (((double)1)/(EGFP_FACTOR20))
#define EGFP25_EPSILON (((double)1)/(EGFP_FACTOR25))
#define EGFP28_EPSILON (((double)1)/(EGFP_FACTOR28))

/* ========================================================================= */
/* now we define some function to manipulate this numbers */
/* ========================================================================= */

/* this check and maintain the overflow bit if the checking was enable, see the
 * eg_config.h to see the default value */
#if __EGFP_CHECK_OVERFLOW__
/* chek if __A FP_T number is overflow */
#define __EGFP_ABS__(__X) (__X>0?__X:-__X)
#define __EGFP_SGN__(__X) (__X<0?-1:1)
#if __EGFP_CHECK_VERBOSE__
#define EGFP_OCHK(__X) (((__EGFP_ABS__(__X))&EGFP_OFBIT)?fprintf(stderr,"Overflow in %s:%d\n",__FILE__,__LINE__),EGFP_OFBIT&(__EGFP_ABS__(__X)):0)
#else
#define EGFP_OCHK(__X) ((__EGFP_ABS__(__X))&EGFP_OFBIT)
#endif
/* define range check */
#define EGFP_RCHK10(__X) (((EGfp10_t)(((__X)>EGFP_MAX10)||((__X)<EGFP_MIN10)))<<(EGFP_BIT-2))
#define EGFP_RCHK20(__X) (((EGfp20_t)(((__X)>EGFP_MAX20)||((__X)<EGFP_MIN20)))<<(EGFP_BIT-2))
#define EGFP_RCHK25(__X) (((EGfp25_t)(((__X)>EGFP_MAX25)||((__X)<EGFP_MIN25)))<<(EGFP_BIT-2))
#define EGFP_RCHK28(__X) (((EGfp28_t)(((__X)>EGFP_MAX28)||((__X)<EGFP_MIN28)))<<(EGFP_BIT-2))
#else
#define EGFP_RCHK10(__X) 0
#define EGFP_RCHK20(__X) 0
#define EGFP_RCHK25(__X) 0
#define EGFP_RCHK28(__X) 0
#define EGFP_OCHK(__X) 0
#define __EGFP_SGN__(__X) 1
#endif

/* this function check if __A EG_fp_t is overflown */
#define EGfpCheckOverflow10(__X) EGFP_OCHK(__X)
#define EGfpCheckOverflow20(__X) EGFP_OCHK(__X)
#define EGfpCheckOverflow25(__X) EGFP_OCHK(__X)
#define EGfpCheckOverflow28(__X) EGFP_OCHK(__X)

/* convert __A float to our fixed point representation */
#define ftofp10(__F) (__EGFP_SGN__(__F)*(((EGfp10_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR10))|EGFP_RCHK10(__F)))
#define ftofp20(__F) (__EGFP_SGN__(__F)*(((EGfp20_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR20))|EGFP_RCHK20(__F)))
#define ftofp25(__F) (__EGFP_SGN__(__F)*(((EGfp25_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR25))|EGFP_RCHK25(__F)))
#define ftofp28(__F) (__EGFP_SGN__(__F)*(((EGfp28_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR28))|EGFP_RCHK28(__F)))

/* convert __A double to our fixed point representation */
#define lftofp10(__F) (__EGFP_SGN__(__F)*(((EGfp10_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR10))|EGFP_RCHK10(__F)))
#define lftofp20(__F) (__EGFP_SGN__(__F)*(((EGfp20_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR20))|EGFP_RCHK20(__F)))
#define lftofp25(__F) (__EGFP_SGN__(__F)*(((EGfp25_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR25))|EGFP_RCHK25(__F)))
#define lftofp28(__F) (__EGFP_SGN__(__F)*(((EGfp28_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR28))|EGFP_RCHK28(__F)))

#ifdef HAVE_LONG_DOUBLE
/* convert __A long double to our fixed point representation */
#define llftofp10(__F) (__EGFP_SGN__(__F)*(((EGfp10_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR10))|EGFP_RCHK10(__F)))
#define llftofp20(__F) (__EGFP_SGN__(__F)*(((EGfp20_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR20))|EGFP_RCHK20(__F)))
#define llftofp25(__F) (__EGFP_SGN__(__F)*(((EGfp25_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR25))|EGFP_RCHK25(__F)))
#define llftofp28(__F) (__EGFP_SGN__(__F)*(((EGfp28_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR28))|EGFP_RCHK28(__F)))
#endif

/* convert an integer to our fixed point representation */
#define itofp10(__F) (__EGFP_SGN__(__F)*(((EGfp10_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR10))|EGFP_RCHK10(__F)))
#define itofp20(__F) (__EGFP_SGN__(__F)*(((EGfp20_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR20))|EGFP_RCHK20(__F)))
#define itofp25(__F) (__EGFP_SGN__(__F)*(((EGfp25_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR25))|EGFP_RCHK25(__F)))
#define itofp28(__F) (__EGFP_SGN__(__F)*(((EGfp28_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR28))|EGFP_RCHK28(__F)))

/* convert an integer to our fixed point representation */
#define ltofp10(__F) (__EGFP_SGN__(__F)*(((EGfp10_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR10))|EGFP_RCHK10(__F)))
#define ltofp20(__F) (__EGFP_SGN__(__F)*(((EGfp20_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR20))|EGFP_RCHK20(__F)))
#define ltofp25(__F) (__EGFP_SGN__(__F)*(((EGfp25_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR25))|EGFP_RCHK25(__F)))
#define ltofp28(__F) (__EGFP_SGN__(__F)*(((EGfp28_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR28))|EGFP_RCHK28(__F)))

/* convert an integer to our fixed point representation */
#define lltofp10(__F) (__EGFP_SGN__(__F)*(((EGfp10_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR10))|EGFP_RCHK10(__F)))
#define lltofp20(__F) (__EGFP_SGN__(__F)*(((EGfp20_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR20))|EGFP_RCHK20(__F)))
#define lltofp25(__F) (__EGFP_SGN__(__F)*(((EGfp25_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR25))|EGFP_RCHK25(__F)))
#define lltofp28(__F) (__EGFP_SGN__(__F)*(((EGfp28_t)((__F*__EGFP_SGN__(__F))*EGFP_FACTOR28))|EGFP_RCHK28(__F)))

/* convert anEGfp_t to double */
#define fptolf10(__F) (((double)__F)/EGFP_FACTOR10)
#define fptolf20(__F) (((double)__F)/EGFP_FACTOR20)
#define fptolf25(__F) (((double)__F)/EGFP_FACTOR25)
#define fptolf28(__F) (((double)__F)/EGFP_FACTOR28)

/* convert anEGfp_t to float */
#define fptof10(__F) (((float)__F)/EGFP_FACTOR10)
#define fptof20(__F) (((float)__F)/EGFP_FACTOR20)
#define fptof25(__F) (((float)__F)/EGFP_FACTOR25)
#define fptof28(__F) (((float)__F)/EGFP_FACTOR28)

/* convert anEGfp_t to int */
#define fptoi10(__F) (((int)__F)/EGFP_FACTOR10)
#define fptoi20(__F) (((int)__F)/EGFP_FACTOR20)
#define fptoi25(__F) (((int)__F)/EGFP_FACTOR25)
#define fptoi28(__F) (((int)__F)/EGFP_FACTOR28)

/* convert anEGfp_t to long */
#define fptol10(__F) (((long)__F)/EGFP_FACTOR10)
#define fptol20(__F) (((long)__F)/EGFP_FACTOR20)
#define fptol25(__F) (((long)__F)/EGFP_FACTOR25)
#define fptol28(__F) (((long)__F)/EGFP_FACTOR28)

/* convert anEGfp_t to long long */
#define fptoll10(__F) (((long long)__F)/EGFP_FACTOR10)
#define fptoll20(__F) (((long long)__F)/EGFP_FACTOR20)
#define fptoll25(__F) (((long long)__F)/EGFP_FACTOR25)
#define fptoll28(__F) (((long long)__F)/EGFP_FACTOR28)

/* this function add to FP numbers */
#if __EGFP_CHECK_OVERFLOW__
#define EGfpAdd(__A,__B) ((EGFP_OCHK(__A)|EGFP_OCHK(__B)|EGFP_OCHK((__A+__B))|((__A+__B)*__EGFP_SGN__(__A+__B)))*__EGFP_SGN__(__A+__B))
#else
#define EGfpAdd(__A,__B) (__A+__B)
#endif
#define EGfpAdd10(__A,__B) EGfpAdd(__A,__B)
#define EGfpAdd20(__A,__B) EGfpAdd(__A,__B)
#define EGfpAdd25(__A,__B) EGfpAdd(__A,__B)
#define EGfpAdd28(__A,__B) EGfpAdd(__A,__B)

/* this function substract to FP numbers */
#if __EGFP_CHECK_OVERFLOW__
#define EGfpSub(__A,__B) ((EGFP_OCHK(__A)|EGFP_OCHK(__B)|EGFP_OCHK((__A-__B))|((__A-__B)*__EGFP_SGN__(__A-__B)))*__EGFP_SGN__(__A-__B))
#else
#define EGfpSub(__A,__B) (__A-__B)
#endif
#define EGfpSub10(__A,__B) EGfpSub(__A,__B)
#define EGfpSub20(__A,__B) EGfpSub(__A,__B)
#define EGfpSub25(__A,__B) EGfpSub(__A,__B)
#define EGfpSub28(__A,__B) EGfpSub(__A,__B)

/* this define multiplication of FP numbers */
#define __EGfpIntMul10__(__A,__B) ((long)(((long long)(__A))*((long long)(__B))>>EGFP_FRBIT10))
#define __EGfpIntMul20__(__A,__B) ((long)(((long long)(__A))*((long long)(__B))>>EGFP_FRBIT20))
#define __EGfpIntMul25__(__A,__B) ((long)(((long long)(__A))*((long long)(__B))>>EGFP_FRBIT25))
#define __EGfpIntMul28__(__A,__B) ((long)(((long long)(__A))*((long long)(__B))>>EGFP_FRBIT28))
#if __EGFP_CHECK_OVERFLOW__
#define EGfpMul10(__A,__B) ((\
		(EGFP_OCHK(__A))|\
		(EGFP_OCHK(__B))|\
		(EGFP_RCHK10((((double)(__A))*((double)(__B)))/(EGFP_FACTOR10*EGFP_FACTOR10)))|\
		(__EGfpIntMul10__(__A,__B)*__EGFP_SGN__(__EGfpIntMul10__(__A,__B))))*__EGFP_SGN__(__EGfpIntMul10__(__A,__B)))
#define EGfpMul20(__A,__B) ((\
		(EGFP_OCHK(__A))|\
		(EGFP_OCHK(__B))|\
		(EGFP_RCHK20((((double)(__A))*((double)(__B)))/(EGFP_FACTOR20*EGFP_FACTOR20)))|\
		(__EGfpIntMul20__(__A,__B)*__EGFP_SGN__(__EGfpIntMul20__(__A,__B))))*__EGFP_SGN__(__EGfpIntMul20__(__A,__B)))
#define EGfpMul25(__A,__B) ((\
		(EGFP_OCHK(__A))|\
		(EGFP_OCHK(__B))|\
		(EGFP_RCHK25((((double)(__A))*((double)(__B)))/(EGFP_FACTOR25*EGFP_FACTOR25)))|\
		(__EGfpIntMul25__(__A,__B)*__EGFP_SGN__(__EGfpIntMul25__(__A,__B))))*__EGFP_SGN__(__EGfpIntMul25__(__A,__B)))
#define EGfpMul28(__A,__B) ((\
		(EGFP_OCHK(__A))|\
		(EGFP_OCHK(__B))|\
		(EGFP_RCHK28((((double)(__A))*((double)(__B)))/(EGFP_FACTOR28*EGFP_FACTOR28)))|\
		(__EGfpIntMul28__(__A,__B)*__EGFP_SGN__(__EGfpIntMul28__(__A,__B))))*__EGFP_SGN__(__EGfpIntMul28__(__A,__B)))
#else
#define EGfpMul10(__A,__B) __EGfpIntMul10__(__A,__B)
#define EGfpMul20(__A,__B) __EGfpIntMul20__(__A,__B)
#define EGfpMul25(__A,__B) __EGfpIntMul25__(__A,__B)
#define EGfpMul28(__A,__B) __EGfpIntMul28__(__A,__B)
#endif

/* this define divition of FP numbers */
#define __EGfpIntDiv10__(__A,__B) ((EGfp10_t)((((long long)(__A))<<EGFP_FRBIT10)/(__B)))
#define __EGfpIntDiv20__(__A,__B) ((EGfp20_t)((((long long)(__A))<<EGFP_FRBIT20)/(__B)))
#define __EGfpIntDiv25__(__A,__B) ((EGfp25_t)((((long long)(__A))<<EGFP_FRBIT25)/(__B)))
#define __EGfpIntDiv28__(__A,__B) ((EGfp28_t)((((long long)(__A))<<EGFP_FRBIT28)/(__B)))
#if __EGFP_CHECK_OVERFLOW__
#define EGfpDiv10(__A,__B) ((\
		(EGFP_OCHK(__A))|\
		(EGFP_OCHK(__B))|\
		(EGFP_RCHK10(((((((double)(__A))*EGFP_FACTOR10)/(__B)))/EGFP_FACTOR10)))|\
		(__EGfpIntDiv10__(__A,__B)*__EGFP_SGN__(__EGfpIntDiv10__(__A,__B))))*__EGFP_SGN__(__EGfpIntDiv10__(__A,__B)))
#define EGfpDiv20(__A,__B) ((\
		(EGFP_OCHK(__A))|\
		(EGFP_OCHK(__B))|\
		(EGFP_RCHK20(((((((double)(__A))*EGFP_FACTOR20)/(__B)))/EGFP_FACTOR20)))|\
		(__EGfpIntDiv20__(__A,__B)*__EGFP_SGN__(__EGfpIntDiv20__(__A,__B))))*__EGFP_SGN__(__EGfpIntDiv20__(__A,__B)))
#define EGfpDiv25(__A,__B) ((\
		(EGFP_OCHK(__A))|\
		(EGFP_OCHK(__B))|\
		(EGFP_RCHK25(((((((double)(__A))*EGFP_FACTOR25)/(__B)))/EGFP_FACTOR25)))|\
		(__EGfpIntDiv25__(__A,__B)*__EGFP_SGN__(__EGfpIntDiv25__(__A,__B))))*__EGFP_SGN__(__EGfpIntDiv25__(__A,__B)))
#define EGfpDiv28(__A,__B) ((\
		(EGFP_OCHK(__A))|\
		(EGFP_OCHK(__B))|\
		(EGFP_RCHK28(((((((double)(__A))*EGFP_FACTOR28)/(__B)))/EGFP_FACTOR28)))|\
		(__EGfpIntDiv28__(__A,__B)*__EGFP_SGN__(__EGfpIntDiv28__(__A,__B))))*__EGFP_SGN__(__EGfpIntDiv28__(__A,__B)))
#else
#define EGfpDiv10(__A,__B) __EGfpIntDiv10__(__A,__B)
#define EGfpDiv20(__A,__B) __EGfpIntDiv20__(__A,__B)
#define EGfpDiv25(__A,__B) __EGfpIntDiv25__(__A,__B)
#define EGfpDiv28(__A,__B) __EGfpIntDiv28__(__A,__B)
#endif

/* this defines the change of sign of __A FP number */
#define EGfpMinus(__A) (__A*-1)
#define EGfpMinus10(__A) EGfpMinus(__A)
#define EGfpMinus20(__A) EGfpMinus(__A)
#define EGfpMinus25(__A) EGfpMinus(__A)
#define EGfpMinus28(__A) EGfpMinus(__A)

/* end of eg_fp.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef __EG_LPNUM_H__
#define __EG_LPNUM_H__
/* ========================================================================= */
/** @defgroup EGlpNum EGlpNum
 *
 * Here we define a common interface to handle numbers in general, the idea is
 * to be able to work with infinite precicion numbers, plain doubles, floats,
 * integers, or fixed point numbers, without actually making different codes
 * for each of those types, rather we preffer to fix that at compyle time.
 *
 * @par History:
 * Revision 1.1.0
 * 	- 2010-09-02
 * 						- Add support for int32 templates, streamline the template
 * 						implementation too
 * 						- Add MaxLpNum and MinLpNum keywords
 *  We start doing the migration to gmp and 'natural' types, this means that we
 *  drop support for EGrat, this allow us to drop the requirement to use
 *  pointers, and instead we can just call the functions with the original
 *  parameters, still we have to be VERY carefull regarding changing
 *  local/external copies.
 *  - 2007-10-08
 *  					- Move EGswap, EGabs, EGmin and Egmax to eg_numutil.h
 *  - 2005-10-31
 *  					- Add EGswap to swap elements of any predefined type.
 *  - 2005-08-31
 *  					- Add EGmin and EGmax for built in types (i.e. for types where
 *  					the < comparison works as we want).
 *  - 2005-08-16
 *  					- Streamline mpq_EGlpNumGetStr
 *  					- Minor Fixes for zeroLpNum
 *  - 2005-07-29
 *  					- Add EGabs definition.
 *  - 2005-07-24
 *  					- Split eg_lpnum.h into different headers for each type of
 *  						suported numbers.
 *  					- Deprecate EGlpNumCOmpUFrac
 *  - 2005-05-26
 *  					- Add epsLpNum
 *  - 2005-05-17
 *  					- Add mpq_EGlpNumReadStrXc(mpq_t,__EGPstr__)
 *  - 2005-05-16
 *  					- Add mpq_EGlpNumSet_mpf(mpq,mpf)
 *  - 2005-05-12
 *  					- Add mpf_EGlpNumEpow(num,power)
 *  					- Add function to change precision of the numbers on the fly.
 *  					- Add EGlpNumReadStr to set a number from a given input string.
 *  					- Add EGlpNumGetStr to get (hopefully) the exact representation 
 *  						of the given input as string.
 *  - 2005-05-03
 *  					- Change the structure of the header so it provides an interface
 *  					in which a program can use all types of numbers at the same time,
 *  					this implies that we must define a start-up and clean-up function
 *  					that would initialize all constants for all numbers, and change
 *  					the naming scheme accordingly to support this.
 *  					- Deprecate EGlpNumInitArray
 *  					- Deprecate EGlpNumFreeIntArray
 *  					- Change all static-inline definitions to Statement Exprs style.
 *  - 2005-04-25
 *  					- Add EGlpNumIsSumLess(__EGPa__,__EGPb__,__EGPc__)
 *  					- Add EGlpNumIsDiffLess(__EGPa__,__EGPb__,__EGPc__)
 *  - 2005-04-13
 *  					- Add EGlpNumCopyDiffRatio(__EGPa__,__EGPb__,__EGPc__,d)
 *  					- Add EGlpNumIsEqqual(__EGPa__,__EGPb__)
 *  					- Add EGlpNumIsEqual(__EGPa__,__EGPb__,__EGPerr__)
 *  					- Add EGlpNumCopy(__EGPa__,__EGPb__)
 *  					- Add EGlpNumIsLess(__EGPa__,__EGPb__)
 *  					- Add EGlpNumToLf(__EGPa__)
 *  					- Add EGlpNumCopyDiff(__EGPa__,__EGPb__,__EGPc__)
 *  					- Add EGlpNumCopyAbs(__EGPa__,__EGPb__)
 *  					- Add EGlpNumSubTo(__EGPa__,__EGPb__)
 *  					- Add EGlpNumAddTo(__EGPa__,__EGPb__)
 *  					- Add EGlpNumDivTo(__EGPa__,__EGPb__)
 *  					- Add EGlpNumMultTo(__EGPa__,__EGPb__)
 *  					- Add EGlpNumZero(__EGPa__)
 *  					- Add EGlpNumOne(__EGPa__)
 *  					- Add EGlpNumAddInnProdTo(__EGPa__,__EGPb__,__EGPc__)
 *  					- Add EGlpNumSubInnProdTo(__EGPa__,__EGPb__,__EGPc__)
 *  					- Add EGlpNumSign(__EGPa__)
 *  					- Add EGlpNumCopyNeg(__EGPa__,__EGPb__)
 *  					- Add EGlpNumDivUiTo(__EGPa__,__EGPb__)
 *  					- Add EGlpNumMultUiTo(__EGPa__,__EGPb__)
 *  					- Add EGlpNumIsLeq(__EGPa__,__EGPb__)
 *  					- Add EGlpNumCopySqrOver(__EGPa__,__EGPb__,__EGPc__)
 *  					- Add EGlpNumSet(__EGPa__,__EGPb__)
 *  					- Add EGlpNumCopyFrac(__EGPa__,__EGPb__,__EGPc__)
 *  					- Add EGlpNumAddUiTo(__EGPa__,__EGPb__)
 *  					- Add EGlpNumSubUiTo(__EGPa__,__EGPb__)
 *  					- Add EGlpNumCopySum(__EGPa__,__EGPb__,__EGPc__)
 *  					- Add EGlpNumInv(__EGPa__)
 *  					- Add EGlpNumFloor(__EGPa__)
 *  					- Add EGlpNumCeil(__EGPa__)
 *  					- Add EGlpNumIsLessDbl(__EGPa__,__EGPb__)
 *  					- Add EGlpNumIsGreaDbl(__EGPa__,__EGPb__)
 *  					- Add EGlpNumSetToMaxAbs(__EGPa__,__EGPb__)
 *  					- Add EGlpNumAllocArray(__EGPszb__)
 *  					- Add EGlpNumFreeArray(__EGPa__)
 *  					- Add EGlpNumReallocArray(__EGPa__,__EGPszb__)
 *  					- Add EGlpNumInitVar(__EGPa__)
 *  					- Add EGlpNumClearVar(__EGPa__)
 *  					- Add EGlpNumIsNeqq(__EGPa__,__EGPb__)
 *  					- Add EGlpNumIsNeq(__EGPa__,__EGPb__,__EGPc__)
 *  					- Add EGlpNumIsNeqqZero(__EGPa__)
 *  					- Add EGlpNumIsNeqZero(__EGPa__,__EGPb__)
 *  					- Add EGlpNumSetToMinAbs(__EGPa__,__EGPb__)
 * Revision 0.0.1
 * - 2004-07-15
 * 						- Add support for GNU_MP_F types
 * - 2004-07-14
 * 						- Add support for GNU_MP_Q types
 * - 2004-07-12
 * 						- Add support for EG-rationals
 * - 2004-06-21
 * 						- First Implementation/Definition
 * */

/** @file
 * @ingroup EGlpNum */
/** @addtogroup EGlpNum */
/** @{ */
/* ========================================================================= */
/* ========================================================================= */
/** @name Number Types Definitions:
 * Define (as its name suggest) an internal identifier for the given 
 * type. this definitions are provided to select different types of data at 
 * compile  time, thus allowing us to provide limited template support. */
/* @{ */
/** C double type. */
#define DBL_TYPE 0
/** C float type. */
#define FLT_TYPE 1
/** C int type. */
#define INT_TYPE 2
/** EGlib #EGfp10_t type, this is an implementation of fixed precision
 * arithmetic with 10 bits for fractional representation. */
#define FP10_TYPE 3
/** EGlib #EGfp20_t type, this is an implementation of fixed precision
 * arithmetic with 20 bits for fractional representation. */
#define FP20_TYPE 4
/** EGlib #EGfp28_t type, this is an implementation of fixed precision
 * arithmetic with 28 bits for fractional representation. */
#define FP28_TYPE 5
/** EGlib #EGfp25_t type, this is an implementation of fixed precision
 * arithmetic with 25 bits for fractional representation. */
#define FP25_TYPE 6
/** GNU_MP library mpz_t type */
#define GNU_MP_Z 8
/** GNU_MP library mpq_t type */
#define GNU_MP_Q 9
/** GNU_MP library mpf_t type */
#define GNU_MP_F 10
/** C long double type */
#define LDBL_TYPE 11
/** C long long int type */
#define LLINT_TYPE 12
/** SoftFloat 128-bit floating point numbner */
#define FLOAT128_TYPE 13
/** int32_t integers */
#define INT32_TYPE 14
/* @} */
/* ========================================================================= */
#ifdef HAVE_LONG_DOUBLE
#endif
#ifdef HAVE_SOFTFLOAT
#if HAVE_SOFTFLOAT
#endif
#endif
#ifdef HAVE_LIBGMP
#endif
/* ========================================================================= */
/** @brief Debugging verbosity messages deped on the value of DEBUG (defined in
 * eg_configure.h) and on the value of EGLPNUM_DEBUGL macro defined here.
* */
#define EGLPNUM_DEBUGL 100

#ifdef HAVE_LIBGMP
/* ========================================================================= */
/** @brief Set the default number of __BITS__ used in the precision of the
 * float point numbers (mpf_t), a normal double use up to 56-64 bits., the 
 * default precision is set to 128 */
extern unsigned long int EGLPNUM_PRECISION;

/* ========================================================================= */
/** @brief Change the default precision for mpf_t numbers. */
void EGlpNumSetPrecision (const unsigned prec);
#endif

/* ========================================================================= */
/** @brief Allocate an array of a given type and store (sizeof(size_t) bytes 
 * before the actual array) the size of the allocated array. 
 * @param __type the type of the array to be returned.
 * @param __size the length of the array to be returned, note that it can be
 * zero, in wich case no memory allocation is made and NULL is returned. */
#define __EGlpNumAllocArray(__type,__size) ({\
	size_t __sz = (__size);\
	size_t *__utmp = __sz ? (size_t*) EGmalloc (sizeof(__type) * __sz + sizeof(size_t)) : 0;\
	if(__sz) __utmp[0] = __sz;\
	(__type*)(__sz ? (__utmp+1):0);})

/* ========================================================================= */
/** @brief Given an array allocated with __EGlpNumAllocArray, return the size of
 * the given array, if the array is null, return zero. 
 * @param __array the array from where we need the size. */
/* ========================================================================= */
#define __EGlpNumArraySize(__array) ({\
	size_t *__utmp = (size_t*)(__array);\
	if(__utmp) __utmp--;\
	__utmp ? __utmp[0]:0;})

/* ========================================================================= */
/** @brief, given an array allocated by __EGlpNumAllocArray, free the allocated
 * memory.
 * @param __array the array to be freed, it can be null. The given array will
 * always pooint to NULL when this function is done.
 * */
/* ========================================================================= */
#define __EGlpNumFreeArray(__array) ({\
	size_t *__utmp = (size_t*)(__array);\
	if(__utmp) free (__utmp-1);\
	(__array) = 0;})

/* ========================================================================= */
/** @brief indicate if the global data needed for EGlpNum has been initialized,
 * if zero, initialization routine should be called. This is provided to allow
 * syncronization between libraries */
extern int __EGlpNum_setup;
/* ========================================================================= */
/** @brief initialization routine for global data. This function is called as a
 * constructor, but calling it twice won't cause any problems, it is provided
 * to ensure that all EGlpnum globals are initialized at the beggining 
 * and in case they where not (__EGlpNMum_setup==0), then call the initializator */
extern void EGlpNumStart(void);
/* ========================================================================= */
/** @brief This function must be called at the end of the program to free all
 * internal data used in the EGlpNum_t structures, once this function is called
 * any operation on EGlpNum_t types may fail.
 * */
extern void EGlpNumClear(void);
/* ========================================================================= */
/** @brief provided for backwards compatibility */
#define EGlpNumExit EGlpNumClear
/** @}*/
/* ========================================================================= */
/** @name Common EGlpNum Interface functions:
 * Here we define the basic functions needed to declare when implementing a
 * number template. */
/** @{ */
#ifdef UNUSED_INTERFACE
/* ========================================================================= */
/** extern definitions of constants for different set-ups */
#define zeroLpNum 
#define oneLpNum 
#define epsLpNum
#define MaxLpNum 
#define MinLpNum
/* ========================================================================= */
/** @brief Read from a string a number and store it in the given number, 
 * @return the number of chars readed from the input string */
#define EGlpNumReadStr(__EGPa__,__EGPstr__) 
/* ========================================================================= */
/** @brief given a int, write it to a string (to be allocated internally), 
 * and return it. */
#define EGlpNumGetStr(__EGPa__) 
/* ========================================================================= */
/** @brief given an array of type int, free it, if the pointer is NULL
 * nothing happen. */
#define EGlpNumFreeArray(__EGParr__)
/* ========================================================================= */
/** @brief Reallocate and initialize (if needed) 'size' elements of type 
 * EGlpNum_t and return it, if no more memory, exit(1) */
#define EGlpNumReallocArray(__EGPptr__,__EGPsza__) 
/* ========================================================================= */
/** @brief Allocate and initialize (if needed) 'size' elements of type int
 * and return it, if no more memory, exit(1) */
#define EGlpNumAllocArray(__EGPszb__)
/* ========================================================================= */
/** @brief set the given number, set its value to the given double.
 * @param var where we will store the int value.
 * @param dbl_var value to be stored in 'var'.
 * @par Description:
 * This function is intended to set initial values to variables; note that the
 * int is a number and not a pointer to that value, be carefull with this
 * detail. */
#define EGlpNumSet(__EGPnum__,__EGPdnum__)
/* ========================================================================= */
/** @brief Stores in the first number the ceil value of the second number, i.e.
 * EGlpNumCeil(__EGPa__,__EGPb__) <==> a= ceil(__EGPb__) */
#define EGlpNumCeil(__EGPa__,__EGPb__)
/* ========================================================================= */
/** @brief Stores in the first number the floor value of the second number, i.e.
 * EGlpNumFloor(__EGPa__,__EGPb__) <==> a= floor(__EGPb__) */
#define EGlpNumFloor(__EGPa__,__EGPb__)
/* ========================================================================= */
/** @brief store the (multiplicative) inverse of a number to itself, i.e.
 * implement a = 1/a.
 * @param a the number to be inverted. */
#define EGlpNumInv(__EGPa__)
/* ========================================================================= */
/** @brief Compare if two numbers are equal within a maximum error.
 * @param a EGlpNum_t first number to compare.
 * @param b EGlpNum_t second number to compare.
 * @return int one in success, zero oterwise.
 * @par Description:
 * Given two numbers 'a','b' return 1 if a == b, otherwise it return 0
 * */
#define EGlpNumIsEqqual(__EGPa__,__EGPb__)
/* ========================================================================= */
/** @brief Compare if two numbers are equal within a maximum error.
 * @param a EGlpNum_t first number to compare.
 * @param b EGlpNum_t second number to compare.
 * @param error EGlpNum_t maximum difference allowed between both
 * numbers.
 * @return int one in success, zero oterwise.
 * @par Description:
 * Given two numbers 'a','b' and a tolerance 'error',
 * return 1 if |a-b| <= error, otherwise it return 0.
 * */
#define EGlpNumIsEqual(__EGPa__,__EGPb__,__EGPerr__)
/* return 1 if |a-b| > error */
#define EGlpNumIsNeq(__EGPa__,__EGPb__,__EGPerr__)
/* return 1 if a == b */
#define EGlpNumIsNeqq(__EGPa__,__EGPb__)
/* return 1 if |a| <= error */
#define EGlpNumIsNeqZero(__EGPa__,__EGPerr__)
/* return 1 if a!= 0 */
#define EGlpNumIsNeqqZero(__EGPa__)
/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a < b, zero
 * otherwise.
 * */
#define EGlpNumIsLess(__EGPa__,__EGPb__)
/* ========================================================================= */
/** @brief test if a numer is greater than zero
 * @param a number to test
 * @return int one if success, zero otherwise.
 * */
#define EGlpNumIsGreatZero(__EGPa__)

/* ========================================================================= */
/** @brief test if a numer is less than zero
 * @param a number to test
 * @return int one if success, zero otherwise.
 * */
#define EGlpNumIsLessZero(__EGPa__)
/* ========================================================================= */
/** @brief test if the sum of the first two numbers is less thatn the third
 * number.
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @param c EGlpNum_t the third number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given a,__EGPb__, and c, return nonzero if (a + b < c), zero toherwise.
 * */
#define EGlpNumIsSumLess(__EGPa__,__EGPb__,__EGPc__)
/* ========================================================================= */
/** @brief test if the diference of the first two numbers is less thatn the 
 * third number.
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @param c EGlpNum_t the third number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given a,__EGPb__, and c, return nonzero if (a - b < c), zero toherwise.
 * */
#define EGlpNumIsDiffLess(__EGPa__,__EGPb__,__EGPc__)
/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b int the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a < b, zero
 * otherwise.
 * */
#define EGlpNumIsLessDbl(__EGPa__,__EGPb__)
/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b int the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a > b, zero
 * otherwise.
 * */
#define EGlpNumIsGreaDbl(__EGPa__,__EGPb__)
/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a <= b, zero
 * otherwise.
 * */
#define EGlpNumIsLeq(__EGPa__,__EGPb__)
/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param a EGlpNum_t source number (it won't change value).
 * @param b EGlpNum_t source number (it won't change value).
 * @param __EGden__ EGlpNum_t denominator of the difference (it won't change value).
 * @param __EGdest__ EGlpNum_t where to store the value .
 * @par Description:
 * Set __EGdest__ = (a - b) / __EGden__ */
#define EGlpNumCopyDiffRatio(__EGdest__,__EGPa__,__EGPb__,__EGden__)
/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param a EGlpNum_t source number (it won't change value).
 * @param b EGlpNum_t source number (it won't change value).
 * @param __EGdest__ EGlpNum_t where to store the value stored in '__EGorig__'.
 * @par Description:
 * Set __EGdest__ = a - b */
#define EGlpNumCopyDiff(__EGdest__,__EGPa__,__EGPb__)
/* ========================================================================= */
/** @brief copy the value of the sum of the second and third parameter
 * @param a EGlpNum_t source number (it won't change value).
 * @param b EGlpNum_t source number (it won't change value).
 * @param __EGdest__ EGlpNum_t where to store the sum.
 * @par Description:
 * Set __EGdest__ = a + b */
#define EGlpNumCopySum(__EGdest__,__EGPa__,__EGPb__)
/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param __EGorig__ EGlpNum_t source number (it won't change value).
 * @param __EGdest__ EGlpNum_t where to store the value stored in '__EGorig__'.
 * @par Description:
 * Given two numbers copy the values in '__EGorig__', into '__EGdest__'.
 * */
#define EGlpNumCopy(__EGdest__,__EGorig__)
/* ========================================================================= */
/** @brief change the fist number to the maximum between itself and the 
 * absolute value of the second.
 * @param __EGorig__ EGlpNum_t source number (it won't change value).
 * @param __EGdest__ EGlpNum_t where to store the value stored in '__EGorig__'.
 * @par Description:
 * implement __EGdest__ = max(__EGdest__,abs(__EGorig__))
 * */
#define EGlpNumSetToMaxAbs(__EGdest__,__EGorig__) 
#define EGlpNumSetToMinAbs(__EGdest__,__EGorig__)
/* ========================================================================= */
/** @brief copy the square of the second argument, divided by the third 
 * argument into the first argument.
 * @param __EGdest__ EGlpNum_t where to store the result
 * @param __EGorig__ EGlpNum_t second parameter
 * @param __EGden__ EGlpNum_t third parameter
 * @par Description:
 * compute __EGdest__ = (__EGorig__*__EGorig__)/__EGden__
 * */
#define EGlpNumCopySqrOver(__EGdest__,__EGorig__,__EGden__)
/* ========================================================================= */
/** @brief copy the value of the absolute value of the second parameter to the 
 * first parameter.
 * @param __EGorig__ EGlpNum_t source number (it won't change value).
 * @param __EGdest__ EGlpNum_t where to store the absolute value stored
 * in '__EGorig__'.
 * @par Description:
 * Given a number '__EGorig__', copy its absolute value to '__EGdest__'. i.e.
 * __EGdest__ = |__EGorig__|
 * */
#define EGlpNumCopyAbs(__EGdest__,__EGorig__)
/* ========================================================================= */
/** @brief copy minus the value of the second parameter to the 
 * first parameter.
 * @param __EGorig__ EGlpNum_t the source number (it won't change value).
 * @param __EGdest__ EGlpNum_t where to store minus the value stored
 * in '__EGorig__'.
 * @par Description:
 * Given a number '__EGorig__', copy minus the value to '__EGdest__'. i.e.
 * __EGdest__ = -__EGorig__
 * */
#define EGlpNumCopyNeg(__EGdest__,__EGorig__)
/* ========================================================================= */
/** @brief Set des = __EGPa__/__EGPb__.
 * @param __EGdest__ EGlpNum_t where we will store the result.
 * @param __EGPa__ EGlpNum_t numerator of the fraction (possibly non an integer)
 * @param __EGPb__ EGlpNum_t denominator of the fraction (possibly non an integer)
 * @par Description:
 *  Set __EGdest__ = __EGPa__/__EGPb__
 * */
#define EGlpNumCopyFrac(__EGdest__,__EGPa__,__EGPb__)
/* ========================================================================= */
/** @brief copy the first 'size' values in the second array to the first array.
 * @param __EGorig__ EGlpNum_t* pointer to the array from where we will copy the
 * values (it won't change value).
 * @param __EGdest__ EGlpNum_t* pointer to where to store the first 'size' values 
 * stored in '__EGorig__'.
 * @param size unsigned int specifying how many values of '__EGorig__' will be copied
 * onto '__EGdest__'
 * @par Description:
 * This function is provided to (possible) make fast copies of arrays of
 * numbers, the arrays should be of length at least 'size', and the resulting
 * copy is absolutely independent froom the original, any change in one vale of
 * one array won't change values on the other array.
 * */
#define EGlpNumCopyArray(__EGdest__,__EGorig__,__EGPszb__)
/* ========================================================================= */
/** @brief Sub to a given number the product of two numbers.
 * @param a EGlpNum_t the number that we are going to Sub to.
 * @param b EGlpNum_t value to be multiplyed.
 * @param c EGlpNum_t value to be multiplyed.
 * @par Description:
 * This function implements a = a - b*c, and clearly don't change the value
 * stored in 'b' nor in 'c'.
 * */
#define EGlpNumSubInnProdTo(__EGPa__,__EGPb__,__EGPc__) 
/* ========================================================================= */
/** @brief Add to a given number the product of two numbers.
 * @param a EGlpNum_t the number that we are going to add to.
 * @param b EGlpNum_t value to be multiplyed.
 * @param c EGlpNum_t value to be multiplyed.
 * @par Description:
 * This function implements a = a + b*c, and clearly don't change the value
 * stored in 'b' nor in 'c'.
 * */
#define EGlpNumAddInnProdTo(__EGPa__,__EGPb__,__EGPc__)
/* ========================================================================= */
/** @brief Substract to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to substract to.
 * @param b unsigned int value to be substracted to 'a'.
 * @par Description:
 * This function implements a = a - b, and clearly don't change the value
 * stored in 'b'.
 * */
#define EGlpNumSubUiTo(__EGPa__,__EGPb__)
/* ========================================================================= */
/** @brief Add to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to add to.
 * @param b unsigned int value to be added to 'a'.
 * @par Description:
 * This function implements a = a + b, and clearly don't change the value
 * stored in 'b'.
 * */
#define EGlpNumAddUiTo(__EGPa__,__EGPb__)
/* ========================================================================= */
/** @brief Add to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to add to.
 * @param b EGlpNum_t value to be added to 'a'.
 * @par Description:
 * This function implements a = a + b, and clearly don't change the value
 * stored in 'b'.
 * */
#define EGlpNumAddTo(__EGPa__,__EGPb__)
/* ========================================================================= */
/** @brief Substract to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to substract
 * from.
 * @param b EGlpNum_t value to be substracted to 'a'.
 * @par Description:
 * This function implements a = a - b, and clearly don't change the value
 * stored in 'b'.
 * */
#define EGlpNumSubTo(__EGPa__,__EGPb__)
/* ========================================================================= */
/** @brief Multiply a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to multiply by
 * the second number and store the result.
 * @param b EGlpNum_t value to be multyply to 'a'.
 * @par Description:
 * This function implements a = a * b, and clearly don't change the value
 * stored in 'b'.
 * */
#define EGlpNumMultTo(__EGPa__,__EGPb__)
/* ========================================================================= */
/** @brief Divide a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to divide by
 * the second number and store the result.
 * @param b EGlpNum_t value to be divide to 'a'.
 * @par Description:
 * This function implements a = a / b, and clearly don't change the value
 * stored in 'b'.
 * */
#define EGlpNumDivTo(__EGPa__,__EGPb__)
/* ========================================================================= */
/** @brief Divide a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to divide by
 * the second number and store the result.
 * @param b unsigned int value to be divided to 'a'.
 * @par Description:
 * This function implements a = a / b, and don't change the value
 * stored in 'b'.
 * */
#define EGlpNumDivUiTo(__EGPa__,__EGPb__)
/* ========================================================================= */
/** @brief Multiply a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to multiply by
 * the second number and store the result.
 * @param b unsigned int value to be multyply to 'a'.
 * @par Description:
 * This function implements a = a * b, and clearly don't change the value
 * stored in 'b'.
 * */
#define EGlpNumMultUiTo(__EGPa__,__EGPb__)
/* ========================================================================= */
/** @brief Reset the value of the pointed number to zero.
 * @param a EGlpNum_t the value to be set to zero.
 * @par Descrpition:
 * Reset a to zero, i.e. implements a = 0;
 * */
#define EGlpNumZero(__EGPa__)
/* ========================================================================= */
/** @brief Reset the value of the pointed number to one.
 * @param a EGlpNum_t value to be set to one.
 * @par Descrpition:
 * Reset a to zero, i.e. implements a = 1;
 * */
#define EGlpNumOne(__EGPa__)
/* ========================================================================= */
/** @brief Change the sign of the number.
 * @param a EGlpNum_t number we will change sign.
 * @par Descrpition:
 * Change the sign of the given number, i.e. implements a = -a
 * */
#define EGlpNumSign(__EGPa__)
/* ========================================================================= */
/** @brief return the closest double value of the given pointer number.
 * @param a EGlpNum_t number that we will be transformed to int.
 * @return int the closest int representation of the given number.
 * par Description:
 * return the int number closest in value to the value stored in a.
 * */
#define EGlpNumToLf(__EGPa__)
/* ========================================================================= */
/** @brief initialize the internal memory of a given variable and set its
 * initial value to zero */
#define EGlpNumInitVar(__EGPa__)

/* ========================================================================= */
/** @brief free the internal memory of a given variable */
#define EGlpNumClearVar(__EGPa__)
#endif
 /** @} */
/* ========================================================================= */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef __EG_LPNUM_DBL__
#define __EG_LPNUM_DBL__
/** @file
 * @ingroup EGlpNum */
/** @addtogroup EGlpNum */
/** @{ */
/* ========================================================================= */
/** extern definitions of constaants for different set-ups */
#define dbl_zeroLpNum 0.0
#define dbl_oneLpNum  1.0
#define dbl_epsLpNum  DBL_EPSILON
#define dbl_MaxLpNum	DBL_MAX
#define dbl_MinLpNum	DBL_MIN

/* ========================================================================= */
/** @brief Read from a string a number and store it in the given double, 
 * @return the number of chars readed from the input string */
#define dbl_EGlpNumReadStr(a,str) ({\
	int __i =0;\
	sscanf(str,"%lf%n",&(a),&__i);\
	__i;})

/* ========================================================================= */
/** @brief given a double, write it to a string (to be allocated internally), 
 * and return it. */
#define dbl_EGlpNumGetStr(a) ({\
	char *__str=0;\
	int __i=snprintf(__str,(size_t)0,"%.7lg",a);\
	__str = EGsMalloc(char,__i+1);\
	snprintf(__str,(size_t)(__i+1),"%.7lg",a);\
	__str;})

/* ========================================================================= */
/** @brief given an array of type double, free it, if the pointer is NULL
 * nothing happen. */
#define dbl_EGlpNumFreeArray(ea) __EGlpNumFreeArray(ea)

/* ========================================================================= */
/** @brief Reallocate and initialize (if needed) 'size' elements of type 
 * EGlpNum_t and return it, if no more memory, exit(1) */
#define dbl_EGlpNumReallocArray(lptr, lsize) ({\
	size_t __csz = (lsize), *__usp = 0;\
	size_t __psz = __EGlpNumArraySize(*lptr);\
	double** __ptr__ = (lptr);\
	if (!__psz) *__ptr__ = dbl_EGlpNumAllocArray (__csz); \
	else if (__psz < __csz) {\
		__usp = (size_t*)(*__ptr__);\
		__usp--;\
		__usp = EGrealloc(__usp, sizeof(double)*__csz+sizeof(size_t));\
		__usp[0] = __csz;\
		*__ptr__ = (double*)(__usp+1);\
		memset((*__ptr__)+__psz,0,sizeof(double)*(__csz-__psz));\
	}\
	*__ptr__;})

/* ========================================================================= */
/** @brief Allocate and initialize (if needed) 'size' elements of type double
 * and return it, if no more memory, exit(1) */
#define dbl_EGlpNumAllocArray(size) __EGlpNumAllocArray(double,size)

/* ========================================================================= */
/** @brief set the given number pointer, set its value to the given double.
 * @param var double where we will store the double value.
 * @param dbl double value to be stored in 'var'.
 * @par Description:
 * This function is intended to set initial values to variables; note that the
 * double is a number and not a pointer to that value, be carefull with this
 * detail. Also, due to implementation details this function can't deal with
 * numbers above 1e158 or smaller than 1e-158. Note also that if the number is
 * writen in the form \f$x=\bar{x}\cdot 2^e\f$ with \f$0.5<|\bar{x}|<1\f$, 
 * then \f$\left|x-\frac{p}{q}\right|<2^{e-64}\f$.
 * */
#define dbl_EGlpNumSet(var, dbl) ((var) = (dbl))

/* ========================================================================= */
/** @brief Stores in the first number the ceil value of the second number, i.e.
 * EGlpNumCeil(a,b) <==> a= ceil(b) */
#define dbl_EGlpNumCeil(a, b) ((a) = ceil(b))

/* ========================================================================= */
/** @brief Stores in the first number the floor value of the second number, i.e.
 * EGlpNumFloor(a,b) <==> a= floor(b) */
#define dbl_EGlpNumFloor(a, b) ((a) = floor(b))

/* ========================================================================= */
/** @brief store the (multiplicative) inverse of a number to itself, i.e.
 * implement a = 1/a.
 * @param a the number to be inverted. */
#define dbl_EGlpNumInv(a) ((a) = 1.0/(a))

/* ========================================================================= */
/** @brief Compare if two numbers are equal within a maximum error.
 * @param a EGlpNum_t first number to compare.
 * @param b EGlpNum_t second number to compare.
 * @return int one in success, zero oterwise.
 * @par Description:
 * Given two numbers 'a','b' return 1 if a == b, otherwise it return 0
 * */
#define dbl_EGlpNumIsEqqual(a,b) ((a) == (b))

/* ========================================================================= */
/** @brief Compare if two numbers are equal within a maximum error.
 * @param a EGlpNum_t first number to compare.
 * @param b EGlpNum_t second number to compare.
 * @param error EGlpNum_t maximum difference allowed between both
 * numbers.
 * @return int one in success, zero oterwise.
 * @par Description:
 * Given two numbers 'a','b' and a tolerance 'error',
 * return 1 if |a-b|<= error, otherwise it return 0.
 * */
#define dbl_EGlpNumIsEqual(a,b,error) (fabs((a)-(b)) <= (error))
#define dbl_EGlpNumIsNeq(a,b,error) (((a)-(b) > (error)) || ((b)-(a) > (error)))
#define dbl_EGlpNumIsNeqq(a,b)  ((a) != (b))
#define dbl_EGlpNumIsNeqZero(a,error) (((a) > (error)) || (-(a) > (error)))
#define dbl_EGlpNumIsNeqqZero(a)     	((a) != 0.0)

/* ========================================================================= */
/** @brief test if the first number is greater than zero
 * @param a EGlpNum_t number to test.
 * @return int one if success, zero otherwise.
 * */
#define dbl_EGlpNumIsGreatZero(a) (a > 0.0)

/* ========================================================================= */
/** @brief test if the first number is less than zero
 * @param a EGlpNum_t number to test.
 * @return int one if success, zero otherwise.
 * */
#define dbl_EGlpNumIsLessZero(a) (a < 0.0)

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a < b, zero
 * otherwise.
 * */
#define dbl_EGlpNumIsLess(a,b) (a < b)

/* ========================================================================= */
/** @brief test if the sum of the first two numbers is less thatn the third
 * number.
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @param c EGlpNum_t the third number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given a,b, and c, return nonzero if (a + b < c), zero toherwise.
 * */
#define dbl_EGlpNumIsSumLess(a, b, c) ((a) + (b) < (c))

/* ========================================================================= */
/** @brief test if the diference of the first two numbers is less thatn the 
 * third number.
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @param c EGlpNum_t the third number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given a,b, and c, return nonzero if (a - b < c), zero toherwise.
 * */
#define dbl_EGlpNumIsDiffLess(a, b, c) ((a) - (b) < (c))

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b double the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a < b, zero
 * otherwise.
 * */
#define dbl_EGlpNumIsLessDbl(a,b) ((a) < (b))

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b double the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a > b, zero
 * otherwise.
 * */
#define dbl_EGlpNumIsGreaDbl(a,b) ((a) > (b))

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a <= b, zero
 * otherwise.
 * */
#define dbl_EGlpNumIsLeq(a,b) ((a) <= (b))

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param a EGlpNum_t source number (it won't change value).
 * @param b EGlpNum_t source number (it won't change value).
 * @param den EGlpNum_t denominator of the difference (it won't change value).
 * @param dest EGlpNum_t where to store the value .
 * @par Description:
 * Set dest = (a - b) / den */
#define dbl_EGlpNumCopyDiffRatio(dest,a, b, den) ((dest) = ((a) - (b)) / (den))

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param a EGlpNum_t source number (it won't change value).
 * @param b EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the value stored in 'orig'.
 * @par Description:
 * Set dest = a - b */
#define dbl_EGlpNumCopyDiff(dest,a,b) ((dest) = (a) - (b))

/* ========================================================================= */
/** @brief copy the value of the sum of the second and third parameter
 * @param a EGlpNum_t source number (it won't change value).
 * @param b EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the sum.
 * @par Description:
 * Set dest = a + b */
#define dbl_EGlpNumCopySum(dest,a,b) ((dest) = (a) + (b))

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param orig EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the value stored in 'orig'.
 * @par Description:
 * Given two numbers copy the values in 'orig', into 'dest'.
 * */
#define dbl_EGlpNumCopy(dest,orig) ((dest) = (orig))

/* ========================================================================= */
/** @brief change the fist number to the maximum between itself and the 
 * absolute value of the second.
 * @param orig EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the value stored in 'orig'.
 * @par Description:
 * implement dest = max(dest,abs(orig))
 * */
#define dbl_EGlpNumSetToMaxAbs(dest, orig) if((dest) < fabs(orig)) \
																							(dest) = fabs(orig)
#define dbl_EGlpNumSetToMinAbs(dest, orig) if((dest) > fabs(orig)) \
																							(dest) = fabs(orig)

/* ========================================================================= */
/** @brief copy the square of the second argument, divided by the third 
 * argument into the first argument.
 * @param dest EGlpNum_t where to store the result
 * @param orig EGlpNum_t second parameter
 * @param den EGlpNum_t third parameter
 * @par Description:
 * compute dest = (orig*orig)/den
 * */
#define dbl_EGlpNumCopySqrOver(dest, orig, den) ((dest) = (orig)*(orig)/(den))

/* ========================================================================= */
/** @brief copy the value of the absolute value of the second parameter to the 
 * first parameter.
 * @param orig EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the absolute value stored
 * in 'orig'.
 * @par Description:
 * Given a number 'orig', copy its absolute value to 'dest'. i.e.
 * dest = |orig|
 * */
#define dbl_EGlpNumCopyAbs(dest,orig) ((dest) = fabs(orig))

/* ========================================================================= */
/** @brief copy minus the value of the second parameter to the 
 * first parameter.
 * @param orig EGlpNum_t the source number (it won't change value).
 * @param dest EGlpNum_t where to store minus the value stored
 * in 'orig'.
 * @par Description:
 * Given a number 'orig', copy minus the value to 'dest'. i.e.
 * dest = -orig
 * */
#define dbl_EGlpNumCopyNeg(dest,orig) ((dest) = -(orig))

/* ========================================================================= */
/** @brief Set des = op1/op2.
 * @param dest EGlpNum_t where we will store the result.
 * @param op1 EGlpNum_t numerator of the fraction (possibly non an integer)
 * @param op2 EGlpNum_t denominator of the fraction (possibly non an integer)
 * @par Description:
 *  Set des = op1/op2
 * */
#define dbl_EGlpNumCopyFrac(dest,op1,op2) ((dest) = (op1)/(op2))

/* ========================================================================= */
/** @brief copy the first 'size' values in the second array to the first array.
 * @param orig EGlpNum_t* pointer to the array from where we will copy the
 * values (it won't change value).
 * @param dest EGlpNum_t* pointer to where to store the first 'size' values 
 * stored in 'orig'.
 * @param size unsigned int specifying how many values of 'orig' will be copied
 * onto 'dest'
 * @par Description:
 * This function is provided to (possible) make fast copies of arrays of
 * numbers, the arrays should be of length at least 'size', and the resulting
 * copy is absolutely independent froom the original, any change in one vale of
 * one array won't change values on the other array.
 * */
#define dbl_EGlpNumCopyArray(dest,orig,size) memcpy(dest,orig,sizeof(double)*(size))

/* ========================================================================= */
/** @brief Sub to a given number the product of two numbers.
 * @param a EGlpNum_t the number that we are going to Sub to.
 * @param b EGlpNum_t value to be multiplyed.
 * @param c EGlpNum_t value to be multiplyed.
 * @par Description:
 * This function implements a = a - b*c, and clearly don't change the value
 * stored in 'b' nor in 'c'.
 * */
#define dbl_EGlpNumSubInnProdTo(a, b, c) ((a) -= (b)*(c))

/* ========================================================================= */
/** @brief Add to a given number the product of two numbers.
 * @param a EGlpNum_t the number that we are going to add to.
 * @param b EGlpNum_t value to be multiplyed.
 * @param c EGlpNum_t value to be multiplyed.
 * @par Description:
 * This function implements a = a + b*c, and clearly don't change the value
 * stored in 'b' nor in 'c'.
 * */
#define dbl_EGlpNumAddInnProdTo(a, b, c) ((a) += (b)*(c))

/* ========================================================================= */
/** @brief Substract to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to substract to.
 * @param b unsigned int value to be substracted to 'a'.
 * @par Description:
 * This function implements a = a - b, and clearly don't change the value
 * stored in 'b'.
 * */
#define dbl_EGlpNumSubUiTo(a,b) ((a) -= (b))

/* ========================================================================= */
/** @brief Add to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to add to.
 * @param b unsigned int value to be added to 'a'.
 * @par Description:
 * This function implements a = a + b, and clearly don't change the value
 * stored in 'b'.
 * */
#define dbl_EGlpNumAddUiTo(a,b) ((a) += (b))

/* ========================================================================= */
/** @brief Add to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to add to.
 * @param b EGlpNum_t value to be added to 'a'.
 * @par Description:
 * This function implements a = a + b, and clearly don't change the value
 * stored in 'b'.
 * */
#define dbl_EGlpNumAddTo(a,b) ((a) += (b))

/* ========================================================================= */
/** @brief Substract to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to substract
 * from.
 * @param b EGlpNum_t value to be substracted to 'a'.
 * @par Description:
 * This function implements a = a - b, and clearly don't change the value
 * stored in 'b'.
 * */
#define dbl_EGlpNumSubTo(a,b) ((a) -= (b))

/* ========================================================================= */
/** @brief Multiply a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to multiply by
 * the second number and store the result.
 * @param b EGlpNum_t value to be multyply to 'a'.
 * @par Description:
 * This function implements a = a * b, and clearly don't change the value
 * stored in 'b'.
 * */
#define dbl_EGlpNumMultTo(a,b) ((a) *= (b))

/* ========================================================================= */
/** @brief Divide a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to divide by
 * the second number and store the result.
 * @param b EGlpNum_t value to be divide to 'a'.
 * @par Description:
 * This function implements a = a / b, and clearly don't change the value
 * stored in 'b'.
 * */
#define dbl_EGlpNumDivTo(a,b) ((a) /= (b))

/* ========================================================================= */
/** @brief Divide a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to divide by
 * the second number and store the result.
 * @param b unsigned int value to be divided to 'a'.
 * @par Description:
 * This function implements a = a / b, and don't change the value
 * stored in 'b'.
 * */
#define dbl_EGlpNumDivUiTo(a,b) ((a) /= (b))

/* ========================================================================= */
/** @brief Multiply a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to multiply by
 * the second number and store the result.
 * @param b unsigned int value to be multyply to 'a'.
 * @par Description:
 * This function implements a = a * b, and clearly don't change the value
 * stored in 'b'.
 * */
#define dbl_EGlpNumMultUiTo(a,b) ((a) *= (b))

/* ========================================================================= */
/** @brief Reset the value of the pointed number to zero.
 * @param a EGlpNum_t the value to be set to zero.
 * @par Descrpition:
 * Reset a to zero, i.e. implements a = 0;
 * */
#define dbl_EGlpNumZero(a) ((a) = 0.0)

/* ========================================================================= */
/** @brief Reset the value of the pointed number to one.
 * @param a EGlpNum_t value to be set to one.
 * @par Descrpition:
 * Reset a to zero, i.e. implements a = 1;
 * */
#define dbl_EGlpNumOne(a) ((a) = 1.0)

/* ========================================================================= */
/** @brief Change the sign of the number.
 * @param a EGlpNum_t number we will change sign.
 * @par Descrpition:
 * Change the sign of the given number, i.e. implements a = -a
 * */
#define dbl_EGlpNumSign(a) ((a) = -(a))

/* ========================================================================= */
/** @brief return the closest double value of the given pointer number.
 * @param a EGlpNum_t number that we will be transformed to double.
 * @return double the closest double representation of the given number.
 * par Description:
 * return the double number closest in value to the value stored in a.
 * */
#define dbl_EGlpNumToLf(a) ((double)a)

/* ========================================================================= */
/** @brief initialize the internal memory of a given variable */
#define dbl_EGlpNumInitVar(a) dbl_EGlpNumZero(a)

/* ========================================================================= */
/** @brief free the internal memory of a given variable */
#define dbl_EGlpNumClearVar(a)

/* ========================================================================= */
/** @} */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef __EG_LPNUM_FP20__
#define __EG_LPNUM_FP20__
/** @file
 * @brief Here we provide an implementation of the common EGlpNum interface
 * using EGlib fixed point numbers, on the case where we store 20 bits for
 * fractional values, 11 bits for integers part and one sign bit. See @ref
 * eg_fp.h for more details.
 * @ingroup EGlpNum */
/** @addtogroup EGlpNum */
/** @{ */
/* ========================================================================= */
/** extern definitions of constants for different set-ups */
#define fp20_zeroLpNum ((int long)0)
#define fp20_oneLpNum ((int long)0x100000)	/**< 2^20 */
#define fp20_epsLpNum ((int long)1)
#define fp20_MaxLpNum ((int long)0x7fffffff)
#define fp20_MinLpNum ((int long)0xffffffff)

/* ========================================================================= */
/** @brief Read from a string a number and store it in the given int, 
 * @return the number of chars readed from the input string */
#define fp20_EGlpNumReadStr(a,str) ({\
	double __FP20_DBL;\
	int __i =0;\
	sscanf(str,"%lf%n",&__FP20_DBL,&__i);\
	a = ((EGfp20_t)(__FP20_DBL * fp20_oneLpNum));\
	__i;})

/* ========================================================================= */
/** @brief given a int, write it to a string (to be allocated internally), 
 * and return it. */
#define fp20_EGlpNumGetStr(a) ({\
	char *__str=0;\
	size_t __i=snprintf(__str,(size_t)0,"%.7lf",((double)(a))/fp20_oneLpNum);\
	__str = EGsMalloc(char,__i+1);\
	snprintf(__str,__i+1,"%.7lf",((double)(a))/fp20_oneLpNum);\
	__str;})

/* ========================================================================= */
/** @brief given an array of type int, free it, if the pointer is NULL
 * nothing happen. */
#define fp20_EGlpNumFreeArray(ea) __EGlpNumFreeArray(ea)

/* ========================================================================= */
/** @brief Reallocate and initialize (if needed) 'size' elements of type 
 * EGlpNum_t and return it, if no more memory, exit(1) */
#define fp20_EGlpNumReallocArray(lptr, lsize) ({\
	size_t __csz = (lsize), *__usp = 0;\
	size_t __psz = __EGlpNumArraySize(*lptr);\
	EGfp20_t** __ptr__ = (lptr);\
	if (!__psz) *__ptr__ = fp20_EGlpNumAllocArray (__csz); \
	else if (__psz < __csz) {\
		__usp = (size_t*)(*__ptr__);\
		__usp--;\
		__usp = EGrealloc(__usp, sizeof(EGfp20_t)*__csz+sizeof(size_t));\
		__usp[0] = __csz;\
		*__ptr__ = (EGfp20_t*)(__usp+1);\
	}\
	*__ptr__;})

/* ========================================================================= */
/** @brief Allocate and initialize (if needed) 'size' elements of type int
 * and return it, if no more memory, exit(1) */
#define fp20_EGlpNumAllocArray(size) __EGlpNumAllocArray(EGfp20_t,size)

/* ========================================================================= */
/** @brief set the given number pointer, set its value to the given int.
 * @param var int where we will store the int value.
 * @param dbl_var int value to be stored in 'var'.
 * @par Description:
 * This function is intended to set initial values to variables; note that the
 * int is a number and not a pointer to that value, be carefull with this
 * detail. Also, due to limits on the numbers that can be represented in
 * EGfp20_t, numbers outside that range will not be correctly represented, so
 * don't count on any specific behavior.
 * */
#define fp20_EGlpNumSet(var, dbl_var) \
	((var) = (EGfp20_t)((dbl_var)*fp20_oneLpNum))

/* ========================================================================= */
/** @brief Stores in the first number the ceil value of the second number, i.e.
 * EGlpNumCeil(a,b) <==> a= ceil(b) */
#define fp20_EGlpNumCeil(a, b) ({\
	fp20_EGlpNumFloor(a,b);\
	if((a) < (b)) (a) += fp20_oneLpNum;\
	(a);})

/* ========================================================================= */
/** @brief Stores in the first number the floor value of the second number, i.e.
 * EGlpNumFloor(a,b) <==> a= floor(b) */
#define fp20_EGlpNumFloor(a, b) ((a) = (((b)/fp20_oneLpNum)*fp20_oneLpNum))

/* ========================================================================= */
/** @brief store the (multiplicative) inverse of a number to itself, i.e.
 * implement a = 1/a.
 * @param a the number to be inverted. */
#define fp20_EGlpNumInv(a) ({\
	long long __fp20_tmp = (0x10000000000LL);\
	(a) = (EGfp20_t)(__fp20_tmp / (a));})

/* ========================================================================= */
/** @brief Compare if two numbers are equal within a maximum error.
 * @param a EGlpNum_t first number to compare.
 * @param b EGlpNum_t second number to compare.
 * @return int one in success, zero oterwise.
 * @par Description:
 * Given two numbers 'a','b' return 1 if a == b, otherwise it return 0
 * */
#define fp20_EGlpNumIsEqqual(a,b) ((a) == (b))

/* ========================================================================= */
/** @brief Compare if two numbers are equal within a maximum error.
 * @param a EGlpNum_t first number to compare.
 * @param b EGlpNum_t second number to compare.
 * @param error EGlpNum_t maximum difference allowed between both
 * numbers.
 * @return int one in success, zero oterwise.
 * @par Description:
 * Given two numbers 'a','b' and a tolerance 'error',
 * return 1 if |a-b|<= error, otherwise it return 0.
 * */
#define fp20_EGlpNumIsEqual(a,b,error) (EGabs((a)-(b)) <= (error))
#define fp20_EGlpNumIsNeq(a,b,error) (((a)-(b) > (error)) || ((b)-(a) > (error)))
#define fp20_EGlpNumIsNeqq(a,b)  ((a) != (b))
#define fp20_EGlpNumIsNeqZero(a,error) (((a) > (error)) || (-(a) > (error)))
#define fp20_EGlpNumIsNeqqZero(a)     	((a) != 0)

/* ========================================================================= */
/** @brief test if the first number is greater than zero
 * @param a number to compare.
 * @return int one if success, zero otherwise.
 * */
#define fp20_EGlpNumIsGreatZero(a) (a > 0)

/* ========================================================================= */
/** @brief test if the first number is less than zero
 * @param a number to compare.
 * @return int one if success, zero otherwise.
 * */
#define fp20_EGlpNumIsLessZero(a) (a < 0)

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a < b, zero
 * otherwise.
 * */
#define fp20_EGlpNumIsLess(a,b) (a < b)

/* ========================================================================= */
/** @brief test if the sum of the first two numbers is less thatn the third
 * number.
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @param c EGlpNum_t the third number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given a,b, and c, return nonzero if (a + b < c), zero toherwise.
 * */
#define fp20_EGlpNumIsSumLess(a, b, c) ((a) + (b) < (c))

/* ========================================================================= */
/** @brief test if the diference of the first two numbers is less thatn the 
 * third number.
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @param c EGlpNum_t the third number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given a,b, and c, return nonzero if (a - b < c), zero toherwise.
 * */
#define fp20_EGlpNumIsDiffLess(a, b, c) ((a) - (b) < (c))

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b int the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a < b, zero
 * otherwise.
 * */
#define fp20_EGlpNumIsLessDbl(a,b) ((a) < ((b)*fp20_oneLpNum))

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b int the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a > b, zero
 * otherwise.
 * */
#define fp20_EGlpNumIsGreaDbl(a,b) ((a) > ((b)*fp20_oneLpNum))

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a <= b, zero
 * otherwise.
 * */
#define fp20_EGlpNumIsLeq(a,b) ((a) <= (b))

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param a EGlpNum_t source number (it won't change value).
 * @param b EGlpNum_t source number (it won't change value).
 * @param den EGlpNum_t denominator of the difference (it won't change value).
 * @param dest EGlpNum_t where to store the value .
 * @par Description:
 * Set dest = (a - b) / den */
#define fp20_EGlpNumCopyDiffRatio(dest,a, b, den) \
	((dest) = (EGfp20_t)((((long long)((a) - (b)))*fp20_oneLpNum) / (den)))

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param a EGlpNum_t source number (it won't change value).
 * @param b EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the value stored in 'orig'.
 * @par Description:
 * Set dest = a - b */
#define fp20_EGlpNumCopyDiff(dest,a,b) ((dest) = (a) - (b))

/* ========================================================================= */
/** @brief copy the value of the sum of the second and third parameter
 * @param a EGlpNum_t source number (it won't change value).
 * @param b EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the sum.
 * @par Description:
 * Set dest = a + b */
#define fp20_EGlpNumCopySum(dest,a,b) ((dest) = (a) + (b))

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param orig EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the value stored in 'orig'.
 * @par Description:
 * Given two numbers copy the values in 'orig', into 'dest'.
 * */
#define fp20_EGlpNumCopy(dest,orig) ((dest) = (orig))

/* ========================================================================= */
/** @brief change the fist number to the maximum between itself and the 
 * absolute value of the second.
 * @param orig EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the value stored in 'orig'.
 * @par Description:
 * implement dest = max(dest,abs(orig))
 * */
#define fp20_EGlpNumSetToMaxAbs(dest, orig) if((dest) < EGabs(orig)) \
																							(dest) = EGabs(orig)
#define fp20_EGlpNumSetToMinAbs(dest, orig) if((dest) > EGabs(orig)) \
																							(dest) = EGabs(orig)

/* ========================================================================= */
/** @brief copy the square of the second argument, divided by the third 
 * argument into the first argument.
 * @param dest EGlpNum_t where to store the result
 * @param orig EGlpNum_t second parameter
 * @param den EGlpNum_t third parameter
 * @par Description:
 * compute dest = (orig*orig)/den
 * */
#define fp20_EGlpNumCopySqrOver(dest, orig, den) \
	((dest) = ((EGfp20_t)((((long long)(orig))*(orig))/(den))))

/* ========================================================================= */
/** @brief copy the value of the absolute value of the second parameter to the 
 * first parameter.
 * @param orig EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the absolute value stored
 * in 'orig'.
 * @par Description:
 * Given a number 'orig', copy its absolute value to 'dest'. i.e.
 * dest = |orig|
 * */
#define fp20_EGlpNumCopyAbs(dest,orig) ((dest) = EGabs(orig))

/* ========================================================================= */
/** @brief copy minus the value of the second parameter to the 
 * first parameter.
 * @param orig EGlpNum_t the source number (it won't change value).
 * @param dest EGlpNum_t where to store minus the value stored
 * in 'orig'.
 * @par Description:
 * Given a number 'orig', copy minus the value to 'dest'. i.e.
 * dest = -orig
 * */
#define fp20_EGlpNumCopyNeg(dest,orig) ((dest) = -(orig))

/* ========================================================================= */
/** @brief Set des = op1/op2.
 * @param dest EGlpNum_t where we will store the result.
 * @param op1 EGlpNum_t numerator of the fraction (possibly non an integer)
 * @param op2 EGlpNum_t denominator of the fraction (possibly non an integer)
 * @par Description:
 *  Set des = op1/op2
 * */
#define fp20_EGlpNumCopyFrac(dest,op1,op2) \
	((dest) = ((EGfp20_t)((((long long)(op1))*fp20_oneLpNum)/(op2))))

/* ========================================================================= */
/** @brief copy the first 'size' values in the second array to the first array.
 * @param orig EGlpNum_t* pointer to the array from where we will copy the
 * values (it won't change value).
 * @param dest EGlpNum_t* pointer to where to store the first 'size' values 
 * stored in 'orig'.
 * @param size unsigned int specifying how many values of 'orig' will be copied
 * onto 'dest'
 * @par Description:
 * This function is provided to (possible) make fast copies of arrays of
 * numbers, the arrays should be of length at least 'size', and the resulting
 * copy is absolutely independent froom the original, any change in one vale of
 * one array won't change values on the other array.
 * */
#define fp20_EGlpNumCopyArray(dest,orig,size) \
	memcpy(dest,orig,sizeof(EGfp20_t)*(size))

/* ========================================================================= */
/** @brief Sub to a given number the product of two numbers.
 * @param a EGlpNum_t the number that we are going to Sub to.
 * @param b EGlpNum_t value to be multiplyed.
 * @param c EGlpNum_t value to be multiplyed.
 * @par Description:
 * This function implements a = a - b*c, and clearly don't change the value
 * stored in 'b' nor in 'c'.
 * */
#define fp20_EGlpNumSubInnProdTo(a, b, c) \
	((a) -= ((EGfp20_t)((((long long)(b))*(c))/fp20_oneLpNum)))

/* ========================================================================= */
/** @brief Add to a given number the product of two numbers.
 * @param a EGlpNum_t the number that we are going to add to.
 * @param b EGlpNum_t value to be multiplyed.
 * @param c EGlpNum_t value to be multiplyed.
 * @par Description:
 * This function implements a = a + b*c, and clearly don't change the value
 * stored in 'b' nor in 'c'.
 * */
#define fp20_EGlpNumAddInnProdTo(a, b, c) \
	((a) += ((EGfp20_t)((((long long)(b))*(c))/fp20_oneLpNum)))

/* ========================================================================= */
/** @brief Substract to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to substract to.
 * @param b unsigned int value to be substracted to 'a'.
 * @par Description:
 * This function implements a = a - b, and clearly don't change the value
 * stored in 'b'.
 * */
#define fp20_EGlpNumSubUiTo(a,b) ((a) -= (b)*fp20_oneLpNum)

/* ========================================================================= */
/** @brief Add to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to add to.
 * @param b unsigned int value to be added to 'a'.
 * @par Description:
 * This function implements a = a + b, and clearly don't change the value
 * stored in 'b'.
 * */
#define fp20_EGlpNumAddUiTo(a,b) ((a) += (b)*fp20_oneLpNum)

/* ========================================================================= */
/** @brief Add to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to add to.
 * @param b EGlpNum_t value to be added to 'a'.
 * @par Description:
 * This function implements a = a + b, and clearly don't change the value
 * stored in 'b'.
 * */
#define fp20_EGlpNumAddTo(a,b) ((a) += (b))

/* ========================================================================= */
/** @brief Substract to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to substract
 * from.
 * @param b EGlpNum_t value to be substracted to 'a'.
 * @par Description:
 * This function implements a = a - b, and clearly don't change the value
 * stored in 'b'.
 * */
#define fp20_EGlpNumSubTo(a,b) ((a) -= (b))

/* ========================================================================= */
/** @brief Multiply a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to multiply by
 * the second number and store the result.
 * @param b EGlpNum_t value to be multyply to 'a'.
 * @par Description:
 * This function implements a = a * b, and clearly don't change the value
 * stored in 'b'.
 * */
#define fp20_EGlpNumMultTo(a,b) \
	((a) = ((EGfp20_t)((((long long)(a))*(b))/fp20_oneLpNum)))

/* ========================================================================= */
/** @brief Divide a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to divide by
 * the second number and store the result.
 * @param b EGlpNum_t value to be divide to 'a'.
 * @par Description:
 * This function implements a = a / b, and clearly don't change the value
 * stored in 'b'.
 * */
#define fp20_EGlpNumDivTo(a,b) \
	((a) = ((EGfp20_t)((((long long)(a))*fp20_oneLpNum)/(b))))

/* ========================================================================= */
/** @brief Divide a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to divide by
 * the second number and store the result.
 * @param b unsigned int value to be divided to 'a'.
 * @par Description:
 * This function implements a = a / b, and don't change the value
 * stored in 'b'.
 * */
#define fp20_EGlpNumDivUiTo(a,b) ((a) /= (b))

/* ========================================================================= */
/** @brief Multiply a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to multiply by
 * the second number and store the result.
 * @param b unsigned int value to be multyply to 'a'.
 * @par Description:
 * This function implements a = a * b, and clearly don't change the value
 * stored in 'b'.
 * */
#define fp20_EGlpNumMultUiTo(a,b) ((a) *= (b))

/* ========================================================================= */
/** @brief Reset the value of the pointed number to zero.
 * @param a EGlpNum_t the value to be set to zero.
 * @par Descrpition:
 * Reset a to zero, i.e. implements a = 0;
 * */
#define fp20_EGlpNumZero(a) ((a) = 0)

/* ========================================================================= */
/** @brief Reset the value of the pointed number to one.
 * @param a EGlpNum_t value to be set to one.
 * @par Descrpition:
 * Reset a to zero, i.e. implements a = 1;
 * */
#define fp20_EGlpNumOne(a) ((a) = fp20_oneLpNum)

/* ========================================================================= */
/** @brief Change the sign of the number.
 * @param a EGlpNum_t number we will change sign.
 * @par Descrpition:
 * Change the sign of the given number, i.e. implements a = -a
 * */
#define fp20_EGlpNumSign(a) ((a) = -(a))

/* ========================================================================= */
/** @brief return the closest int value of the given pointer number.
 * @param a EGlpNum_t number that we will be transformed to int.
 * @return int the closest int representation of the given number.
 * par Description:
 * return the int number closest in value to the value stored in a.
 * */
#define fp20_EGlpNumToLf(a) (((double)(a))/fp20_oneLpNum)

/* ========================================================================= */
/** @brief initialize the internal memory of a given variable */
#define fp20_EGlpNumInitVar(a) fp20_EGlpNumZero(a)

/* ========================================================================= */
/** @brief free the internal memory of a given variable */
#define fp20_EGlpNumClearVar(a)

/* ========================================================================= */
/** @} */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef __EG_LPNUM_INT__
#define __EG_LPNUM_INT__
/** @file
 * @ingroup EGlpNum */
/** @addtogroup EGlpNum */
/** @{ */
/* ========================================================================= */
/** extern definitions of constants for different set-ups */
#define int_zeroLpNum 0
#define int_oneLpNum  1
#define int_epsLpNum  0
#define int_MaxLpNum INT_MAX
#define int_MinLpNum INT_MIN

/* ========================================================================= */
/** @brief Read from a string a number and store it in the given int, 
 * @return the number of chars readed from the input string */
#define int_EGlpNumReadStr(a,str) ({\
	int __i =0;\
	sscanf(str,"%d%n",&(a),&__i);\
	__i;})

/* ========================================================================= */
/** @brief given a int, write it to a string (to be allocated internally), 
 * and return it. */
#define int_EGlpNumGetStr(a) ({\
	char *__str=0;\
	size_t __i=snprintf(__str,(size_t)0,"%d",a);\
	__str = EGsMalloc(char,__i+1);\
	snprintf(__str,__i+1,"%d",a);\
	__str;})

/* ========================================================================= */
/** @brief given an array of type int, free it, if the pointer is NULL
 * nothing happen. */
#define int_EGlpNumFreeArray(ea) __EGlpNumFreeArray(ea)

/* ========================================================================= */
/** @brief Reallocate and initialize (if needed) 'size' elements of type 
 * EGlpNum_t and return it, if no more memory, exit(1) */
#define int_EGlpNumReallocArray(lptr, lsize) ({\
	size_t __csz = (lsize), *__usp = 0;\
	size_t __psz = __EGlpNumArraySize(*lptr);\
	int** __ptr__ = (lptr);\
	if (!__psz) *__ptr__ = int_EGlpNumAllocArray (__csz); \
	else if (__psz < __csz) {\
		__usp = (size_t*)(*__ptr__);\
		__usp--;\
		__usp = EGrealloc(__usp, sizeof(int)*__csz+sizeof(size_t));\
		__usp[0] = __csz;\
		*__ptr__ = (int*)(__usp+1);\
	}\
	*__ptr__;})

/* ========================================================================= */
/** @brief Allocate and initialize (if needed) 'size' elements of type int
 * and return it, if no more memory, exit(1) */
#define int_EGlpNumAllocArray(size) __EGlpNumAllocArray(int,size)

/* ========================================================================= */
/** @brief set the given number pointer, set its value to the given int.
 * @param var int where we will store the int value.
 * @param dbl_var int value to be stored in 'var'.
 * @par Description:
 * This function is intended to set initial values to variables; note that the
 * int is a number and not a pointer to that value, be carefull with this
 * detail. Also, due to implementation details this function can't deal with
 * numbers above 1e158 or smaller than 1e-158. Note also that if the number is
 * writen in the form \f$x=\bar{x}\cdot 2^e\f$ with \f$0.5<|\bar{x}|<1\f$, 
 * then \f$\left|x-\frac{p}{q}\right|<2^{e-64}\f$.
 * */
#define int_EGlpNumSet(var, dbl_var) ((var) = (dbl_var))

/* ========================================================================= */
/** @brief Stores in the first number the ceil value of the second number, i.e.
 * EGlpNumCeil(a,b) <==> a= ceil(b) */
#define int_EGlpNumCeil(a, b) int_EGlpNumSet(a,b)

/* ========================================================================= */
/** @brief Stores in the first number the floor value of the second number, i.e.
 * EGlpNumFloor(a,b) <==> a= floor(b) */
#define int_EGlpNumFloor(a, b) int_EGlpNumSet(a,b)

/* ========================================================================= */
/** @brief store the (multiplicative) inverse of a number to itself, i.e.
 * implement a = 1/a.
 * @param a the number to be inverted. */
#define int_EGlpNumInv(a) ((a) = 1/(a))

/* ========================================================================= */
/** @brief Compare if two numbers are equal within a maximum error.
 * @param a EGlpNum_t first number to compare.
 * @param b EGlpNum_t second number to compare.
 * @return int one in success, zero oterwise.
 * @par Description:
 * Given two numbers 'a','b' return 1 if a == b, otherwise it return 0
 * */
#define int_EGlpNumIsEqqual(a,b) ((a) == (b))

/* ========================================================================= */
/** @brief Compare if two numbers are equal within a maximum error.
 * @param a EGlpNum_t first number to compare.
 * @param b EGlpNum_t second number to compare.
 * @param error EGlpNum_t maximum difference allowed between both
 * numbers.
 * @return int one in success, zero oterwise.
 * @par Description:
 * Given two numbers 'a','b' and a tolerance 'error',
 * return 1 if |a-b|<= error, otherwise it return 0.
 * */
#define int_EGlpNumIsEqual(a,b,error) (EGabs((a)-(b)) <= (error))
#define int_EGlpNumIsNeq(a,b,error) (((a)-(b) > (error)) || ((b)-(a) > (error)))
#define int_EGlpNumIsNeqq(a,b)  ((a) != (b))
#define int_EGlpNumIsNeqZero(a,error) (((a) > (error)) || (-(a) > (error)))
#define int_EGlpNumIsNeqqZero(a)     	((a) != 0)

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a < b, zero
 * otherwise.
 * */
#define int_EGlpNumIsLess(a,b) (a < b)

/* ========================================================================= */
/** @brief test if a numer is greater than zero
 * @param a number to test
 * @return int one if success, zero otherwise.
 * */
#define int_EGlpNumIsGreatZero(a) (a > 0)

/* ========================================================================= */
/** @brief test if a numer is less than zero
 * @param a number to test
 * @return int one if success, zero otherwise.
 * */
#define int_EGlpNumIsLessZero(a) (a < 0)

/* ========================================================================= */
/** @brief test if the sum of the first two numbers is less thatn the third
 * number.
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @param c EGlpNum_t the third number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given a,b, and c, return nonzero if (a + b < c), zero toherwise.
 * */
#define int_EGlpNumIsSumLess(a, b, c) ((a) + (b) < (c))

/* ========================================================================= */
/** @brief test if the diference of the first two numbers is less thatn the 
 * third number.
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @param c EGlpNum_t the third number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given a,b, and c, return nonzero if (a - b < c), zero toherwise.
 * */
#define int_EGlpNumIsDiffLess(a, b, c) ((a) - (b) < (c))

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b int the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a < b, zero
 * otherwise.
 * */
#define int_EGlpNumIsLessDbl(a,b) ((a) < (b))

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b int the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a > b, zero
 * otherwise.
 * */
#define int_EGlpNumIsGreaDbl(a,b) ((a) > (b))

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a <= b, zero
 * otherwise.
 * */
#define int_EGlpNumIsLeq(a,b) ((a) <= (b))

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param a EGlpNum_t source number (it won't change value).
 * @param b EGlpNum_t source number (it won't change value).
 * @param den EGlpNum_t denominator of the difference (it won't change value).
 * @param dest EGlpNum_t where to store the value .
 * @par Description:
 * Set dest = (a - b) / den */
#define int_EGlpNumCopyDiffRatio(dest,a, b, den) ((dest) = ((a) - (b)) / (den))

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param a EGlpNum_t source number (it won't change value).
 * @param b EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the value stored in 'orig'.
 * @par Description:
 * Set dest = a - b */
#define int_EGlpNumCopyDiff(dest,a,b) ((dest) = (a) - (b))

/* ========================================================================= */
/** @brief copy the value of the sum of the second and third parameter
 * @param a EGlpNum_t source number (it won't change value).
 * @param b EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the sum.
 * @par Description:
 * Set dest = a + b */
#define int_EGlpNumCopySum(dest,a,b) ((dest) = (a) + (b))

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param orig EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the value stored in 'orig'.
 * @par Description:
 * Given two numbers copy the values in 'orig', into 'dest'.
 * */
#define int_EGlpNumCopy(dest,orig) ((dest) = (orig))

/* ========================================================================= */
/** @brief change the fist number to the maximum between itself and the 
 * absolute value of the second.
 * @param orig EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the value stored in 'orig'.
 * @par Description:
 * implement dest = max(dest,abs(orig))
 * */
#define int_EGlpNumSetToMaxAbs(dest, orig) if((dest) < EGabs(orig)) \
																							(dest) = EGabs(orig)
#define int_EGlpNumSetToMinAbs(dest, orig) if((dest) > EGabs(orig)) \
																							(dest) = EGabs(orig)

/* ========================================================================= */
/** @brief copy the square of the second argument, divided by the third 
 * argument into the first argument.
 * @param dest EGlpNum_t where to store the result
 * @param orig EGlpNum_t second parameter
 * @param den EGlpNum_t third parameter
 * @par Description:
 * compute dest = (orig*orig)/den
 * */
#define int_EGlpNumCopySqrOver(dest, orig, den) ((dest) = (orig)*(orig)/(den))

/* ========================================================================= */
/** @brief copy the value of the absolute value of the second parameter to the 
 * first parameter.
 * @param orig EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the absolute value stored
 * in 'orig'.
 * @par Description:
 * Given a number 'orig', copy its absolute value to 'dest'. i.e.
 * dest = |orig|
 * */
#define int_EGlpNumCopyAbs(dest,orig) ((dest) = EGabs(orig))

/* ========================================================================= */
/** @brief copy minus the value of the second parameter to the 
 * first parameter.
 * @param orig EGlpNum_t the source number (it won't change value).
 * @param dest EGlpNum_t where to store minus the value stored
 * in 'orig'.
 * @par Description:
 * Given a number 'orig', copy minus the value to 'dest'. i.e.
 * dest = -orig
 * */
#define int_EGlpNumCopyNeg(dest,orig) ((dest) = -(orig))

/* ========================================================================= */
/** @brief Set des = op1/op2.
 * @param dest EGlpNum_t where we will store the result.
 * @param op1 EGlpNum_t numerator of the fraction (possibly non an integer)
 * @param op2 EGlpNum_t denominator of the fraction (possibly non an integer)
 * @par Description:
 *  Set des = op1/op2
 * */
#define int_EGlpNumCopyFrac(dest,op1,op2) ((dest) = (op1)/(op2))

/* ========================================================================= */
/** @brief copy the first 'size' values in the second array to the first array.
 * @param orig EGlpNum_t* pointer to the array from where we will copy the
 * values (it won't change value).
 * @param dest EGlpNum_t* pointer to where to store the first 'size' values 
 * stored in 'orig'.
 * @param size unsigned int specifying how many values of 'orig' will be copied
 * onto 'dest'
 * @par Description:
 * This function is provided to (possible) make fast copies of arrays of
 * numbers, the arrays should be of length at least 'size', and the resulting
 * copy is absolutely independent froom the original, any change in one vale of
 * one array won't change values on the other array.
 * */
#define int_EGlpNumCopyArray(dest,orig,size) memcpy(dest,orig,sizeof(int)*(size))

/* ========================================================================= */
/** @brief Sub to a given number the product of two numbers.
 * @param a EGlpNum_t the number that we are going to Sub to.
 * @param b EGlpNum_t value to be multiplyed.
 * @param c EGlpNum_t value to be multiplyed.
 * @par Description:
 * This function implements a = a - b*c, and clearly don't change the value
 * stored in 'b' nor in 'c'.
 * */
#define int_EGlpNumSubInnProdTo(a, b, c) ((a) -= (b)*(c))

/* ========================================================================= */
/** @brief Add to a given number the product of two numbers.
 * @param a EGlpNum_t the number that we are going to add to.
 * @param b EGlpNum_t value to be multiplyed.
 * @param c EGlpNum_t value to be multiplyed.
 * @par Description:
 * This function implements a = a + b*c, and clearly don't change the value
 * stored in 'b' nor in 'c'.
 * */
#define int_EGlpNumAddInnProdTo(a, b, c) ((a) += (b)*(c))

/* ========================================================================= */
/** @brief Substract to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to substract to.
 * @param b unsigned int value to be substracted to 'a'.
 * @par Description:
 * This function implements a = a - b, and clearly don't change the value
 * stored in 'b'.
 * */
#define int_EGlpNumSubUiTo(a,b) ((a) -= (b))

/* ========================================================================= */
/** @brief Add to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to add to.
 * @param b unsigned int value to be added to 'a'.
 * @par Description:
 * This function implements a = a + b, and clearly don't change the value
 * stored in 'b'.
 * */
#define int_EGlpNumAddUiTo(a,b) ((a) += (b))

/* ========================================================================= */
/** @brief Add to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to add to.
 * @param b EGlpNum_t value to be added to 'a'.
 * @par Description:
 * This function implements a = a + b, and clearly don't change the value
 * stored in 'b'.
 * */
#define int_EGlpNumAddTo(a,b) ((a) += (b))

/* ========================================================================= */
/** @brief Substract to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to substract
 * from.
 * @param b EGlpNum_t value to be substracted to 'a'.
 * @par Description:
 * This function implements a = a - b, and clearly don't change the value
 * stored in 'b'.
 * */
#define int_EGlpNumSubTo(a,b) ((a) -= (b))

/* ========================================================================= */
/** @brief Multiply a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to multiply by
 * the second number and store the result.
 * @param b EGlpNum_t value to be multyply to 'a'.
 * @par Description:
 * This function implements a = a * b, and clearly don't change the value
 * stored in 'b'.
 * */
#define int_EGlpNumMultTo(a,b) ((a) *= (b))

/* ========================================================================= */
/** @brief Divide a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to divide by
 * the second number and store the result.
 * @param b EGlpNum_t value to be divide to 'a'.
 * @par Description:
 * This function implements a = a / b, and clearly don't change the value
 * stored in 'b'.
 * */
#define int_EGlpNumDivTo(a,b) ((a) /= (b))

/* ========================================================================= */
/** @brief Divide a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to divide by
 * the second number and store the result.
 * @param b unsigned int value to be divided to 'a'.
 * @par Description:
 * This function implements a = a / b, and don't change the value
 * stored in 'b'.
 * */
#define int_EGlpNumDivUiTo(a,b) ((a) /= (b))

/* ========================================================================= */
/** @brief Multiply a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to multiply by
 * the second number and store the result.
 * @param b unsigned int value to be multyply to 'a'.
 * @par Description:
 * This function implements a = a * b, and clearly don't change the value
 * stored in 'b'.
 * */
#define int_EGlpNumMultUiTo(a,b) ((a) *= (b))

/* ========================================================================= */
/** @brief Reset the value of the pointed number to zero.
 * @param a EGlpNum_t the value to be set to zero.
 * @par Descrpition:
 * Reset a to zero, i.e. implements a = 0;
 * */
#define int_EGlpNumZero(a) ((a) = 0)

/* ========================================================================= */
/** @brief Reset the value of the pointed number to one.
 * @param a EGlpNum_t value to be set to one.
 * @par Descrpition:
 * Reset a to zero, i.e. implements a = 1;
 * */
#define int_EGlpNumOne(a) ((a) = 1)

/* ========================================================================= */
/** @brief Change the sign of the number.
 * @param a EGlpNum_t number we will change sign.
 * @par Descrpition:
 * Change the sign of the given number, i.e. implements a = -a
 * */
#define int_EGlpNumSign(a) ((a) = -(a))

/* ========================================================================= */
/** @brief return the closest int value of the given pointer number.
 * @param a EGlpNum_t number that we will be transformed to int.
 * @return int the closest int representation of the given number.
 * par Description:
 * return the int number closest in value to the value stored in a.
 * */
#define int_EGlpNumToLf(a) ((double)a)

/* ========================================================================= */
/** @brief initialize the internal memory of a given variable */
#define int_EGlpNumInitVar(a) int_EGlpNumZero(a)

/* ========================================================================= */
/** @brief free the internal memory of a given variable */
#define int_EGlpNumClearVar(a)

/* ========================================================================= */
/** @} */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef __EG_LPNUM_LINT__
#define __EG_LPNUM_LINT__
/** @file
 * @ingroup EGlpNum */
/** @addtogroup EGlpNum */
/** @{ */
/* ========================================================================= */
/** extern definitions of constaants for different set-ups */
#define llint_zeroLpNum 0LL
#define llint_oneLpNum  1LL
#define llint_epsLpNum  0LL
#define llint_MaxLpNum  LLONG_MAX
#define llint_MinLpNum  LLONG_MIN

/* ========================================================================= */
/** @brief Read from a string a number and store it in the given long long int, 
 * @return the number of chars readed from the input string */
#define llint_EGlpNumReadStr(a,str) ({\
	long long int __i =0;\
	sscanf(str,"%lld%n",&(a),&__i);\
	__i;})

/* ========================================================================= */
/** @brief given a long long int, write it to a string (to be allocated internally), 
 * and return it. */
#define llint_EGlpNumGetStr(a) ({\
	char *__str=0;\
	size_t __i=snprintf(__str,(size_t)0,"%lld",a);\
	__str = EGsMalloc(char,__i+1);\
	snprintf(__str,__i+1,"%lld",a);\
	__str;})

/* ========================================================================= */
/** @brief given an array of type long long int, free it, if the pointer is NULL
 * nothing happen. */
#define llint_EGlpNumFreeArray(ea) __EGlpNumFreeArray(ea)

/* ========================================================================= */
/** @brief Reallocate and initialize (if needed) 'size' elements of type 
 * EGlpNum_t and return it, if no more memory, exit(1) */
#define llint_EGlpNumReallocArray(lptr, lsize) ({\
	size_t __csz = (lsize), *__usp = 0;\
	size_t __psz = __EGlpNumArraySize(*lptr);\
	long long int** __ptr__ = (lptr);\
	if (!__psz) *__ptr__ = llint_EGlpNumAllocArray (__csz); \
	else if (__psz < __csz) {\
		__usp = (size_t*)(*__ptr__);\
		__usp--;\
		__usp = EGrealloc(__usp, sizeof(long long int)*__csz+sizeof(size_t));\
		__usp[0] = __csz;\
		*__ptr__ = (long long int*)(__usp+1);\
	}\
	*__ptr__;})

/* ========================================================================= */
/** @brief Allocate and initialize (if needed) 'size' elements of type long long int
 * and return it, if no more memory, exit(1) */
#define llint_EGlpNumAllocArray(size) __EGlpNumAllocArray(long long int,size)

/* ========================================================================= */
/** @brief set the given number pointer, set its value to the given long long int.
 * @param var long long int where we will store the long long int value.
 * @param dbl_var long long int value to be stored in 'var'.
 * @par Description:
 * This function is intended to set initial values to variables; note that the
 * long long int is a number and not a pointer to that value, be carefull with this
 * detail. Also, due to implementation details this function can't deal with
 * numbers above 1e158 or smaller than 1e-158. Note also that if the number is
 * writen in the form \f$x=\bar{x}\cdot 2^e\f$ with \f$0.5<|\bar{x}|<1\f$, 
 * then \f$\left|x-\frac{p}{q}\right|<2^{e-64}\f$.
 * */
#define llint_EGlpNumSet(var, dbl_var) ((var) = (dbl_var))

/* ========================================================================= */
/** @brief Stores in the first number the ceil value of the second number, i.e.
 * EGlpNumCeil(a,b) <==> a= ceil(b) */
#define llint_EGlpNumCeil(a, b) llint_EGlpNumSet(a,b)

/* ========================================================================= */
/** @brief Stores in the first number the floor value of the second number, i.e.
 * EGlpNumFloor(a,b) <==> a= floor(b) */
#define llint_EGlpNumFloor(a, b) llint_EGlpNumSet(a,b)

/* ========================================================================= */
/** @brief store the (multiplicative) inverse of a number to itself, i.e.
 * implement a = 1/a.
 * @param a the number to be inverted. */
#define llint_EGlpNumInv(a) ((a) = 1/(a))

/* ========================================================================= */
/** @brief Compare if two numbers are equal within a maximum error.
 * @param a EGlpNum_t first number to compare.
 * @param b EGlpNum_t second number to compare.
 * @return long long int one in success, zero oterwise.
 * @par Description:
 * Given two numbers 'a','b' return 1 if a == b, otherwise it return 0
 * */
#define llint_EGlpNumIsEqqual(a,b) ((a) == (b))

/* ========================================================================= */
/** @brief Compare if two numbers are equal within a maximum error.
 * @param a EGlpNum_t first number to compare.
 * @param b EGlpNum_t second number to compare.
 * @param error EGlpNum_t maximum difference allowed between both
 * numbers.
 * @return long long int one in success, zero oterwise.
 * @par Description:
 * Given two numbers 'a','b' and a tolerance 'error',
 * return 1 if |a-b|<= error, otherwise it return 0.
 * */
#define llint_EGlpNumIsEqual(a,b,error) (EGabs((a)-(b)) <= (error))
#define llint_EGlpNumIsNeq(a,b,error) (((a)-(b) > (error)) || ((b)-(a) > (error)))
#define llint_EGlpNumIsNeqq(a,b)  ((a) != (b))
#define llint_EGlpNumIsNeqZero(a,error) (((a) > (error)) || (-(a) > (error)))
#define llint_EGlpNumIsNeqqZero(a)     	((a) != 0)

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @return long long int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a < b, zero
 * otherwise.
 * */
#define llint_EGlpNumIsLess(a,b) (a < b)

/* ========================================================================= */
/** @brief test if a number is greater than zero
 * @param a number to test
 * @return long long int one if success, zero otherwise.
 * */
#define llint_EGlpNumIsGreatZero(a) (a > 0)

/* ========================================================================= */
/** @brief test if a number is bellow zero
 * @param a number to test
 * @return long long int one if success, zero otherwise.
 * */
#define llint_EGlpNumIsLessZero(a) (a < 0)

/* ========================================================================= */
/** @brief test if the sum of the first two numbers is less thatn the third
 * number.
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @param c EGlpNum_t the third number
 * @return long long int one if success, zero otherwise.
 * @par Description:
 * Given a,b, and c, return nonzero if (a + b < c), zero toherwise.
 * */
#define llint_EGlpNumIsSumLess(a, b, c) ((a) + (b) < (c))

/* ========================================================================= */
/** @brief test if the diference of the first two numbers is less thatn the 
 * third number.
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @param c EGlpNum_t the third number
 * @return long long int one if success, zero otherwise.
 * @par Description:
 * Given a,b, and c, return nonzero if (a - b < c), zero toherwise.
 * */
#define llint_EGlpNumIsDiffLess(a, b, c) ((a) - (b) < (c))

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b long long int the second number
 * @return long long int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a < b, zero
 * otherwise.
 * */
#define llint_EGlpNumIsLessDbl(a,b) ((a) < (b))

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b long long int the second number
 * @return long long int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a > b, zero
 * otherwise.
 * */
#define llint_EGlpNumIsGreaDbl(a,b) ((a) > (b))

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @return long long int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a <= b, zero
 * otherwise.
 * */
#define llint_EGlpNumIsLeq(a,b) ((a) <= (b))

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param a EGlpNum_t source number (it won't change value).
 * @param b EGlpNum_t source number (it won't change value).
 * @param den EGlpNum_t denominator of the difference (it won't change value).
 * @param dest EGlpNum_t where to store the value .
 * @par Description:
 * Set dest = (a - b) / den */
#define llint_EGlpNumCopyDiffRatio(dest,a, b, den) ((dest) = ((a) - (b)) / (den))

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param a EGlpNum_t source number (it won't change value).
 * @param b EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the value stored in 'orig'.
 * @par Description:
 * Set dest = a - b */
#define llint_EGlpNumCopyDiff(dest,a,b) ((dest) = (a) - (b))

/* ========================================================================= */
/** @brief copy the value of the sum of the second and third parameter
 * @param a EGlpNum_t source number (it won't change value).
 * @param b EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the sum.
 * @par Description:
 * Set dest = a + b */
#define llint_EGlpNumCopySum(dest,a,b) ((dest) = (a) + (b))

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param orig EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the value stored in 'orig'.
 * @par Description:
 * Given two numbers copy the values in 'orig', into 'dest'.
 * */
#define llint_EGlpNumCopy(dest,orig) ((dest) = (orig))

/* ========================================================================= */
/** @brief change the fist number to the maximum between itself and the 
 * absolute value of the second.
 * @param orig EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the value stored in 'orig'.
 * @par Description:
 * implement dest = max(dest,abs(orig))
 * */
#define llint_EGlpNumSetToMaxAbs(dest, orig) if((dest) < EGabs(orig)) \
																							(dest) = EGabs(orig)
#define llint_EGlpNumSetToMinAbs(dest, orig) if((dest) > EGabs(orig)) \
																							(dest) = EGabs(orig)

/* ========================================================================= */
/** @brief copy the square of the second argument, divided by the third 
 * argument into the first argument.
 * @param dest EGlpNum_t where to store the result
 * @param orig EGlpNum_t second parameter
 * @param den EGlpNum_t third parameter
 * @par Description:
 * compute dest = (orig*orig)/den
 * */
#define llint_EGlpNumCopySqrOver(dest, orig, den) ((dest) = (orig)*(orig)/(den))

/* ========================================================================= */
/** @brief copy the value of the absolute value of the second parameter to the 
 * first parameter.
 * @param orig EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the absolute value stored
 * in 'orig'.
 * @par Description:
 * Given a number 'orig', copy its absolute value to 'dest'. i.e.
 * dest = |orig|
 * */
#define llint_EGlpNumCopyAbs(dest,orig) ((dest) = EGabs(orig))

/* ========================================================================= */
/** @brief copy minus the value of the second parameter to the 
 * first parameter.
 * @param orig EGlpNum_t the source number (it won't change value).
 * @param dest EGlpNum_t where to store minus the value stored
 * in 'orig'.
 * @par Description:
 * Given a number 'orig', copy minus the value to 'dest'. i.e.
 * dest = -orig
 * */
#define llint_EGlpNumCopyNeg(dest,orig) ((dest) = -(orig))

/* ========================================================================= */
/** @brief Set des = op1/op2.
 * @param dest EGlpNum_t where we will store the result.
 * @param op1 EGlpNum_t numerator of the fraction (possibly non an integer)
 * @param op2 EGlpNum_t denominator of the fraction (possibly non an integer)
 * @par Description:
 *  Set des = op1/op2
 * */
#define llint_EGlpNumCopyFrac(dest,op1,op2) ((dest) = (op1)/(op2))

/* ========================================================================= */
/** @brief copy the first 'size' values in the second array to the first array.
 * @param orig EGlpNum_t* pointer to the array from where we will copy the
 * values (it won't change value).
 * @param dest EGlpNum_t* pointer to where to store the first 'size' values 
 * stored in 'orig'.
 * @param size unsigned long long int specifying how many values of 'orig' will be copied
 * onto 'dest'
 * @par Description:
 * This function is provided to (possible) make fast copies of arrays of
 * numbers, the arrays should be of length at least 'size', and the resulting
 * copy is absolutely independent froom the original, any change in one vale of
 * one array won't change values on the other array.
 * */
#define llint_EGlpNumCopyArray(dest,orig,size) memcpy(dest,orig,sizeof(long long int)*(size))

/* ========================================================================= */
/** @brief Sub to a given number the product of two numbers.
 * @param a EGlpNum_t the number that we are going to Sub to.
 * @param b EGlpNum_t value to be multiplyed.
 * @param c EGlpNum_t value to be multiplyed.
 * @par Description:
 * This function implements a = a - b*c, and clearly don't change the value
 * stored in 'b' nor in 'c'.
 * */
#define llint_EGlpNumSubInnProdTo(a, b, c) ((a) -= (b)*(c))

/* ========================================================================= */
/** @brief Add to a given number the product of two numbers.
 * @param a EGlpNum_t the number that we are going to add to.
 * @param b EGlpNum_t value to be multiplyed.
 * @param c EGlpNum_t value to be multiplyed.
 * @par Description:
 * This function implements a = a + b*c, and clearly don't change the value
 * stored in 'b' nor in 'c'.
 * */
#define llint_EGlpNumAddInnProdTo(a, b, c) ((a) += (b)*(c))

/* ========================================================================= */
/** @brief Substract to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to substract to.
 * @param b unsigned long long int value to be substracted to 'a'.
 * @par Description:
 * This function implements a = a - b, and clearly don't change the value
 * stored in 'b'.
 * */
#define llint_EGlpNumSubUiTo(a,b) ((a) -= (b))

/* ========================================================================= */
/** @brief Add to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to add to.
 * @param b unsigned long long int value to be added to 'a'.
 * @par Description:
 * This function implements a = a + b, and clearly don't change the value
 * stored in 'b'.
 * */
#define llint_EGlpNumAddUiTo(a,b) ((a) += (b))

/* ========================================================================= */
/** @brief Add to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to add to.
 * @param b EGlpNum_t value to be added to 'a'.
 * @par Description:
 * This function implements a = a + b, and clearly don't change the value
 * stored in 'b'.
 * */
#define llint_EGlpNumAddTo(a,b) ((a) += (b))

/* ========================================================================= */
/** @brief Substract to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to substract
 * from.
 * @param b EGlpNum_t value to be substracted to 'a'.
 * @par Description:
 * This function implements a = a - b, and clearly don't change the value
 * stored in 'b'.
 * */
#define llint_EGlpNumSubTo(a,b) ((a) -= (b))

/* ========================================================================= */
/** @brief Multiply a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to multiply by
 * the second number and store the result.
 * @param b EGlpNum_t value to be multyply to 'a'.
 * @par Description:
 * This function implements a = a * b, and clearly don't change the value
 * stored in 'b'.
 * */
#define llint_EGlpNumMultTo(a,b) ((a) *= (b))

/* ========================================================================= */
/** @brief Divide a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to divide by
 * the second number and store the result.
 * @param b EGlpNum_t value to be divide to 'a'.
 * @par Description:
 * This function implements a = a / b, and clearly don't change the value
 * stored in 'b'.
 * */
#define llint_EGlpNumDivTo(a,b) ((a) /= (b))

/* ========================================================================= */
/** @brief Divide a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to divide by
 * the second number and store the result.
 * @param b unsigned long long int value to be divided to 'a'.
 * @par Description:
 * This function implements a = a / b, and don't change the value
 * stored in 'b'.
 * */
#define llint_EGlpNumDivUiTo(a,b) ((a) /= (b))

/* ========================================================================= */
/** @brief Multiply a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to multiply by
 * the second number and store the result.
 * @param b unsigned long long int value to be multyply to 'a'.
 * @par Description:
 * This function implements a = a * b, and clearly don't change the value
 * stored in 'b'.
 * */
#define llint_EGlpNumMultUiTo(a,b) ((a) *= (b))

/* ========================================================================= */
/** @brief Reset the value of the pointed number to zero.
 * @param a EGlpNum_t the value to be set to zero.
 * @par Descrpition:
 * Reset a to zero, i.e. implements a = 0;
 * */
#define llint_EGlpNumZero(a) ((a) = 0)

/* ========================================================================= */
/** @brief Reset the value of the pointed number to one.
 * @param a EGlpNum_t value to be set to one.
 * @par Descrpition:
 * Reset a to zero, i.e. implements a = 1;
 * */
#define llint_EGlpNumOne(a) ((a) = 1)

/* ========================================================================= */
/** @brief Change the sign of the number.
 * @param a EGlpNum_t number we will change sign.
 * @par Descrpition:
 * Change the sign of the given number, i.e. implements a = -a
 * */
#define llint_EGlpNumSign(a) ((a) = -(a))

/* ========================================================================= */
/** @brief return the closest long long int value of the given pointer number.
 * @param a EGlpNum_t number that we will be transformed to long long int.
 * @return long long int the closest long long int representation of the given number.
 * par Description:
 * return the long long int number closest in value to the value stored in a.
 * */
#define llint_EGlpNumToLf(a) (a)

/* ========================================================================= */
/** @brief initialize the internal memory of a given variable */
#define llint_EGlpNumInitVar(a) llint_EGlpNumZero(a)

/* ========================================================================= */
/** @brief free the internal memory of a given variable */
#define llint_EGlpNumClearVar(a)

/* ========================================================================= */
/** @} */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License,or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful,but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not,write to the Free Software Foundation,
 * Inc.,51 Franklin St,Fifth Floor,Boston,MA  02110-1301  USA 
 * */
#ifndef __EG_LPNUM_INT32__
#define __EG_LPNUM_INT32__
/** @file
 * @ingroup EGlpNum */
/** @addtogroup EGlpNum */
/** @{ */
/*=========================================================================*/
/** extern definitions of constaants for different set-ups */
#define int32_zeroLpNum 0
#define int32_oneLpNum  1
#define int32_epsLpNum  0
#define int32_MaxLpNum INT32_MAX
#define int32_MinLpNum INT32_MIN

/*=========================================================================*/
/** @brief Read from a string a number and store it in the given number,
 * @return the number of chars readed from the input string */
#define int32_EGlpNumReadStr(__EGPa__,__EGstr__) ({\
	int __i=0;\
	sscanf(__EGstr__,"%d%n",&(__EGPa__),&__i);\
	__i;})

/*=========================================================================*/
/** @brief given a number,write it to a string (to be allocated internally),
 * and return it. */
#define int32_EGlpNumGetStr(__EGPa__) ({\
	char *__str=0;\
	size_t __i=snprintf(__str,(size_t)0,"%d",__EGPa__);\
	__str=EGsMalloc(char,__i+1);\
	snprintf(__str,__i+1,"%d",__EGPa__);\
	__str;})

/*=========================================================================*/
/** @brief given an array of type number,free it,if the pointer is NULL
 * nothing happen. */
#define int32_EGlpNumFreeArray(__EGea__) __EGlpNumFreeArray(__EGea__)

/*=========================================================================*/
/** @brief Reallocate and initialize (if needed) '__EGlsz__' elements of type 
 * int32_t and return it,if no more memory,exit(1) */
#define int32_EGlpNumReallocArray(__EGpone__,__EGlsz__) ({\
	size_t __csz=(__EGlsz__),*__usp=0;\
	size_t __psz=__EGlpNumArraySize(*(__EGpone__));\
	int32_t** __ptr__=(__EGpone__);\
	if (!__psz) *__ptr__=int32_EGlpNumAllocArray (__csz); \
	else if (__psz < __csz) {\
		__usp=(size_t*)(*__ptr__);\
		__usp--;\
		__usp=EGrealloc(__usp,sizeof(int32_t)*__csz+sizeof(size_t));\
		__usp[0]=__csz;\
		*__ptr__=(int32_t*)(__usp+1);\
		memset((*__ptr__)+__psz,0,sizeof(int32_t)*(__csz-__psz));\
	}\
	*__ptr__;})

/*=========================================================================*/
/** @brief Allocate and initialize (if needed) '__EGsz__' elements of type int32_t
 * and return it,if no more memory,exit(1) */
#define int32_EGlpNumAllocArray(__EGsz__) __EGlpNumAllocArray(int32_t,__EGsz__)

/*=========================================================================*/
/** @brief set the given number pointer,set its value to the given double.
 * @param (__EGvone__) double where we will store the double value.
 * @param __EGdbl__ double value to be stored in '(__EGvone__)'.
 * @par Description:
 * This function is intended to set initial values to variables; note that the
 * double is (__EGPa__) number and not (__EGPa__) pointer to that value,be carefull with this
 * detail. Also,due to implementation details this function can't deal with
 * numbers above 1e158 or smaller than 1e-158. Note also that if the number is
 * writen in the form \f$x=\bar{x}\cdot 2^e\f$ with \f$0.5<|\bar{x}|<1\f$,
 * then \f$\left|x-\frac{p}{q}\right|<2^{e-64}\f$.
 * */
#define int32_EGlpNumSet(__EGvone__,__EGdbl__) ((__EGvone__)=(int32_t)(__EGdbl__))

/*=========================================================================*/
/** @brief Stores in the first number the ceil value of the second number,i.e.
 * EGlpNumCeil(__EGPa__,__EGPb__) <==> (__EGPa__)=ceil(__EGPb__) */
#define int32_EGlpNumCeil(__EGPa__,__EGPb__) (__EGPa__=__EGPb__)

/*=========================================================================*/
/** @brief Stores in the first number the floor value of the second number,i.e.
 * EGlpNumFloor(__EGPa__,__EGPb__) <==> (__EGPa__)=floor(__EGPb__) */
#define int32_EGlpNumFloor(__EGPa__,__EGPb__) (__EGPa__=__EGPb__)

/*=========================================================================*/
/** @brief store the (multiplicative) inverse of (__EGPa__) number to itself,i.e.
 * implement (__EGPa__)=1/(__EGPa__).
 * @param (__EGPa__) the number to be inverted. */
#define int32_EGlpNumInv(__EGPa__) ((__EGPa__)=0)

/*=========================================================================*/
/** @brief Compare if two numbers are equal within (__EGPa__) maximum (__EGPerr__).
 * @param (__EGPa__) EGlpNum_t first number to compare.
 * @param (__EGPb__) EGlpNum_t second number to compare.
 * @return int one in success,zero oterwise.
 * @par Description:
 * Given two numbers '(__EGPa__)','(__EGPb__)' return 1 if (__EGPa__)==(__EGPb__),otherwise it return 0
 * */
#define int32_EGlpNumIsEqqual(__EGPa__,__EGPb__) ((__EGPa__)==(__EGPb__))

/*=========================================================================*/
/** @brief Compare if two numbers are equal within (__EGPa__) maximum (__EGPerr__).
 * @param (__EGPa__) EGlpNum_t first number to compare.
 * @param (__EGPb__) EGlpNum_t second number to compare.
 * @param (__EGPerr__) EGlpNum_t maximum difference allowed between both
 * numbers.
 * @return int one in success,zero oterwise.
 * @par Description:
 * Given two numbers '(__EGPa__)','(__EGPb__)' and (__EGPa__) tolerance '(__EGPerr__)',
 * return 1 if |(__EGPa__)-(__EGPb__)|<=(__EGPerr__),otherwise it return 0.
 * */
#define int32_EGlpNumIsEqual(__EGPa__,__EGPb__,__EGPerr__) (EGabs((__EGPa__)-(__EGPb__))<=(__EGPerr__))
#define int32_EGlpNumIsNeq(__EGPa__,__EGPb__,__EGPerr__) (EGabs((__EGPa__)-(__EGPb__))>(__EGPerr__))
#define int32_EGlpNumIsNeqq(__EGPa__,__EGPb__)  ((__EGPa__)!=(__EGPb__))
#define int32_EGlpNumIsNeqZero(__EGPa__,__EGPerr__) (((__EGPa__)>(__EGPerr__))||(-(__EGPa__) > (__EGPerr__)))
#define int32_EGlpNumIsNeqqZero(__EGPa__)     	(__EGPa__)

/*=========================================================================*/
/** @brief test if the first number is greater than zero
 * @param (__EGPa__) EGlpNum_t number to test.
 * @return int one if success,zero otherwise.
 * */
#define int32_EGlpNumIsGreatZero(__EGPa__) ((__EGPa__)>0)

/*=========================================================================*/
/** @brief test if the first number is less than zero
 * @param (__EGPa__) EGlpNum_t number to test.
 * @return int one if success,zero otherwise.
 * */
#define int32_EGlpNumIsLessZero(__EGPa__) ((__EGPa__)<0)

/*=========================================================================*/
/** @brief test if the first number is bigger to the second number
 * @param (__EGPa__) EGlpNum_t the first number.
 * @param (__EGPb__) EGlpNum_t the second number
 * @return int one if success,zero otherwise.
 * @par Description:
 * Given two numbers '(__EGPa__)' and '(__EGPb__)',return one if (__EGPa__) < (__EGPb__),zero
 * otherwise.
 * */
#define int32_EGlpNumIsLess(__EGPa__,__EGPb__) ((__EGPa__)<(__EGPb__))

/*=========================================================================*/
/** @brief test if the sum of the first two numbers is less thatn the third
 * number.
 * @param (__EGPa__) EGlpNum_t the first number.
 * @param (__EGPb__) EGlpNum_t the second number
 * @param (__EGPc__) EGlpNum_t the third number
 * @return int one if success,zero otherwise.
 * @par Description:
 * Given (__EGPa__),__EGPb__,and (__EGPc__),return nonzero if ((__EGPa__) + (__EGPb__) < (__EGPc__)),zero toherwise.
 * */
#define int32_EGlpNumIsSumLess(__EGPa__,__EGPb__,__EGPc__) ((__EGPa__)+(__EGPb__)<(__EGPc__))

/*=========================================================================*/
/** @brief test if the diference of the first two numbers is less thatn the 
 * third number.
 * @param (__EGPa__) EGlpNum_t the first number.
 * @param (__EGPb__) EGlpNum_t the second number
 * @param (__EGPc__) EGlpNum_t the third number
 * @return int one if success,zero otherwise.
 * @par Description:
 * Given (__EGPa__),__EGPb__,and (__EGPc__),return nonzero if ((__EGPa__) - (__EGPb__) < (__EGPc__)),zero toherwise.
 * */
#define int32_EGlpNumIsDiffLess(__EGPa__,__EGPb__,__EGPc__) ((__EGPa__)-(__EGPb__)<(__EGPc__))

/*=========================================================================*/
/** @brief test if the first number is bigger to the second number
 * @param (__EGPa__) EGlpNum_t the first number.
 * @param (__EGPb__) double the second number
 * @return int one if success,zero otherwise.
 * @par Description:
 * Given two numbers '(__EGPa__)' and '(__EGPb__)',return one if (__EGPa__) < (__EGPb__),zero
 * otherwise.
 * */
#define int32_EGlpNumIsLessDbl(__EGPa__,__EGPb__) (((double)(__EGPa__)) < (__EGPb__))

/*=========================================================================*/
/** @brief test if the first number is bigger to the second number
 * @param (__EGPa__) EGlpNum_t the first number.
 * @param (__EGPb__) double the second number
 * @return int one if success,zero otherwise.
 * @par Description:
 * Given two numbers '(__EGPa__)' and '(__EGPb__)',return one if (__EGPa__) > (__EGPb__),zero
 * otherwise.
 * */
#define int32_EGlpNumIsGreaDbl(__EGPa__,__EGPb__) (((double)(__EGPa__)) > (__EGPb__))

/*=========================================================================*/
/** @brief test if the first number is bigger to the second number
 * @param (__EGPa__) EGlpNum_t the first number.
 * @param (__EGPb__) EGlpNum_t the second number
 * @return int one if success,zero otherwise.
 * @par Description:
 * Given two numbers '(__EGPa__)' and '(__EGPb__)',return one if (__EGPa__) <=(__EGPb__),zero
 * otherwise.
 * */
#define int32_EGlpNumIsLeq(__EGPa__,__EGPb__) ((__EGPa__)<=(__EGPb__))

/*=========================================================================*/
/** @brief copy the value of the second number to the first.
 * @param (__EGPa__) EGlpNum_t source number (it won't change value).
 * @param (__EGPb__) EGlpNum_t source number (it won't change value).
 * @param (__EGPdn__) EGlpNum_t denominator of the difference (it won't change value).
 * @param (__EGPd__) EGlpNum_t where to store the value .
 * @par Description:
 * Set (__EGPd__)=((__EGPa__) - (__EGPb__)) / (__EGPdn__) */
#define int32_EGlpNumCopyDiffRatio(__EGPd__,__EGPa__,__EGPb__,__EGPdn__) ((__EGPd__)=((__EGPa__)-(__EGPb__))/(__EGPdn__))

/*=========================================================================*/
/** @brief copy the value of the second number to the first.
 * @param (__EGPa__) EGlpNum_t source number (it won't change value).
 * @param (__EGPb__) EGlpNum_t source number (it won't change value).
 * @param (__EGPd__) EGlpNum_t where to store the value stored in '(__EGPo__)'.
 * @par Description:
 * Set (__EGPd__)=(__EGPa__) - (__EGPb__) */
#define int32_EGlpNumCopyDiff(__EGPd__,__EGPa__,__EGPb__) ((__EGPd__)=((__EGPa__)-(__EGPb__)))

/*=========================================================================*/
/** @brief copy the value of the sum of the second and third parameter
 * @param (__EGPa__) EGlpNum_t source number (it won't change value).
 * @param (__EGPb__) EGlpNum_t source number (it won't change value).
 * @param (__EGPd__) EGlpNum_t where to store the sum.
 * @par Description:
 * Set (__EGPd__)=(__EGPa__) + (__EGPb__) */
#define int32_EGlpNumCopySum(__EGPd__,__EGPa__,__EGPb__) ((__EGPd__)=((__EGPa__)+(__EGPb__)))

/*=========================================================================*/
/** @brief copy the value of the second number to the first.
 * @param (__EGPo__) EGlpNum_t source number (it won't change value).
 * @param (__EGPd__) EGlpNum_t where to store the value stored in '(__EGPo__)'.
 * @par Description:
 * Given two numbers copy the values in '(__EGPo__)',into '(__EGPd__)'.
 * */
#define int32_EGlpNumCopy(__EGPd__,__EGPo__) ((__EGPd__)=(__EGPo__))

/*=========================================================================*/
/** @brief change the fist number to the maximum between itself and the 
 * absolute value of the second.
 * @param (__EGPo__) EGlpNum_t source number (it won't change value).
 * @param (__EGPd__) EGlpNum_t where to store the value stored in '(__EGPo__)'.
 * @par Description:
 * implement (__EGPd__)=max(__EGPd__,abs(__EGPo__))
 * */
#define int32_EGlpNumSetToMaxAbs(__EGPd__,__EGPo__) ({\
	const int32_t __EGcv__=(__EGPo__)<0?(__EGPo__):-(__EGPo__);\
	__EGPd__=(__EGcv__)>(__EGPd__)?(__EGcv__):(__EGPd__);})
#define int32_EGlpNumSetToMinAbs(__EGPd__,__EGPo__) ({\
	const int32_t __EGcv__=(__EGPo__)<0?(__EGPo__):-(__EGPo__);\
	__EGPd__=(__EGcv__)<(__EGPd__)?(__EGcv__):(__EGPd__);})

/*=========================================================================*/
/** @brief copy the square of the second argument,divided by the third 
 * argument into the first argument.
 * @param (__EGPd__) EGlpNum_t where to store the result
 * @param (__EGPo__) EGlpNum_t second parameter
 * @param (__EGPdn__) EGlpNum_t third parameter
 * @par Description:
 * compute (__EGPd__)=((__EGPo__)*(__EGPo__))/(__EGPdn__)
 * */
#define int32_EGlpNumCopySqrOver(__EGPd__,__EGPo__,__EGPdn__) ((__EGPd__)=(__EGPo__)*(__EGPo__)/(__EGPdn__))

/*=========================================================================*/
/** @brief copy the value of the absolute value of the second parameter to the 
 * first parameter.
 * @param (__EGPo__) EGlpNum_t source number (it won't change value).
 * @param (__EGPd__) EGlpNum_t where to store the absolute value stored
 * in '(__EGPo__)'.
 * @par Description:
 * Given (__EGPa__) number '(__EGPo__)',copy its absolute value to '(__EGPd__)'. i.e.
 * (__EGPd__)=|(__EGPo__)|
 * */
#define int32_EGlpNumCopyAbs(__EGPd__,__EGPo__) ((__EGPd__)=((__EGPo__)<0?-(__EGPo__):(__EGPo__)))

/*=========================================================================*/
/** @brief copy minus the value of the second parameter to the 
 * first parameter.
 * @param (__EGPo__) EGlpNum_t the source number (it won't change value).
 * @param (__EGPd__) EGlpNum_t where to store minus the value stored
 * in '(__EGPo__)'.
 * @par Description:
 * Given (__EGPa__) number '(__EGPo__)',copy minus the value to '(__EGPd__)'. i.e.
 * (__EGPd__)=-(__EGPo__)
 * */
#define int32_EGlpNumCopyNeg(__EGPd__,__EGPo__) ((__EGPd__)=-(__EGPo__))

/*=========================================================================*/
/** @brief Set des=(__EGPone__)/(__EGPtwo__).
 * @param (__EGPd__) EGlpNum_t where we will store the result.
 * @param (__EGPone__) EGlpNum_t numerator of the fraction (possibly non an integer)
 * @param (__EGPtwo__) EGlpNum_t denominator of the fraction (possibly non an integer)
 * @par Description:
 *  Set des=(__EGPone__)/(__EGPtwo__)
 * */
#define int32_EGlpNumCopyFrac(__EGPd__,__EGPone__,__EGPtwo__) ((__EGPd__)=(__EGPone__)/(__EGPtwo__))

/*=========================================================================*/
/** @brief copy the first '(__EGsz__)' values in the second array to the first array.
 * @param (__EGPo__) EGlpNum_t* pointer to the array from where we will copy the
 * values (it won't change value).
 * @param (__EGPd__) EGlpNum_t* pointer to where to store the first '(__EGsz__)' values 
 * stored in '(__EGPo__)'.
 * @param (__EGsz__) unsigned int specifying how many values of '(__EGPo__)' will be copied
 * onto '(__EGPd__)'
 * @par Description:
 * This function is provided to (possible) make fast copies of arrays of
 * numbers,the arrays should be of length at least '(__EGsz__)',and the resulting
 * copy is absolutely independent froom the original,any change in one vale of
 * one array won't change values on the other array.
 * */
#define int32_EGlpNumCopyArray(__EGPd__,__EGPo__,__EGsz__) memcpy(__EGPd__,__EGPo__,sizeof(int32_t)*(__EGsz__))

/*=========================================================================*/
/** @brief Sub to (__EGPa__) given number the product of two numbers.
 * @param (__EGPa__) EGlpNum_t the number that we are going to Sub to.
 * @param (__EGPb__) EGlpNum_t value to be multiplyed.
 * @param (__EGPc__) EGlpNum_t value to be multiplyed.
 * @par Description:
 * This function implements (__EGPa__)=(__EGPa__) - (__EGPb__)*(__EGPc__),and clearly don't change the value
 * stored in '(__EGPb__)' nor in '(__EGPc__)'.
 * */
#define int32_EGlpNumSubInnProdTo(__EGPa__,__EGPb__,__EGPc__) ((__EGPa__)-=(__EGPb__)*(__EGPc__))

/*=========================================================================*/
/** @brief Add to (__EGPa__) given number the product of two numbers.
 * @param (__EGPa__) EGlpNum_t the number that we are going to add to.
 * @param (__EGPb__) EGlpNum_t value to be multiplyed.
 * @param (__EGPc__) EGlpNum_t value to be multiplyed.
 * @par Description:
 * This function implements (__EGPa__)=(__EGPa__) + (__EGPb__)*(__EGPc__),and clearly don't change the value
 * stored in '(__EGPb__)' nor in '(__EGPc__)'.
 * */
#define int32_EGlpNumAddInnProdTo(__EGPa__,__EGPb__,__EGPc__) ((__EGPa__)+=(__EGPb__)*(__EGPc__))

/*=========================================================================*/
/** @brief Substract to (__EGPa__) given number the value of the second number.
 * @param (__EGPa__) EGlpNum_t the number that we are going to substract to.
 * @param (__EGPb__) unsigned int value to be substracted to '(__EGPa__)'.
 * @par Description:
 * This function implements (__EGPa__)=(__EGPa__) - (__EGPb__),and clearly don't change the value
 * stored in '(__EGPb__)'.
 * */
#define int32_EGlpNumSubUiTo(__EGPa__,__EGPb__) ((__EGPa__)-=((int32_t)(__EGPb__)))

/*=========================================================================*/
/** @brief Add to (__EGPa__) given number the value of the second number.
 * @param (__EGPa__) EGlpNum_t the number that we are going to add to.
 * @param (__EGPb__) unsigned int value to be added to '(__EGPa__)'.
 * @par Description:
 * This function implements (__EGPa__)=(__EGPa__) + (__EGPb__),and clearly don't change the value
 * stored in '(__EGPb__)'.
 * */
#define int32_EGlpNumAddUiTo(__EGPa__,__EGPb__) ((__EGPa__)+=((int32_t)(__EGPb__)))

/*=========================================================================*/
/** @brief Add to (__EGPa__) given number the value of the second number.
 * @param (__EGPa__) EGlpNum_t the number that we are going to add to.
 * @param (__EGPb__) EGlpNum_t value to be added to '(__EGPa__)'.
 * @par Description:
 * This function implements (__EGPa__)=(__EGPa__) + (__EGPb__),and clearly don't change the value
 * stored in '(__EGPb__)'.
 * */
#define int32_EGlpNumAddTo(__EGPa__,__EGPb__) ((__EGPa__)+=(__EGPb__))

/*=========================================================================*/
/** @brief Substract to (__EGPa__) given number the value of the second number.
 * @param (__EGPa__) EGlpNum_t the number that we are going to substract
 * from.
 * @param (__EGPb__) EGlpNum_t value to be substracted to '(__EGPa__)'.
 * @par Description:
 * This function implements (__EGPa__)=(__EGPa__) - (__EGPb__),and clearly don't change the value
 * stored in '(__EGPb__)'.
 * */
#define int32_EGlpNumSubTo(__EGPa__,__EGPb__) ((__EGPa__)-=(__EGPb__))

/*=========================================================================*/
/** @brief Multiply (__EGPa__) given number by the value of the second number.
 * @param (__EGPa__) EGlpNum_t the number that we are going to multiply by
 * the second number and store the result.
 * @param (__EGPb__) EGlpNum_t value to be multyply to '(__EGPa__)'.
 * @par Description:
 * This function implements (__EGPa__)=(__EGPa__) * (__EGPb__),and clearly don't change the value
 * stored in '(__EGPb__)'.
 * */
#define int32_EGlpNumMultTo(__EGPa__,__EGPb__) ((__EGPa__)*=(__EGPb__))

/*=========================================================================*/
/** @brief Divide (__EGPa__) given number by the value of the second number.
 * @param (__EGPa__) EGlpNum_t the number that we are going to divide by
 * the second number and store the result.
 * @param (__EGPb__) EGlpNum_t value to be divide to '(__EGPa__)'.
 * @par Description:
 * This function implements (__EGPa__)=(__EGPa__) / (__EGPb__),and clearly don't change the value
 * stored in '(__EGPb__)'.
 * */
#define int32_EGlpNumDivTo(__EGPa__,__EGPb__) ((__EGPa__)/=(__EGPb__))

/*=========================================================================*/
/** @brief Divide (__EGPa__) given number by the value of the second number.
 * @param (__EGPa__) EGlpNum_t the number that we are going to divide by
 * the second number and store the result.
 * @param (__EGPb__) unsigned int value to be divided to '(__EGPa__)'.
 * @par Description:
 * This function implements (__EGPa__)=(__EGPa__) / (__EGPb__),and don't change the value
 * stored in '(__EGPb__)'.
 * */
#define int32_EGlpNumDivUiTo(__EGPa__,__EGPb__) ((__EGPa__)/=((int32_t)(__EGPb__)))

/*=========================================================================*/
/** @brief Multiply (__EGPa__) given number by the value of the second number.
 * @param (__EGPa__) EGlpNum_t the number that we are going to multiply by
 * the second number and store the result.
 * @param (__EGPb__) unsigned int value to be multyply to '(__EGPa__)'.
 * @par Description:
 * This function implements (__EGPa__)=(__EGPa__) * (__EGPb__),and clearly don't change the value
 * stored in '(__EGPb__)'.
 * */
#define int32_EGlpNumMultUiTo(__EGPa__,__EGPb__) ((__EGPa__)*=((int32_t)(__EGPb__)))

/*=========================================================================*/
/** @brief Reset the value of the pointed number to zero.
 * @param (__EGPa__) EGlpNum_t the value to be set to zero.
 * @par Descrpition:
 * Reset (__EGPa__) to zero,i.e. implements (__EGPa__)=0;
 * */
#define int32_EGlpNumZero(__EGPa__) ((__EGPa__)=0)

/*=========================================================================*/
/** @brief Reset the value of the pointed number to one.
 * @param (__EGPa__) EGlpNum_t value to be set to one.
 * @par Descrpition:
 * Reset (__EGPa__) to zero,i.e. implements (__EGPa__)=1;
 * */
#define int32_EGlpNumOne(__EGPa__) ((__EGPa__)=1)

/*=========================================================================*/
/** @brief Change the sign of the number.
 * @param (__EGPa__) EGlpNum_t number we will change sign.
 * @par Descrpition:
 * Change the sign of the given number,i.e. implements (__EGPa__)=-(__EGPa__)
 * */
#define int32_EGlpNumSign(__EGPa__) ((__EGPa__)=-(__EGPa__))

/*=========================================================================*/
/** @brief return the closest double value of the given pointer number.
 * @param (__EGPa__) EGlpNum_t number that we will be transformed to double.
 * @return double the closest double representation of the given number.
 * par Description:
 * return the double number closest in value to the value stored in (__EGPa__).
 * */
#define int32_EGlpNumToLf(__EGPa__) ((double)(__EGPa__))

/*=========================================================================*/
/** @brief initialize the internal memory of (__EGPa__) given variable */
#define int32_EGlpNumInitVar(__EGPa__) int32_EGlpNumZero(__EGPa__)

/*=========================================================================*/
/** @brief free the internal memory of (__EGPa__) given variable */
#define int32_EGlpNumClearVar(__EGPa__)

/* ========================================================================= */
/** @} */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/* bit operations over arbitrary memory segnemts 
 *
 * Version 0.0.1 2003-04-11
 *
 * - 2006-01-30
 * 		- Change some type definitions so that to make its behavior independent
 * 		of the plataform, we choose to use bit words of size 32 bits.
 * - 2005-08-01
 * 		- Fix some types to size_t for alloc/free functions
 * - 2004-11-05 
 * 		- Add EGbitsetSize macro to compute the wright size of static
 * 			bitsets.
 * - 2003-05-14 
 * 		- Fix problem in EGbitTest
 * - 2003-04-29 
 * 		- Change the parameters that are not changed to const.
 * 		- Change the definition of the function to 'extern inline int' to 
 * 			speed-up the running time for all funcions but EGbitNext.
 *
 * */
/* ========================================================================= */

#ifndef __EG_BIT_H__
#define __EG_BIT_H__
/* ============================================================================
   Bitset definitions and functions                                                                
   ==========================================================================*/


/* ========================================================================= */
/* EG_BIT options */
/* ========================================================================= */
/* the debug level indicates what is the minimum debug level to start generating
 * messages of the operation for this suit, by defoult is 10, note that the
 * lower the level, the more messages that we will generate. */
#ifndef __EGBIT_DEBUG_LEVEL__
#define __EGBIT_DEBUG_LEVEL__ 10
#endif

/* ========================================================================== */
/** @name Word lengths and related macros */
/* @{ */
#define __EGBIT_WORD_SIZE__ 32U
#define __EGBIT_SHIFT__ 5U
#define __EGBIT_MASK__ 31U
/* @} */

/* ========================================================================== */
/** @brief Macro to compute the right size of a bitset given the desired 
 * number of bits in the bitset */
#define EGbitsetSize(__Bsize) (((__Bsize)>>__EGBIT_SHIFT__)+(((__Bsize)&__EGBIT_MASK__)?1:0))

/* ============================================================================   
   all positions are in bits not in bytes   
   the ranged operations are performed between low_wordsize(from)   
   upper_wordsize(to) where low and upper are points in the wordsize generated   
   latice, for example, if wordsize is 32, and from is 46 and to is 90, then   
   the real range will be [32,95] so, be careful and remember that the range   
   start at zero.   
      
   this function is to check if the parameter are well set up   
   ========================================================================= */
/*typedef uint32_t bit_int_t;*/
#define bit_int_t uint32_t
#define EGbitset_t bit_int_t

/* ========================================================================= */
/* this function only check if the internal parameters of this utilities were
 * well set at compile time */
/* ========================================================================= */
int EGbitSanity (void);

/* ========================================================================= */
/* this function implements dst |= src in the range [from,to[, where from and to
 * are roneded down to the nearest complete word size. */
/* ========================================================================= */
int EGbitOr (bit_int_t * dst,
						 const bit_int_t * src,
						 const unsigned int from,
						 const unsigned int to);

/* ========================================================================= */
/* this function implements dst &= src in the range [from,to[, where from and to
 * are rounded down to the nearest complete word size. */
/* ========================================================================= */
int EGbitAnd (bit_int_t * dst,
							const bit_int_t * src,
							const unsigned int from,
							const unsigned int to);

/* ========================================================================= */
/* this function implement right shifts in the range [from,to[, where
 * from and to are rounded down to the nearest complete word size */
/* ========================================================================= */
int EGbitRightShift (bit_int_t * dst,
										 const bit_int_t * src,
										 const unsigned int shift,
										 const unsigned int from,
										 const unsigned int to);

/* ========================================================================= */
/* this function implement left shifts in the range [from,to[, where
 * from and to are rounded down to the nearest complete word size */
/* ========================================================================= */
int EGbitLeftShift (bit_int_t * dst,
										const bit_int_t * src,
										const unsigned int shift,
										const unsigned int from,
										const unsigned int to);

/* ========================================================================= */
/* this function set to zero the bit dst:pos (i.e. the bit in the position 'pos'
 * */
/* ========================================================================= */
int EGbitUnset (bit_int_t * dst,
								const unsigned int pos);

/* ========================================================================= */
/* this function set to one the bit dst:pos (i.e. the bit in the position 'pos'
 * */
/* ========================================================================= */
int EGbitSet (bit_int_t * const dst,
							const unsigned int pos);

/* ========================================================================= */
/* this function implement x+=y function in the range [from,to[, where
 * from and to are rounded down to the nearest complete word size */
/* ========================================================================= */
int EGbitPlus (bit_int_t * dst,
							 const bit_int_t * src,
							 const unsigned int from,
							 const unsigned int to);

/* ========================================================================= */
/* copy one bitset to another within some range [from,to] */
/* ========================================================================= */
int EGbitCopy (bit_int_t * const a,
							 const bit_int_t * const b,
							 const unsigned int from,
							 const unsigned int to);

/* ========================================================================= */
/* tell us if a <= b bit fields are equal within some range [from,to[. */
/* ========================================================================= */
int EGbitIsLeq (const bit_int_t * a,
								const bit_int_t * b,
								const unsigned int from,
								const unsigned int to);

/* ========================================================================= */
/* tell us if these bit fields are equal within some range [from,to[. */
/* ========================================================================= */
int EGbitIsEqual (const bit_int_t * a,
									const bit_int_t * b,
									const unsigned int from,
									const unsigned int to);

/* ========================================================================= */
/* this function implements dst ^= src in the range [from,to[, where from and to
 * are rounded down to the nearest complete word size. */
/* ========================================================================= */
int EGbitXor (bit_int_t * dst,
							const bit_int_t * src,
							const unsigned int from,
							const unsigned int to);

/* ========================================================================= */
/* this function implements dst = 0 in the range [from,to[, where from and to
 * are rounded down to the nearest complete word size. */
/* ========================================================================= */
int EGbitReset (bit_int_t * dst,
								const unsigned int from,
								const unsigned int to);

/* ========================================================================= */
/* this function return the value of dst:pos (i.e. the value of the bit in the
 * position 'pos' */
/* ========================================================================= */
int EGbitTest (bit_int_t const *const dst,
							const unsigned int pos);

/* ========================================================================= */
/* return the next one position in the bitset from 'pos' (inclusive), if no
 * next one position is found it return a number bigger than size */
/* ========================================================================= */
unsigned int EGbitNext (const bit_int_t * dst,
												const unsigned int pos,
												const unsigned int size);

/* ========================================================================= */
/* return the previous one position in the bitset from 'pos' (inclusive), if no
 * previous one position is found it return a number bigger than pos */
/* ========================================================================= */
unsigned int EGbitPrev (const EGbitset_t * dst,
												const unsigned int pos);

/** @brief Count number of on bits on 32-bit integers.
 * @return Number of on bits in the given 32-bit integer
 * @par Description:
 * Parallel Count carries out bit counting in a parallel fashion. Consider n
 * after the first line has finished executing. Imagine splitting n into pairs
 * of bits. Each pair contains the number of ones in those two bit positions in
 * the original n. After the second line has finished executing, each nibble
 * contains the number of ones in those four bits positions in the original n.
 * Continuing this for five iterations, the 64 bits contain the number of ones
 * among these sixty-four bit positions in the original n. That is what we
 * wanted to compute.*/
EGbitset_t EGbitElemBitCount (EGbitset_t n);

 /** @brief Count the number of on-bits in a bit-map */
EGbitset_t EGbitCount (bit_int_t * bitset,
											const unsigned int from,
											const unsigned int to);
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef __EG_COMPARE_H__
#define __EG_COMPARE_H__
/* ========================================================================= */
/** @defgroup EGcompare EGcompare
 *
 * Here we define an interface for comparison functions, and some default
 * comparators.
 *
 * -2004-08-16
 * 					- First Implementation
 * */
/** @file
 * @ingroup EGcompare */
/* @{ */
/* ========================================================================= */

/* ========================================================================= */
/** @brief comparison function type.
 * @par Description:
 * This type of function is intended to represent general comparison functions,
 * the comparison function must return an integer less than, equal to, or 
 * greater than zero if the first argument is considered to be respectively 
 * less than, equal to, or greater than the second. Note that the standard
 * function memcompare operate in the same sense.
 * */
typedef int (*EGcompare_f) (const void *,
														const void *);

/* ========================================================================= */
/** @brief Lexicographical order of strings.
 * @par Description:
 * This function compare two strings of (\0 terminated) chars in
 * lexicographical order. */
extern int EGstringCompare (const void *str1,
														const void *str2);

/* ========================================================================= */
/** @brief Normal order of doubles.
 * @par Description:
 * This function compare two doubles. */
extern int EGlfCompare (const void *str1,
												const void *str2);

/* ========================================================================= */
/** @brief Normal order of integers.
 * @par Description:
 * This function compare two integers. */
extern int EGdCompare (const void *str1,
											 const void *str2);

/* ========================================================================= */
/** @brief Normal order of unsigned integers.
 * @par Description:
 * This function compare two unsigned integers. */
extern int EGudCompare (const void *str1,
												const void *str2);

/* ========================================================================= */
/** @brief Normal order of pointers.
 * @par Description:
 * This function compare pointers in 'memory' order. */
extern int EGptCompare (const void *str1,
												const void *str2);

/* ========================================================================= */
/* } */
/* end of eg_compare.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGeBTree EGeBTree
 *
 * Here we define a minimal implementation of binary trees, using the philosophy
 * of embeded structures. Operations as adding nodes (in any position of the
 * tree), deleting nodes, splicing trees, and separating sub-trees are performed
 * in O(1) time. To obtain this running time information such as depth is not
 * stored in the nodes of the tree.
 *
 * -2005-07-08
 * 					- First Implementation
 * */
/** @file
 * @ingroup EGeBTree */
/** @addtogroup EGeBTree */
/** @{ 
 * @example eg_ebtree.ex.c  
 * This is a simple example for the usage of binary trees as implemented in @ref
 * EGeBTree. */
/* ========================================================================= */
#ifndef __EG_EBTREE_H__
#define __EG_EBTREE_H__

/* ========================================================================= */
/** @brief Parent index */
#define EG_EBTREE_PARENT 0

/* ========================================================================= */
/** @brief Left Child Index */
#define EG_EBTREE_LEFT 1

/* ========================================================================= */
/** @brief Right Child Index */
#define EG_EBTREE_RIGHT 2

/* ========================================================================= */
/** @brief Basic structure of a tree node, note that a node in a tree is in
 * itself a (sub)tree. */
typedef struct EGeBTree_t
{
	struct EGeBTree_t *cn[3];	/**< This array contains three pointers, in 
																 position #EG_EBTREE_PARENT the link to the 
																 parent of this node, in position 
																 #EG_EBTREE_LEFT the link to the left child, and
																 in #EG_EBTREE_RIGHT the link to the right 
																 child for this node. If any of this pointers
																 is NULL, then the link does not exists. In 
																 particular a leaf is a node with both child
																 links set to NULL, and the root of a tree
																 is the node whose parent link is NULL. */
}
EGeBTree_t;

/* ========================================================================= */
/** @brief Initialize a tree structure. It let it as a tree containing only
 * itself. and allocate any internal memory (not allocated by the user).
 * @param __tn tree to initialize. 
 * @note Note that the definition of #EGeBTree_t does not need to initialize any
 * memory, and basically reset and init do exactly the same, while clear do
 * nothing. */
#define EGeBTreeInit(__tn) (*(__tn) = (EGeBTree_t){{0,0,0}})

/* ========================================================================= */
/** @brief Let a tree just as after an init call.
 * @param __tn tree to reset.
 * @note Note that this macro is provided onll for completeness, because there
 * is no need for it.
 * */
#define EGeBTreeReset(__tn) EGeBTreeInit(__tn)

/* ========================================================================= */
/** @brief Free any internal memory (not allocated by the user) related to this
 * structure.
 * @param __tn tree to be cleared.
 * @note Note that this function is not really needed, it is provided for
 * completness, but is defined as nothing. */
#define EGeBTreeClear(__tn)

/* ========================================================================= */
/** @brief Add a left __child to a node in a tree.
 * @param __parent node to wich we will add a left child
 * @param __child node to be a left child
 * @return zero on success, non zero otherwise.
 * */
#define EGeBTreeAddLeft(__parent,__child) ({\
	EGeBTree_t*const __EGeparent = (__parent);\
	EGeBTree_t*const __EGechild = (__child);\
	__EGeparent->cn[EG_EBTREE_LEFT] ? (fprintf(stderr,"Can't add left __child to "#__parent" because it already has a left __child, in %s:%s:%d\n",__func__,__FILE__,__LINE__),1): (__EGeparent->cn[EG_EBTREE_LEFT] = __EGechild, __EGechild->cn[EG_EBTREE_PARENT] = __EGeparent, 0);})

/* ========================================================================= */
/** @brief Add a right child to a node in a tree.
 * @param __parent node to wich we will add a right child
 * @param __child node to be a right child
 * @return zero on success, non zero otherwise.
 * */
#define EGeBTreeAddRight(__parent,__child) ({\
	EGeBTree_t*const __EGeparent = (__parent);\
	EGeBTree_t*const __EGechild = (__child);\
	__EGeparent->cn[EG_EBTREE_RIGHT] ? (fprintf(stderr,"Can't add right __child to "#__parent" because it already has a right __child, in %s:%s:%d\n",__func__,__FILE__,__LINE__),1): (__EGeparent->cn[EG_EBTREE_RIGHT] = __EGechild, __EGechild->cn[EG_EBTREE_PARENT] = __EGeparent, 0);})

/* ========================================================================= */
/** @return a pointer to the parent of the given node, if NULL, then this node
 * is the root node of the tree.
 * @param __member node for wich we are looking for the father.
 * @return pointer to the parent node in the tree.
 * */
#define EGeBTreeGetParent(__member) ((__member)->cn[EG_EBTREE_PARENT])

/* ========================================================================= */
/** @return a pointer to the left child of the given node, if NULL, then this
 * node don;t have a left child
 * @param __member node for wich we are looking for the left child.
 * @return pointer to the left child node in the tree.
 * */
#define EGeBTreeGetLeft(__member) ((__member)->cn[EG_EBTREE_LEFT])

/* ========================================================================= */
/** @return a pointer to the right child of the given node, if NULL, then this
 * node don;t have a right child
 * @param __member node for wich we are looking for the right child.
 * @return pointer to the right child node in the tree.
 * */
#define EGeBTreeGetRight(__member) ((__member)->cn[EG_EBTREE_RIGHT])

/* ========================================================================= */
/** @brief return the root of the tree containing the given tree node.
 * @param __member node for wich we are looking for the tree-root.
 * @return pointer to the root of the tree containing the given node.
 * */
#define EGeBTreeGetRoot(__member) ({\
	EGeBTree_t*__EGeroot = (__member);\
	while(__EGeroot->cn[EG_EBTREE_PARENT]) \
		__EGeroot = __EGeroot->cn[EG_EBTREE_PARENT];\
	__EGeroot;})

/* ========================================================================= */
/** @brief Replace a node in a tree.
 * @param __old node to be replaced.
 * @param __rep node to be used as replacement.
 * @return zero on success, non-zero otherwise.
 * */
#define EGeBTreeReplace(__old,__rep) ({\
	EGeBTree_t*const __EGeold = (__old);\
	EGeBTree_t*const __EGenew = (__rep);\
	EGeBTree_t*const __EGepar = __EGeold->cn[EG_EBTREE_PARENT];\
	EGeBTree_t*const __EGelft = __EGeold->cn[EG_EBTREE_LEFT];\
	EGeBTree_t*const __EGergt = __EGeold->cn[EG_EBTREE_RIGHT];\
	*__EGenew = *__EGeold;\
	if(__EGepar)\
	{\
		if(__EGepar->cn[EG_EBTREE_LEFT] == __EGeold)\
			__EGepar->cn[EG_EBTREE_LEFT] = __EGenew;\
		else __EGepar->cn[EG_EBTREE_RIGHT] = __EGenew;\
	}\
	if(__EGelft) __EGelft->cn[EG_EBTREE_PARENT] = __EGenew;\
	if(__EGergt) __EGergt->cn[EG_EBTREE_PARENT] = __EGenew;\
	0;})

/* ========================================================================= */
/** @brief return the successor of the given node in it's tree according to the
 * in-order ordering.
 * @param __node element for wich we want the successor.
 * @return pointer to the successor, if NULL is returned, then there is no
 * successor for the given node.
 * @note The in-order considered here is the one depicted in the next figure:
 * \f[
 \psset{unit=1cm,arrows=->}
 \begin{pspicture}(-1,-1)(7,3)
 \rput(0,0){\circlenode{a}{1}}
 \rput(1,1){\circlenode{b}{2}}
 \rput(2,0){\circlenode{c}{3}}
 \rput(3,2){\circlenode{d}{4}}
 \rput(4,0){\circlenode{e}{5}}
 \rput(5,1){\circlenode{f}{6}}
 \rput(6,0){\circlenode{g}{7}}
 \ncline{b}{a}
 \ncline{b}{c}
 \ncline{d}{b}
 \ncline{d}{f}
 \ncline{f}{e}
 \ncline{f}{g}
 \end{pspicture}
 \f] In this figure the numbers in the nodes represent the in-order order. */
#define EGeBTreeGetNext(__node) ({\
	EGeBTree_t* __EGexn = (__node);\
	EGeBTree_t* __EGecn = __EGexn->cn[EG_EBTREE_RIGHT];\
	if(__EGecn) while(__EGecn->cn[EG_EBTREE_LEFT])\
			__EGecn = __EGecn->cn[EG_EBTREE_LEFT];\
	else do __EGecn = __EGexn->cn[EG_EBTREE_PARENT]; while(__EGecn && \
			__EGecn->cn[EG_EBTREE_RIGHT] == __EGexn && (__EGexn = __EGecn));\
	__EGecn;})

/* ========================================================================= */
/** @brief return the predecesor of the given node in it's tree according to 
 * the in-order ordering.
 * @param __node element for wich we want the predecesor.
 * @return pointer to the predecesor, if NULL is returned, then there is no
 * predecesor for the given node.
 * @note The in-order considered here is the one depicted in the next figure:
 * \f[
 \psset{unit=1cm,arrows=->}
 \begin{pspicture}(-1,-1)(7,3)
 \rput(0,0){\circlenode{a}{1}}
 \rput(1,1){\circlenode{b}{2}}
 \rput(2,0){\circlenode{c}{3}}
 \rput(3,2){\circlenode{d}{4}}
 \rput(4,0){\circlenode{e}{5}}
 \rput(5,1){\circlenode{f}{6}}
 \rput(6,0){\circlenode{g}{7}}
 \ncline{b}{a}
 \ncline{b}{c}
 \ncline{d}{b}
 \ncline{d}{f}
 \ncline{f}{e}
 \ncline{f}{g}
 \end{pspicture}
 \f] In this figure the numbers in the nodes represent the in-order order. */
#define EGeBTreeGetPrev(__node) ({\
	EGeBTree_t* __EGexn = (__node);\
	EGeBTree_t* __EGecn = __EGexn->cn[EG_EBTREE_LEFT];\
	if(__EGecn) while(__EGecn->cn[EG_EBTREE_RIGHT])\
			__EGecn = __EGecn->cn[EG_EBTREE_RIGHT];\
	else do __EGecn = __EGexn->cn[EG_EBTREE_PARENT]; while(__EGecn && \
			__EGecn->cn[EG_EBTREE_LEFT] == __EGexn && (__EGexn = __EGecn));\
	__EGecn;})

/* ========================================================================= */
/** @brief return the first node in the (sub-)tree (according to the in-order).
 * @param __node pointer to a node of the tree.
 * @return first node in the tree.
 * */
#define EGeBTreeGetFirst(__node) ({\
	EGeBTree_t* __EGecn = (__node);\
	while(__EGecn->cn[EG_EBTREE_LEFT]) __EGecn = __EGecn->cn[EG_EBTREE_LEFT];\
	__EGecn;})

/* ========================================================================= */
/** @brief return the last node in the (sub-)tree (according to the in-order).
 * @param __node pointer to a node of the tree.
 * @return last node in the tree.
 * */
#define EGeBTreeGetLast(__node) ({\
	EGeBTree_t* __EGecn = (__node);\
	while(__EGecn->cn[EG_EBTREE_RIGHT]) __EGecn = __EGecn->cn[EG_EBTREE_RIGHT];\
	__EGecn;})

/* ========================================================================= */
/** @brief Erase a leaf node from a tree.
 * @param __leaf node to be erased from the tree.
 * @return zero on success, non-zero otherwise, a failure means that the given
 * node wasn't a leaf in the tree.
 * */
#define EGeBTreeDel(__leaf) ({\
	EGeBTree_t*const __EGelf = (__leaf);\
	EGeBTree_t*const __EGepar = __EGelf->cn[EG_EBTREE_PARENT];\
	int __rval = 0;\
	if(__EGelf->cn[EG_EBTREE_LEFT] || __EGelf->cn[EG_EBTREE_RIGHT]) __rval = 1;\
	else if(__EGepar)\
	{\
		if(__EGepar->cn[EG_EBTREE_LEFT] == __EGelf) \
			__EGepar->cn[EG_EBTREE_LEFT] = 0;\
		else __EGepar->cn[EG_EBTREE_RIGHT] = 0;\
	}\
	__rval;})

/* ========================================================================= */
/** @brief Cut the given node from the tree containing it (and so create a
 * sub-tree).
 * @param __member
 * @return zero on success, non-zero otherwise.
 * */
#define EGeBTreeCut(__member) ({\
	EGeBTree_t*const __EGeroot = (__member);\
	EGeBTree_t*const __EGepar = __EGeroot->cn[EG_EBTREE_PARENT];\
	if(__EGepar) \
	{\
		__EGeroot->cn[EG_EBTREE_PARENT] = 0; \
		if(__EGepar->cn[EG_EBTREE_LEFT] == __EGeroot)\
			__EGepar->cn[EG_EBTREE_LEFT] = 0;\
		else __EGepar->cn[EG_EBTREE_RIGHT] = 0;\
	}\
	0;})

/* ========================================================================= */
/** @} */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGeList EGeList
 *
 * Here we define the basic interface for a circular linked list where the list
 * is embeded in some other structure. The ideas come from the Linux Kernel
 * implementation of lists. This implementation is based on the philosophy of 
 * embeded structures.
 *
 * 
 * @version 0.0.1
 * @par History:
 * - 2005-08-19
 * 						- Add debugging control
 * - 2005-05-23
 * 						- First Implementation.
 *
 * @note In general, the functions described bellow don't perform consistency
 * checks. It is asumed that the user does know what is he doing.
 *
 * @note If you want to have some debugging control try changing the debug level
 * at compile time, and lowering the debug level asociated to the list function
 * as defined in eg_configure.h.
 *
 * */
/** @file 
 * @ingroup EGeList */
/** @addtogroup EGeList */
/** @{ */
/** @example eg_elist.ex.c 
 * This is a working (althought useless) example on @ref EGeList.
 * */
/* ========================================================================= */
#ifndef __EG_ELIST_H__
#define __EG_ELIST_H__

/* ========================================================================= */
/** @brief debug level for lists */
#define __EL_DEBUG_ 100

/* ========================================================================= */
/** 
 * @brief List Node Structure.
 * @par Description:
 * This structure is to store a general node of the list. It is composed by
 * two members, that point to the next and previous structures in the list.  */
typedef struct EGeList_t
{
	struct EGeList_t *next;/**< Pointer to the next structure in the list */
	struct EGeList_t *prev;/**< Pointer to the previous structure in the list */
}
EGeList_t;

/* ========================================================================= */
/** @brief Initialize a given structure to point to itself (in circular
 * fashion).
 * @param __lpt pointer to the list to initialize. 
 * @return the pointer to the list. */
#define EGeListInit(__lpt) ({\
	EGeList_t*const __EGeL_init =(__lpt);\
	__EGeL_init->next = __EGeL_init->prev = __EGeL_init;})

/* ========================================================================= */
/** @brief Insert a __newpt __entry between two known consecutive entries.
 * @par Description:
 * This is only for internal list manipulation, where we know the prev/next
 * entries already.
 * @param __newpt pointer to the list node to insert.
 * @param __prevpt pointer to the node to preceed the __newpt node.
 * @param __nextpt pointer to the node to follow the __newpt node. 
 * @return the address of __newpt.
 * */
#define __EGeListAdd(__newpt,__prevpt,__nextpt) ({\
	EGeList_t*const __EGeL_add_new = (__newpt);\
	EGeList_t*const __EGeL_add_prev = (__prevpt);\
	EGeList_t*const __EGeL_add_next = (__nextpt);\
	__EGeL_add_next->prev = __EGeL_add_new;\
	__EGeL_add_prev->next = __EGeL_add_new;\
	__EGeL_add_new->next = __EGeL_add_next;\
	__EGeL_add_new->prev = __EGeL_add_prev;\
	__EGeL_add_new;})

/* ========================================================================= */
/** @brief Insert a __newpt __entry after the given pointer.
 * @param __newpt pointer to the __newpt list node to insert.
 * @param __head pointer from where the __newpt __entry will follow.
 * @return the pointer to the __newpt __entry in the list. 
 * */
#define EGeListAddAfter(__newpt,__head) __EGeListAdd(__newpt,__head,(__head)->next)

/* ========================================================================= */
/** @brief Insert a __newpt __entry before the given pointer.
 * @param __newpt pointer to the __newpt list node to insert.
 * @param __tailpt pointer that will follow the __newpt __entry in the list.
 * @return the pointer to the __newpt __entry in the list. 
 * */
#define EGeListAddBefore(__newpt,__tailpt) __EGeListAdd(__newpt,(__tailpt)->prev,__tailpt)

/* ========================================================================= */
/** @brief Given two nodes, link them as if they would follow one another in the
 * list (used to delete points from a list).
 * @param __prevpt pointer to the guy to be in first in the list.
 * @param __nextpt pointer to the guy to follow in the list.
 * @par Description:
 * This function is intended to be used only internally, where we know what is
 * what, if you use it is because you also know what is going on.
 * */
#define __EGeListLink(__prevpt,__nextpt) ({\
	EGeList_t* __EGeL_lnk_prev = (__prevpt);\
	EGeList_t* __EGeL_lnk_next = (__nextpt);\
	__EGeL_lnk_prev->next = __EGeL_lnk_next;\
	__EGeL_lnk_next->prev = __EGeL_lnk_prev;\
	0;})

/* ========================================================================= */
/** @brief Given a node, eliminate it from the list it bellongs. but don't
 * change the internal data in the eliminated list (be carefull, if you will 
 * use it afterwards, then you MUST initialize it). If debugging is enabled,
 * then whenever you delete, the connector is reseted to 0xffffffff. What you
 * can count on is that the connector won't be NULL after deleting it from the
 * list, but it's values may be lost if we are debugging.
 * @param __entry __entry to eliminate from the list.
 * @return pointer to the deleted __entry from the list.*/
#define EGeListDel(__entry) ({\
	EGeList_t *const __EGeL_del_entr = (__entry);\
	__EGeListLink(__EGeL_del_entr->prev,__EGeL_del_entr->next);\
	if(__EL_DEBUG_ <= DEBUG) \
		(*__EGeL_del_entr) = (EGeList_t){(EGeList_t*)0xffffffffU,\
																		 (EGeList_t*)0xffffffffU};\
	__EGeL_del_entr;})

/* ========================================================================= */
/** @brief Replace one __entry with another in a list.
 * @param __oldpt __entry to be replaced, note that the pointers stored in next/prev
 * won't be changed, this may possible lead to errors if the __entry is used
 * afterwards without initialization.
 * @param __newpt __newpt __entry in the list.
 * @return pointer to the old replaced member.
 * */
#define EGeListReplace(__oldpt,__newpt) ({\
	EGeList_t* __EGeL_rep_old = (__oldpt);\
	EGeList_t* __EGeL_rep_new = (__newpt);\
	__EGeL_rep_new->next = __EGeL_rep_old->next;\
	__EGeL_rep_new->prev = __EGeL_rep_old->prev;\
	__EGeL_rep_new->next->prev = __EGeL_rep_new;\
	__EGeL_rep_new->prev->next = __EGeL_rep_new;\
	__EGeL_rep_old;})

/* ========================================================================= */
/** @brief Move an element from one list to another (deleting it from the
 * original one).
 * @param __entry element to be removed from it's current list to a position 
 * after the given __head.
 * @param __head element to be before the moved element.
 * */
#define EGeListMoveAfter(__entry,__head) ({\
	__EGeListLink((__entry)->prev,(__entry)->next);\
	EGeListAddAfter(__entry,__head);})

/* ========================================================================= */
/** @brief Move an element from one list to another (deleting it from the
 * original one).
 * @param __entry element to be removed from it's current list to a position
 * before the given __tailpt.
 * @param __tailpt element to be after the moved element.
 * */
#define EGeListMoveBefore(__entry,__tailpt) ({\
	__EGeListLink((__entry)->prev,(__entry)->next);\
	EGeListAddBefore(__entry,__tailpt);})

/* ========================================================================= */
/** @brief test whether a list is empty (i.e. he is its own next pointer) */
#define EGeListIsEmpty(__head) ({\
	EGeList_t* __EGeL_emp_head = (__head);\
	(__EGeL_emp_head == __EGeL_emp_head->next);})

/* ========================================================================= */
/** @brief move all elements in one list to the given location in a second list.
 * Note that this function assumes that the list is represented by a pointer to
 * an EGeList_t structure that act as a marker but that don't bellong to the
 * list, and thus is not included in the joinded list.
 * @param __list marker to the list to be joined with the second. Note that the
 * fields in list won't be reinitialized, so be carefull with that, because the
 * fields are pointing to inconsistent data as it is, if you want to reutilize
 * the list you must call #EGeListInit before.
 * @param __head position from where the list will be spliced in.
 * @note Note that the original list is left in an undefined status, so before
 * use it, it should be re-initialized.
 * */
#define __EGeListSplice(__list,__head) ({\
	EGeList_t* __EGeL_spl_list = (__list);\
	EGeList_t* __EGeL_spl_first = __EGeL_spl_list->next;\
	EGeList_t* __EGeL_spl_last = __EGeL_spl_list->prev;\
	EGeList_t* __EGeL_spl_head = (__head);\
	EGeList_t* __EGeL_spl_at = __EGeL_spl_head->next;\
	__EGeL_spl_first->prev = __EGeL_spl_head;\
	__EGeL_spl_head->next = __EGeL_spl_first;\
	__EGeL_spl_last->next = __EGeL_spl_at;\
	__EGeL_spl_at->prev = __EGeL_spl_last;\
	0;})
#define EGeListSplice(__list,__head) ({if(!EGeListIsEmpty(__list)) __EGeListSplice(__list,__head);})

/* ========================================================================= */
/** @}*/
/* end of eg_elist.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGeDgraph EGeDgraph
 * Here we define a basic directed graph structure, it holds the number of
 * nodes and edges in the graph, as well as the in and out degree of all
 * nodes, and allow to access the head and tail of any edge. The spirit of this
 * implementation is to use embeded sub-structures rather than pointers to
 * sub-structures, much in the spirit of the Linux Kernel List implementation.
 * Wether this will help in running time is hard to say, but at least now we
 * have two implementations (EGdGraph_t) one with embeded structures and one
 * with pointer to sub-structures.
 *
 * @version 0.0.1
 * @par History:
 * - 2005-05-23
 * 						- First Implementation.
 *
 * */
/** @file 
 * @ingroup EGeDgraph */
/** @addtogroup EGeDgraph */
/** @{ */
/** @example eg_edgraph.ex.c
 * This is a more detailed example on how to use this module */
/* ========================================================================= */

#ifndef _EG_E_DGRAPH_H
#define _EG_E_DGRAPH_H

/* ========================================================================= */
/** @brief structure that hold all node related structures needed to define a
 * graph, and add/delete/modify it's structure */
typedef struct EGeDgraphNode_t
{
	EGeList_t in_edge;	/**< List head for a list of incomming edges */
	EGeList_t out_edge;	/**< List head for a list of outgoing edges */
	EGeList_t node_cn;	/**< List member of the list of all nodes in the graph, 
													 note that if this node is not (YET) in a graph, 
													 the contents are undefined */
	unsigned in_size;		/**< Number of incomming edges */
	unsigned out_size;	/**< Number of outgoing edges */
}
EGeDgraphNode_t;

/* ========================================================================= */
/** @brief structure that hold all edge related structures needed to define a
 * directed graph, and add/delete/modify it's structure */
typedef struct EGeDgraphEdge_t
{
	EGeList_t head_cn;		/**< List member of the incomming edge list in the 
														 head node for this edge. */
	EGeList_t tail_cn;		/**< List member of the outgoing edge list in the 
														 tail node for this edge. */
	EGeDgraphNode_t *head;/**< pointer to the head node for this edge */
	EGeDgraphNode_t *tail;/**< pointer to the tail node for this edge */
}
EGeDgraphEdge_t;

/* ========================================================================= */
/** @brief structure that holds all graph related structures needed to define
 * a directed graph, and to allow modifications over it. */
typedef struct 
{
	EGeList_t nodes;	/**< List head for all nodes in the graph */
	unsigned n_nodes;	/**< number of nodes in the graph */
	unsigned n_edges;	/**< number of edges in the graph */
}
EGeDgraph_t;

/* ========================================================================= */
/** @brief Initialize a graph structure as an empty graph with no members.
 * @param __G pointer to the graph to be initialized */
#define EGeDgraphInit(__G) ({\
	EGeDgraph_t*const __EGeDg_in_G = (__G);\
	EGeListInit(&(__EGeDg_in_G->nodes));\
	__EGeDg_in_G->n_edges = __EGeDg_in_G->n_nodes = 0;})

/* ========================================================================= */
/** @brief Reset the given graph pointer as an empty graph.
 * @param __G pointer to the graph to reset */
#define EGeDgraphReset(__G) EGeDgraphInit(__G)

/* ========================================================================= */
/** @brief Clear the structure so that we can free it (without memory leaks).
 * Note that this macro does nothing, because it is always safe to free this
 * structure */
#define EGeDgraphClear(__G)

/* ========================================================================= */
/** @brief Initialize an edge as an empty edge, non attached to any graph.
 * @param __e pointer to edge be initialized */
#define EGeDgraphEdgeInit(__e) ({\
	EGeDgraphEdge_t*const __EGeDg_in_e = (__e);\
	__EGeDg_in_e->head_cn = (EGeList_t){0,0};\
	__EGeDg_in_e->tail_cn = (EGeList_t){0,0};\
	__EGeDg_in_e->head = __EGeDg_in_e->tail = 0;})

/* ========================================================================= */
/** @brief Reset the given edge pointer as an edge not linked to a graph.
 * @param __e pointer to the edge to reset */
#define EGeDgraphEdgeReset(__e) EGeDgraphEdgeInit(__e)

/* ========================================================================= */
/** @brief Clear the structure so that we can free it (without memory leaks).
 * Note that this macro does nothing, because it is always safe to free this
 * structure */
#define EGeDgraphEdgeClear(__G) ;

/* ========================================================================= */
/** @brief Initialize a node as an empty non-attached node.
 * @param __v pointer to node to be initialized */
#define EGeDgraphNodeInit(__v) ({\
	EGeDgraphNode_t*const __EGeDg_in_v = (__v);\
	EGeListInit(&(__EGeDg_in_v->in_edge));\
	EGeListInit(&(__EGeDg_in_v->out_edge));\
	__EGeDg_in_v->node_cn = (EGeList_t){0,0};\
	__EGeDg_in_v->in_size = __EGeDg_in_v->out_size = 0;})

/* ========================================================================= */
/** @brief Reset the given node pointer as a node not linked to a graph.
 * @param __v pointer to the node to reset */
#define EGeDgraphNodeReset(__v) EGeDgraphNodeInit(__v)

/* ========================================================================= */
/** @brief Clear the structure so that we can free it (without memory leaks).
 * Note that this macro does nothing, because it is always safe to free this
 * structure */
#define EGeDgraphNodeClear(__G)

/* ========================================================================= */
/** @brief Add a node to the graph.
 * @param __G pointer to the graph to where we will add a node, it should be an
 * initialized graph structure (see EGeDgraphInit).
 * @param __v pointer to the node to be added to the graph. Note that we don't
 * check wether the node has valid information inside (you should call
 * EGeDgraphNodeInit(__v) for all nodes before adding them.
 * @return the number of nodes in the graph (including the recently added
 * node).
 * */
#define EGeDgraphAddNode(__G,__v) ({\
	EGeDgraph_t*const __EGeDg_add_n_G = (__G);\
	EGeDgraphNode_t*const __EGeDg_add_n_v = (__v);\
	EGeListAddAfter(&(__EGeDg_add_n_v->node_cn),&(__EGeDg_add_n_G->nodes));\
	__EGeDg_add_n_G->n_nodes++;})

/* ========================================================================= */
/** @brief Remove a node from a graph.
 * @param __v pointer to the node to be removed from the graph.
 * @param __G pointer to the graph from where we will remove the node.
 * @return pointer to the removed node.
 * @note Note that the actual definition of removing a node from a graph is
 * not completelly well defined, since there might be some edges attached to
 * this node, and is not clear what to do in such a case. In this
 * implementation we chose to return an error if the degree of this node is
 * non-zero. */
#define EGeDgraphDelNode(__G,__v) ({\
	EGeDgraph_t*const __EGeDg_del_n_G = (__G);\
	EGeDgraphNode_t*const __EGeDg_del_n = (__v);\
	if(__EGeDg_del_n->in_size) EXIT(1,"trying to remove node "#__v" with "\
		"incoming edges from graph "#__G);\
	if(__EGeDg_del_n->out_size) EXIT(1,"trying to remove node "#__v" with "\
		"outgoing edges from graph "#__G);\
	EGeListDel(&(__EGeDg_del_n->node_cn));\
	__EGeDg_del_n_G->n_nodes--;\
	__EGeDg_del_n;})

/* ========================================================================= */
/** @brief Add an edge to a graph.
 * @param __G pointer to the graph.
 * @param __hpt pointer to the head node.
 * @param __tpt pointer to the tail node.
 * @param __e pointer to the edge.
 * */
#define EGeDgraphAddEdge(__G,__hpt,__tpt,__e) ({\
	EGeDgraph_t*const __EGeDg_add_e_G = (__G);\
	EGeDgraphNode_t*const __EGeDg_add_e_head = (__hpt);\
	EGeDgraphNode_t*const __EGeDg_add_e_tail = (__tpt);\
	EGeDgraphEdge_t*const __EGeDg_add_e = (__e);\
	EGeListAddAfter(&(__EGeDg_add_e->head_cn),&(__EGeDg_add_e_head->in_edge));\
	EGeListAddAfter(&(__EGeDg_add_e->tail_cn),&(__EGeDg_add_e_tail->out_edge));\
	__EGeDg_add_e->head = __EGeDg_add_e_head;\
	__EGeDg_add_e->tail = __EGeDg_add_e_tail;\
	__EGeDg_add_e_head->in_size++;\
	__EGeDg_add_e_tail->out_size++;\
	__EGeDg_add_e_G->n_edges++;})

/* ========================================================================= */
/** @brief Delete an edge from a graph.
 * @param __G pointer to the graph.
 * @param __e pointer to the edge.
 * @return pointer to the deleted edge.
 * @note Take notice that this function won't change the values stored in the
 * given edge '__e', so if you access the internal information it may or may not
 * be still valid, (depending on what else has happen with the graph in the
 * meantime).
 * */
#define EGeDgraphDelEdge(__G,__e) ({\
	EGeDgraph_t*const __EGeDg_del_e_G = (__G);\
	EGeDgraphEdge_t*const __EGeDg_del_e = (__e);\
	EGeListDel(&(__EGeDg_del_e->head_cn));\
	EGeListDel(&(__EGeDg_del_e->tail_cn));\
	__EGeDg_del_e->head->in_size--;\
	__EGeDg_del_e->tail->out_size--;\
	__EGeDg_del_e_G->n_edges--;\
	__EGeDg_del_e;})

/* ========================================================================= */
/** @brief Change the tail of an edge.
 * @param __e pointer to the edge whose tail will be changed.
 * @param __G pointer to the graph.
 * @param __tpt pointer to the new edge's tail.
 * @return pointer to the new tail of the given edge.
 * @par Description:
 * Note that this function assumes that  that
 * both (__e) and (__tpt) bellong to an initialized graph. */
#define EGeDgraphChangeTail(__G,__e,__tpt) ({\
	EGeDgraphNode_t*const __EGeDg_chg_hd_tail = (__tpt);\
	EGeDgraphEdge_t*const __EGeDg_chg_hd_e = (__e);\
	__EGeDg_chg_hd_e->tail->out_size--;\
	EGeListDel(&(__EGeDg_chg_hd_e->tail_cn));\
	EGeListAddAfter(&(__EGeDg_chg_hd_e->tail_cn),&(__EGeDg_chg_hd_tail->out_edge));\
	__EGeDg_chg_hd_tail->out_size++;\
	__EGeDg_chg_hd_e->tail = __EGeDg_chg_hd_tail;})

/* ========================================================================= */
/** @brief Change the head of an edge.
 * @param __e pointer to the edge whose head will be changed.
 * @param __hpt pointer to the new edge's head.
 * @param __G pointer to the graph.
 * @return pointer to the new head of the given edge.
 * @par Description:
 * Note that this function assumes that  that
 * both (__e) and (__hpt) bellong to an initialized graph. */
#define EGeDgraphChangeHead(__G,__e,__hpt) ({\
	EGeDgraphNode_t*const __EGeDg_chg_hd_head = (__hpt);\
	EGeDgraphEdge_t*const __EGeDg_chg_hd_e = (__e);\
	__EGeDg_chg_hd_e->head->in_size--;\
	EGeListDel(&(__EGeDg_chg_hd_e->head_cn));\
	EGeListAddAfter(&(__EGeDg_chg_hd_e->head_cn),&(__EGeDg_chg_hd_head->in_edge));\
	__EGeDg_chg_hd_head->in_size++;\
	__EGeDg_chg_hd_e->head = __EGeDg_chg_hd_head;})

/* ========================================================================= */
/** @} */
/* end of eg_edgraph.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef __EG_EHASH_H__
#define __EG_EHASH_H__
/* ========================================================================= */
/** @defgroup EGeHash Embeded-Hash Tables
 *
 * Here we defina a hash-table implementation using embeded structures and an
 * array of lists as the method to store elements.
 * @version 0.0.1
 * @par History:
 * - 2006-10-04
 * 						- First implementation
 * */
/** @file
 * @ingroup EGeHash */
/** @addtogroup EGeHash */
/** @{ */
/** @example eg_ehash.ex.c
 * This is a simple example of the usage of hash tables using @ref EGeHash */
/* ========================================================================= */

/* ========================================================================= */
/* to store the key, if the key are too big we can  change that definition 
 * to long long int or wathever */
typedef uint64_t EGkey_t;

/* ========================================================================= */
/* this is for the hash function */
/* prime number, this is one of the 1024 biggest prime for unsigned int */
extern const EGkey_t EGhashPrime;
/* other prime number */
extern const EGkey_t EGhashB;
/* and yet other prime number */
extern const EGkey_t EGhashA;


/* ========================================================================= */
/** @brief this is the hashing function.
 * @param __key the key value we are looking for.
 * @param __maxsize size of the hash table
 * @return hash value. */
#define EGeHashFunc(__key,__maxsize)	({\
	(int)(((((EGkey_t)(__key)) * EGhashB  + EGhashA )% EGhashPrime) % (__maxsize));})

/* ========================================================================= */
/** @brief structure to store in the hash table, for a key we store a key,
 * this should be general enough */
typedef struct EGeHashInfo_t
{
	EGeList_t cn;	/**< @brief connector in the list where this element lives. */
	EGkey_t key;	/**< @brief identifier of this element, note that we may 
										 have several elements with the same identifier in the 
										 hash table, all of them will live in the same list of 
										 the hash table, but may not be consecutive in the list. */
} EGeHashInfo_t;

/* ========================================================================= */
/* structure that holds the internal lists */
typedef struct EGeHashTable_t
{
	size_t max_sz;	/**< @brief Number of entries in the array of lists */
	size_t sz;			/**< @brief Number of elements in the hash table */
	EGeList_t*table;/**< @brief Array of size #EGeHashTable_t::max_sz */
}
EGeHashTable_t;

/* ========================================================================= */
/** @brief Initialize a hash table as a table of the given max_size.
 * @param __maxsz size of the table.
 * @param __htable pointer to the Hash Table.
 * @note This functyion will allocate some memory, and to free it,
 * #EGeHashTableClear should be called. */
#define EGeHashTableInit(__htable,__maxsz) do{\
	EGeHashTable_t*const __EGeht = (__htable);\
	size_t const __EGehtsz = (size_t)(__maxsz);\
	register int __EGehti = (int)__EGehtsz;\
	__EGeht->max_sz = __EGehtsz;\
	__EGeht->sz = 0;\
	__EGeht->table = EGsMalloc(EGeList_t,__EGehtsz);\
	while(__EGehti--){EGeListInit(__EGeht->table+__EGehti);}}while(0)

/* ========================================================================= */
/** @brief Clear a hash table (free internally allocated memory too).
 * @param __htable pointer to the Hash Table.
 * @note This function will not disconnect each list of #EGeHashInfo_t
 * structures, instead, it will just free the respective #EGeHashTable_t::table
 * array */
#define EGeHashTableClear(__htable) EGfree((__htable)->table)

/* ========================================================================= */
/** @brief this is to find an element in the hash table, if the key is not 
 * found, it return 0, otherwise, it will return the pointer to the first 
 * #EGeHashInfo_t structure that has the sought after key.
 * @param __hkey key that we are looking for.
 * @param __htable pointer to the hash table where we are looking the key.
 * @return NULL if the key was not found, otherwise, a pointer to the first
 * #EGeHashInfo_t structure with the right key
 * */
#define EGeHashTableFind(__htable,__hkey) ({\
	EGeHashTable_t*const __EGehtf = (__htable);\
	const EGkey_t __EGehtfk = (__hkey);\
	EGeList_t*const __EGehtfr = __EGehtf->table + EGeHashFunc(__EGehtfk,__EGehtf->max_sz);\
	EGeList_t*__EGehtfi = __EGehtfr->next;\
	EGeHashInfo_t*__EGehtfn = 0;\
	while(__EGehtfi != __EGehtfr){\
		__EGehtfn = EGcontainerOf(__EGehtfi,EGeHashInfo_t,cn);\
		if(__EGehtfn->key == __EGehtfk) break;\
		__EGehtfi = __EGehtfi->next;}\
	__EGehtfi == __EGehtfr ? (EGeHashInfo_t*)0 : __EGehtfn;})

/* ========================================================================= */
/** @brief Given a hash info pointer in a table, find the
 * next #EGeHashInfo_t structure in the table with the same key. If no more
 * structures with the same key are found, return 0.
 * @param __hinfo pointer to the hash info structure for which we want it
 * successor.
 * @param __htable pointer to the hash table where we are looking the key.
 * @return NULL if no further key was found, otherwise, a pointer to the next
 * #EGeHashInfo_t structure with the right key
 * */
#define EGeHashTableFindNext(__htable,__hinfo) ({\
	EGeHashTable_t*const __EGehtf = (__htable);\
	const EGkey_t __EGehtfk = (__hinfo)->key;\
	EGeList_t*const __EGehtfr = __EGehtf->table + EGeHashFunc(__EGehtfk,__EGehtf->max_sz);\
	EGeHashInfo_t*__EGehtfn = (__hinfo);\
	EGeList_t*__EGehtfi = __EGehtfn->cn.next;\
	while(__EGehtfi != __EGehtfr){\
		__EGehtfn = EGcontainerOf(__EGehtfi,EGeHashInfo_t,cn);\
		if(__EGehtfn->key == __EGehtfk) break;\
		__EGehtfi = __EGehtfi->next;}\
	__EGehtfi == __EGehtfr ? (EGeHashInfo_t*)0 : __EGehtfn;})

/* ========================================================================= */
/** @brief insert an element to the hash table. 
 * @param __htable pointer to the hash table where we are looking the key.
 * @param __hinfo pointer to the hash info structure that we want to add.
 * */
#define EGeHashTableAdd(__htable,__hinfo) do{\
	EGeHashTable_t*const __EGehta = (__htable);\
	EGeHashInfo_t*const __EGehtai = (__hinfo);\
	EGeList_t*__EGehtar = __EGehta->table + EGeHashFunc(__EGehtai->key,__EGehta->max_sz);\
	EGeListAddAfter(&(__EGehtai->cn),__EGehtar);\
	__EGehta->sz++;}while(0)
	

/* ========================================================================= */
/** @brief this is to eliminate an element from the hash table. 
 * @param __htable pointer to the hash table.
 * @param __hinfo pointer to the hash info structure that we want to remove.
 * */
#define EGeHashTableDel(__htable,__hinfo) do{\
	EGeHashTable_t*const __EGehtd = (__htable);\
	EGeHashInfo_t*const __EGehtdi = (__hinfo);\
	__EGehtd->sz--;\
	EGeListDel(&(__EGehtdi->cn));}while(0)

/* ========================================================================= */
/** @brief Given an initialized hash table, resize the table array and move all
 * members from the old array to the new one.
 * @param __htable pointer to the hash table.
 * @param __maxsz new size of the table (it should be positive).
 * */
#define EGeHashTableResize(__htable,__maxsz) do{\
	EGeHashTable_t*const __EGehtr = (__htable);\
	size_t __EGehtosz = __EGehtr->max_sz;\
	size_t __EGehtnsz = (__maxsz);\
	EGeList_t*__EGehtot = __EGehtr->table;\
	EGeHashInfo_t*__EGehtri = 0;\
	__EGehtr->max_sz = __EGehtnsz;\
	__EGehtr->sz = 0;\
	__EGehtr->table = EGsMalloc(EGeList_t,__EGehtnsz);\
	while(__EGehtnsz--){EGeListInit(__EGehtr->table+__EGehtnsz);}\
	for(;__EGehtosz--;){\
		while(__EGehtot[__EGehtosz].next != __EGehtot+__EGehtosz){\
			__EGehtri = EGcontainerOf(__EGehtot[__EGehtosz].next,EGeHashInfo_t,cn);\
			EGeListDel(&(__EGehtri->cn));\
			EGeHashTableAdd(__EGehtr,__EGehtri);}}\
	EGfree(__EGehtot);}while(0)		
	
/* ========================================================================= */
/** @} */
/* end eg_ehash.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGeSet EGeSet 
 * This is an implementation of the set's defined at 'Data Structures and
 * Network Algorithms' of Robert Endre Tarjan. This structures allow to work
 * with disjoint setswith a representant (thus an equivalence class) and ask the
 * basic question of, given an elment, who is the representant if his class,
 * make a set, link two sets (i.e. union if them) and given a representant link
 * an element to that class.
 *
 * @version 0.0.1
 * @par History:
 * - 2005-06-20
 * 					- First Implementation.
 * */
/** @file 
 * @ingroup EGeSet */
/** @addtogroup EGeSet */
/** @{ */
/* ========================================================================= */
#ifndef __EG_ESET_H__
#define __EG_ESET_H__
#ifndef EG_ESET_DLEVEL
#define EG_ESET_DLEVEL 0
#endif

/* ========================================================================= */
/** @brief this structure holds an element of a set */
typedef struct EGes_t
{
	struct EGes_t *father;/**> pointer to the representing element on the 
													 	 class where this element bellong. */
	unsigned int rank;		/**> This is a lower bound on the number of 
														 elements for wich this is the represenntant */
}
EGes_t;

/* ========================================================================= */
/** @brief Initialize a set element as a set containing only itsself */
#define EGesInit(__elem) ({\
	EGes_t*const __EGesElm = (__elem);\
	*__EGesElm = (EGes_t){__EGesElm,0};})

/* ========================================================================= */
/** @brief this function find the representant of this element in his 
 * equivalence set.
 * @param __elem pointer to the element to wich we want to find the
 * representant.
 * @return the representant for this set (EGes_t*). */
#define EGesFind(__elem) ({\
	EGes_t *_EGesFc = __elem, *_EGesFn;\
	while(_EGesFc != _EGesFc->father)\
	{\
		_EGesFn = _EGesFc->father;\
		_EGesFc->father = _EGesFn->father;\
		_EGesFc = _EGesFn;\
	}\
	_EGesFc;})

/* ========================================================================= */
/**@brief Given two representing elements for two clases, joint them into a
 * single class.
 * @param __u first representative.
 * @param __v second representative.
 * @return the representing element of the new class.
 * @note This implementation always let the first element to be the 
 * representative for the new class. */
#define EGesLink(__u,__v) ({\
	EGes_t *_EGes_lu = (__u), *_EGes_lv = (__v);\
	EXITL(EG_ESET_DLEVEL, _EGes_lu != _EGes_lu->father, #__u\
				" is not a representant for its class");\
	EXITL(EG_ESET_DLEVEL, _EGes_lv != _EGes_lv->father, #__v\
				" is not a representant for its class");\
	EXITL(EG_ESET_DLEVEL, _EGes_lu == _EGes_lv, "same representant v == u");\
	if(_EGes_lu->rank <= _EGes_lv->rank) _EGes_lu->rank = _EGes_lv->rank+1;\
	_EGes_lv->father = _EGes_lu;\
	_EGes_lu;})

/* ========================================================================= */
/** @} end eg_eset.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGeUgraph EGeUgraph
 * Here we define a basic directed graph structure, it holds the number of
 * nodes and edges in the graph, as well as the in and out degree of all
 * nodes, and allow to access the head and tail of any edge. The spirit of this
 * implementation is to use embeded sub-structures rather than pointers to
 * sub-structures, much in the spirit of the Linux Kernel List implementation.
 * Wether this will help in running time is hard to say, but at least now we
 * have two implementations (EGdGraph_t) one with embeded structures and one
 * with pointer to sub-structures.
 *
 * @version 0.0.1
 * @par History:
 * - 2005-06-15
 * 						- First Implementation.
 *
 * */
/** @file 
 * @ingroup EGeUgraph */
/** @addtogroup EGeUgraph */
/** @{ */
/** @example eg_eugraph.ex.c
 * This is a more detailed example on how to use this module */
/* ========================================================================= */

#ifndef _EG_E_UGRAPH
#define _EG_E_UGRAPH

/* ========================================================================= */
/** @brief structure that hold all node related structures needed to define a
 * graph, and add/delete/modify it's structure */
typedef struct EGeUgraphNode_t
{
	EGeList_t edges;		/**< List of all edges with an endpoint in this node, if 
													 the edge is a loop, then it appears, two times in 
													 the adjacency list. */
	EGeList_t node_cn;	/**< List member of the list of all nodes in the graph, 
													 note that if this node is not (YET) in a graph, 
													 the contents are undefined */
	unsigned degree;		/**< Degree for the node, note that a loop edge is counted
													 twice, thus this is the number of members in the 
													 #EGeUgraphNode_t::edges list. */
}
EGeUgraphNode_t;

/* ========================================================================= */
/** @brief Structure for endpoints of edges. */
typedef struct EGeUgraphEP_t
{
	EGeList_t cn;					/**< List member of the edge list in the 
														 node for this edge. */
	EGeUgraphNode_t *node;/**< Link to the actual node of this end point */
	unsigned char type;		/**< either 0 or 1, zero for tail, one for head */
}
EGeUgraphEP_t;


/* ========================================================================= */
/** @brief structure that hold all edge related structures needed to define a
 * directed graph, and add/delete/modify it's structure */
typedef struct EGeUgraphEdge_t
{
	EGeUgraphEP_t ep[2];	/**< endpoints of the edge, by convention end point 
														 zero is the tail, and endpoint 1 is the head */
}
EGeUgraphEdge_t;

/* ========================================================================= */
/** @brief structure that holds all graph related structures needed to define
 * a directed graph, and to allow modifications over it. */
typedef struct EGeUgraph_t
{
	EGeList_t nodes;	/**< List head for all nodes in the graph */
	unsigned n_nodes;	/**< number of nodes in the graph */
	unsigned n_edges;	/**< number of edges in the graph */
}
EGeUgraph_t;

/* ========================================================================= */
/** @brief Initialize a graph structure as an empty graph with no members.
 * @param __Gpt pointer to the graph to be initialized */
#define EGeUgraphInit(__Gpt) ({\
	EGeUgraph_t*const __EGeDg_in_G = (__Gpt);\
	EGeListInit(&(__EGeDg_in_G->nodes));\
	__EGeDg_in_G->n_edges = __EGeDg_in_G->n_nodes = 0;})

/* ========================================================================= */
/** @brief Clear the structure so that we can free it (without memory leaks).
 * Note that this macro does nothing, because it is always safe to free this
 * structure */
#define EGeUgraphClear(__Gpt) ;

/* ========================================================================= */
/** @brief Initialize an edge as an empty edge, non attached to any graph.
 * @param __ept pointer to edge be initialized */
#define EGeUgraphEdgeInit(__ept) *(__ept) = (EGeUgraphEdge_t){{(EGeUgraphEP_t){(EGeList_t){0,0},0,0},(EGeUgraphEP_t){(EGeList_t){0,0},0,1}}};

/* ========================================================================= */
/** @brief Clear the structure so that we can free it (without memory leaks).
 * Note that this macro does nothing, because it is always safe to free this
 * structure */
#define EGeUgraphEdgeClear(__Gpt) ;

/* ========================================================================= */
/** @brief Initialize a node as an empty non-attached node.
 * @param __v pointer to node to be initialized */
#define EGeUgraphNodeInit(__v) ({\
	EGeUgraphNode_t*const __EGeDg_in_v = (__v);\
	EGeListInit(&(__EGeDg_in_v->edges));\
	__EGeDg_in_v->node_cn = (EGeList_t){0,0};\
	__EGeDg_in_v->degree = 0;})

/* ========================================================================= */
/** @brief Clear the structure so that we can free it (without memory leaks).
 * Note that this macro does nothing, because it is always safe to free this
 * structure */
#define EGeUgraphNodeClear(__Gpt) ;

/* ========================================================================= */
/** @brief Given the adjacency list connector of an edge, return the pointer
 * to the internal edge.
 * @param __edge_cn pointer to the edge connector as in the nodes adjacency
 * list.
 * @return pointer to the actual EGeUgraphEdge_t containing the connector. 
 * */
#define EGeUgraphGetAdjEdge(__edge_cn) ({\
	EGeUgraphEP_t*const __EGeUg_ep = EGcontainerOf(__edge_cn,EGeUgraphEP_t,cn);\
	EGcontainerOf(__EGeUg_ep,EGeUgraphEdge_t,ep[__EGeUg_ep->type]);})

/* ========================================================================= */
/** @brief Add a node to the graph.
 * @param __Gpt pointer to the graph to where we will add a node, it should be an
 * initialized graph structure (see EGeUgraphInit).
 * @param __v pointer to the node to be added to the graph. Note that we don't
 * check wether the node has valid information inside (you should call
 * EGeUgraphNodeInit(__v) for all nodes before adding them.
 * @return the number of nodes in the graph (including the recently added
 * node).
 * */
#define EGeUgraphAddNode(__Gpt,__v) ({\
	EGeUgraph_t*const __EGeDg_add_n_G = (__Gpt);\
	EGeUgraphNode_t*const __EGeDg_add_n_v = (__v);\
	EGeListAddAfter(&(__EGeDg_add_n_v->node_cn),&(__EGeDg_add_n_G->nodes));\
	__EGeDg_add_n_G->n_nodes++;})

/* ========================================================================= */
/** @brief Remove a node from a graph.
 * @param __v pointer to the node to be removed from the graph.
 * @param __Gpt pointer to the graph from where we will remove the node.
 * @return pointer to the removed node.
 * @note Note that the actual definition of removing a node from a graph is
 * not completelly well defined, since there might be some edges attached to
 * this node, and is not clear what to do in such a case. In this
 * implementation we chose to return an error if the degree of this node is
 * non-zero. */
#define EGeUgraphDelNode(__Gpt,__v) ({\
	EGeUgraph_t*const __EGeDg_del_n_G = (__Gpt);\
	EGeUgraphNode_t*const __EGeDg_del_n = (__v);\
	if(__EGeDg_del_n->degree) EXIT(1,"trying to remove node "#__v" with "\
		"incoming edges from graph "#__Gpt);\
	EGeListDel(&(__EGeDg_del_n->node_cn));\
	__EGeDg_del_n_G->n_nodes--;\
	__EGeDg_del_n;})

/* ========================================================================= */
/** @brief Add an edge to a graph.
 * @param __Gpt pointer to the graph.
 * @param __headpt pointer to the head node.
 * @param __tailpt pointer to the tail node.
 * @param __ept pointer to the edge.
 * */
#define EGeUgraphAddEdge(__Gpt,__headpt,__tailpt,__ept) ({\
	EGeUgraph_t*const __EGeDg_add_e_G = (__Gpt);\
	EGeUgraphNode_t*const __EGeDg_add_e_head = (__headpt);\
	EGeUgraphNode_t*const __EGeDg_add_e_tail = (__tailpt);\
	EGeUgraphEdge_t*const __EGeDg_add_e = (__ept);\
	EGeListAddAfter(&(__EGeDg_add_e->ep[1].cn),&(__EGeDg_add_e_head->edges));\
	EGeListAddAfter(&(__EGeDg_add_e->ep[0].cn),&(__EGeDg_add_e_tail->edges));\
	__EGeDg_add_e->ep[1].node = __EGeDg_add_e_head;\
	__EGeDg_add_e->ep[0].node = __EGeDg_add_e_tail;\
	__EGeDg_add_e_head->degree++;\
	__EGeDg_add_e_tail->degree++;\
	__EGeDg_add_e_G->n_edges++;})

/* ========================================================================= */
/** @brief Delete an edge from a graph.
 * @param __Gpt pointer to the graph.
 * @param __ept pointer to the edge.
 * @return pointer to the deleted edge.
 * @note Take notice that this function won't change the values stored in the
 * given edge '__ept', so if you access the internal information it may or may not
 * be still valid, (depending on what else has happen with the graph in the
 * meantime).
 * */
#define EGeUgraphDelEdge(__Gpt,__ept) ({\
	EGeUgraph_t*const __EGeDg_del_e_G = (__Gpt);\
	EGeUgraphEdge_t*const __EGeDg_del_e = (__ept);\
	EGeListDel(&(__EGeDg_del_e->ep[1].cn));\
	EGeListDel(&(__EGeDg_del_e->ep[0].cn));\
	__EGeDg_del_e->ep[1].node->degree--;\
	__EGeDg_del_e->ep[0].node->degree--;\
	__EGeDg_del_e_G->n_edges--;\
	__EGeDg_del_e;})

/* ========================================================================= */
/** @brief Change an endpoint of an edge.
 * @param __ept pointer to the edge whose tail will be changed.
 * @param __Gpt pointer to the graph.
 * @param __tailpt pointer to the new edge's tail.
 * @param __eptype number of the endpoint (either 0 or 1).
 * @return pointer to the new tail of the given edge.
 * @par Description:
 * Note that this function assumes that  that
 * both (__ept) and (__tailpt) bellong to an initialized graph. */
#define EGeUgraphChangeEP(__Gpt,__ept,__tailpt,__eptype) ({\
	EGeUgraphNode_t*const __EGeDg_chg_hd_tail = (__tailpt);\
	EGeUgraphEdge_t*const __EGeDg_chg_hd_e = (__ept);\
	EGeUgraphEP_t*const __EGeDg_ep = &(__EGeDg_chg_hd_e->ep[__eptype]);\
	__EGeDg_ep->node->degree--;\
	EGeListDel(&(__EGeDg_ep->cn));\
	EGeListAddAfter(&(__EGeDg_ep->cn),&(__EGeDg_chg_hd_tail->edges));\
	__EGeDg_chg_hd_tail->degree++;\
	__EGeDg_ep->node = __EGeDg_chg_hd_tail;})

/* ========================================================================= */
/** @brief Change the tail of an edge.
 * @param __ept pointer to the edge whose tail will be changed.
 * @param __Gpt pointer to the graph.
 * @param __tailpt pointer to the new edge's tail.
 * @return pointer to the new tail of the given edge.
 * @par Description:
 * Note that this function assumes that  that
 * both (__ept) and (__tailpt) bellong to an initialized graph. */
#define EGeUgraphChangeTail(__Gpt,__ept,__tailpt) EGeUgraphChangeEP(__Gpt,__ept,__tailpt,0)

/* ========================================================================= */
/** @brief Change the head of an edge.
 * @param __ept pointer to the edge whose head will be changed.
 * @param __headpt pointer to the new edge's head.
 * @param __Gpt pointer to the graph.
 * @return pointer to the new head of the given edge.
 * @par Description:
 * Note that this function assumes that  that
 * both (__ept) and (__headpt) bellong to an initialized graph. */
#define EGeUgraphChangeHead(__Gpt,__ept,__headpt) EGeUgraphChangeEP(__Gpt,__ept,__headpt,1)

/* ========================================================================= */
/** @} */
/* end of eg_edgraph.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGgcIt Gray Code Iterator
 *
 * Here we define an implementation of knuth's looples gray code iterator for
 * binary strings as defined in ``The Art of Computer Programming, 
 * Chapter 7.2.1.1''.
 * */
/** @file 
 * @ingroup EGgcIt */
/** @addtogroup EGgcIt */
/** @{ */
/** @example eg_gcit.ex.c
 * This is a simple example of the usage of heaps using @ref EGgcIt */
/* ========================================================================= */
#ifndef __EG_GCIT__
#define __EG_GCIT__
/* ========================================================================= */
/** @brief Debug level for the heap */
#define EG_GCIT_DBG 0

/* ========================================================================= */
/** @brief Structure to store the information relevant to the binary gray code
 * iterator. */
typedef struct EGgcIt_t
{
	int sz;					/**< @brief Number of bits in the code */
	int changed_pos;/**< @brief position of the last bit changed */
	int*tuple;			/**< @brief Current binary tuple being visited */
	int*focus;			/**< @brief Internal information */
}
EGgcIt_t;

/* ========================================================================= */
/** @brief Reset an initialized gray code iterator to the zero position.
 * @param __gc pointer to a gray-code iterator structure (#EGgcIt_t) 
 * */
#define EGgcItReset(__gc) do{\
	EGgcIt_t*const __EGgcit2 = (__gc);\
	register int __EGgci = __EGgcit2->sz;\
	__EGgcit2->focus[__EGgci]=__EGgci;\
	while(__EGgci--){__EGgcit2->tuple[__EGgci] = 0;\
	__EGgcit2->focus[__EGgci]=__EGgci;}\
	__EGgcit2->changed_pos=0;}while(0)

/* ========================================================================= */
/** @brief Initialize a binary gray code iterator, and set the iterator to the
 * zero position.
 * @param __gc pointer to a gray-code iterator structure (#EGgcIt_t) 
 * @param __sz number of bits to be used in the iterator.
 * */
#define EGgcItInit(__gc,__sz) do{\
	EGgcIt_t*const __EGgcit = (__gc);\
	const int __EGgcsz = __EGgcit->sz = ((int)(__sz));\
	__EGgcit->tuple = EGsMalloc(int,__EGgcsz);\
	__EGgcit->focus = EGsMalloc(int,__EGgcsz+1);\
	EGgcItReset(__EGgcit);}while(0)

/* ========================================================================= */
/** @brief free all internally allocated memory for the given #EGgcIt_t
 * structure.
 * @param __gc pointer to a gray-code iterator structure (#EGgcIt_t) 
 * */
#define EGgcItClear(__gc) do{\
	EGgcIt_t*const __EGgcit = (__gc);\
	EGfree(__EGgcit->tuple);\
	EGfree(__EGgcit->focus);\
	memset(__EGgcit,0,sizeof(EGgcIt_t));}while(0)

/* ========================================================================= */
/** @brief Return the number of bits for the given gray code iterator 
 * @param __gc pointer to a gray-code iterator structure (#EGgcIt_t) 
 * @return number of bits for the iterator
 * */
#define EGgcItGetSize(__gc) ((const int)((__gc)->sz))

/* ========================================================================= */
/** @brief Return a constant pointer to the current tuple 
 * @param __gc pointer to a gray-code iterator structure (#EGgcIt_t) 
 * @return pointer to an array containing the current tuple */
#define EGgcItGetTuple(__gc) ((const int*const)((__gc)->tuple))

/* ========================================================================= */
/** @brief return which position in the binary string changed in the last
 * iteration.
 * @param __gc pointer to a gray-code iterator structure (#EGgcIt_t) 
 * */
#define EGgcItGetChange(__gc) ((const int)((__gc)->changed_pos))

/* ========================================================================= */
/** @brief move to the next binary string, if no next string exists (i.e. we
 * finish the loop), return 0, otherwise return 1.
 * @param __gc pointer to a gray-code iterator structure (#EGgcIt_t) 
 * @return zero if no next string exists, otherwise 1.
 * */
#define EGgcItNext(__gc) ({\
	EGgcIt_t*const __EGgcit = (__gc);\
	const int __EGgccp = __EGgcit->changed_pos = __EGgcit->focus[0];\
	const int __EGgcrval=(__EGgccp!=__EGgcit->sz);\
	if(__EGgcrval){\
	__EGgcit->focus[0]=0;\
	__EGgcit->focus[__EGgccp]=__EGgcit->focus[__EGgccp+1];\
	__EGgcit->focus[__EGgccp+1]=__EGgccp+1;\
	__EGgcit->tuple[__EGgccp] = 1-__EGgcit->tuple[__EGgccp];}\
	__EGgcrval;})
	
/* ========================================================================= */
/** @} */
/* end of eg_gcit.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */

/* ========================================================================= */
/** @defgroup EGio EGio
 * input/output utilities
 *
 * Version 0.0.2 2003-05-09 (Marcos)
 *
 * Added the function EGioNParse to get a more argc, argv feel.
 * Also: Changed EGioParse so that it ignores multiple sequential delimiters.
 * 
 * Version 0.0.1 2003-04-11
 * - 2004-08-17
 * 					-	Add EGdisplayString function.
 * - 2006-08-16
 * 					- Add EGioReadLine function.
 * - 2007-12-06
 * 					- Add EGioReadxxxParam functions
 * - 2009-10-19
 * 					- Add bzlib/zlib/plain text interface
 * */
/** @file
 * @ingroup EGio */
/** @addtogroup EGio */
/** @{
 * @example eg_ebtree.ex.c
 * This is an example of writing to a zlib-compresed file
 *
 * @example eg_min_cut.ex.c
 * This is an example of reading files, either plain, bz2 or gz
 * */
/* ========================================================================= */

#ifndef __EG_IO_H__
#define __EG_IO_H__

/* ========================================================================= */
/** @brief safe open function, it test that we can open the given file with the
 * given mode, if an error occurs, display it on screen and exit, otherwise,
 * return the open file stream.
 * @param __file file name to open (is a const char*)
 * @param __mode mode to use to open the file (is a const char*)
 * @return FILE* stream */
#define EGsfopen(__file,__mode) ({\
	const char*__EGsfile = (__file);\
	const char*__EGsmode = (__mode);\
	FILE*__EGsFILE = fopen(__EGsfile,__EGsmode);\
	if(!__EGsFILE)\
	{\
		const int __EGserrno = errno;\
		fprintf(stderr,"fopen() failed with error code %d, error\n%s",__EGserrno,strerror(__EGserrno));\
		MESSAGE(0,"Could not open %s with mode %s", __EGsfile, __EGsmode);\
		exit(__EGserrno);\
	}\
	__EGsFILE;})

/* ========================================================================= */
/**@brief type of functions for display, receives a void* to the structure to print,
 * and a *FILE where to output */
typedef void (*EGdisplay_f) (void *, FILE *);
#define EGnullDisplay ((EGdisplay_f)0)

/* ========================================================================= */
/** @brief type of functions for display, receives a void* to the structure to print, a
 * *FILE where to output, and a set of offsets for datas, the length of that
 * array must be know by the user. */
typedef void (*EGdisplayOS_f) (void *,
															 FILE *,
															 size_t *);

/* ========================================================================= */
/** @brief Given a string 'input' this function uses EGioParse to separate
 * up to N words in it, we assume that argc is an array of pointers to strings
 * of size N, and note that the input array will be changed. */
void EGioNParse (char *input,
								 int max_argc,
								 const char *delim,
								 const char *comment,
								 int *argc,
								 char **argv);

/* ========================================================================= */
/** @brief given two *pointers 'next' and 'current' and a constant set 
 * of strings (parse delimiters), it store in 'next the next 
 * meaningfull string, and in current the rest of the secuence, 
 * the idea is to iterate over 'next' while it is not true; 
 * you have to store the original pointer to the string stream 
 * elsewere; also, we assume that the original stream is 
 * terminated with '\0'; also, it will discaard any sub-string 
 * that start with #, that is inteded for discard comments */
void EGioParse (char **next,
								char **current,
								const char *delim,
								const char *coment);

/* ========================================================================= */
/** @brief read a line from an input stream.
 * @param str where to store the line.
 * @param max_len maximum allowed length.
 * @param file stream from where we read the input
 * @return zero on success, non-zero otherwise, errors are cast when we can not
 * read from the given file.
 * */
int EGioReadLine(char*const str,size_t const max_len, FILE*file);

/* ========================================================================= */
/** @brief read a named string parameter, this function checks that we have two
 * parameters, and check if we had previously readed the parameter, if an error
 * occurs, report it in the given rval 
 * @param argc number of tokens in the current line
 * @param argv array of strings of tokens
 * @param name named of the parameter
 * @param param where to save the parameter (if null, don't save it)
 * @param has_param if we had the parameter before, should be one, if not,
 * should be zero, if successfull, then it will be set to one.
 * @param rval return value if an error while reading occurs.
 * @return one if we found the parameter in the line, or if we had an error
 * while reading the named parameter, zero otherwise. */
int EGioReadNamedStringParam( const int argc,
															char**argv,
															const char*const name,
															char**const param,
															int*const has_param,
															int*const rval);
/* ========================================================================= */
/** @brief read a named, non-negative, integer parameter, this function checks that we have two
 * parameters, and check if we had previously readed the parameter, if an error
 * occurs, report it in the given rval 
 * @param argc number of tokens in the current line
 * @param argv array of strings of tokens
 * @param name named of the parameter
 * @param param where to save the parameter (if null, don't save it)
 * @param has_param if we had the parameter before, should be one, if not,
 * should be zero, if successfull, then it will be set to one.
 * @param rval return value if an error while reading occurs.
 * @return one if we found the parameter in the line, or if we had an error
 * while reading the named parameter, zero otherwise. */
int EGioReadNamedIntNNParam(const int argc,
															char**argv,
															const char*const name,
															int*const param,
															int*const has_param,
															int*const rval);
/* ========================================================================= */
/** @brief read a named, strictly positive, integer parameter, this function checks that we have two
 * parameters, and check if we had previously readed the parameter, if an error
 * occurs, report it in the given rval 
 * @param argc number of tokens in the current line
 * @param argv array of strings of tokens
 * @param name named of the parameter
 * @param param where to save the parameter (if null, don't save it)
 * @param has_param if we had the parameter before, should be one, if not,
 * should be zero, if successfull, then it will be set to one.
 * @param rval return value if an error while reading occurs.
 * @return one if we found the parameter in the line, or if we had an error
 * while reading the named parameter, zero otherwise. */
int EGioReadNamedIntPlusParam(const int argc,
															char**argv,
															const char*const name,
															int*const param,
															int*const has_param,
															int*const rval);
/* ========================================================================= */
/** @brief read a named positive double parameter, this function checks that we have two
 * parameters, and check if we had previously readed the parameter, if an error
 * occurs, report it in the given rval 
 * @param argc number of tokens in the current line
 * @param argv array of strings of tokens
 * @param name named of the parameter
 * @param param where to save the parameter (if null, don't save it)
 * @param has_param if we had the parameter before, should be one, if not,
 * should be zero, if successfull, then it will be set to one.
 * @param rval return value if an error while reading occurs.
 * @return one if we found the parameter in the line, or if we had an error
 * while reading the named parameter, zero otherwise. */
int EGioReadNamedDblPlusParam(const int argc,
															char**argv,
															const char*const name,
															double*const param,
															int*const has_param,
															int*const rval);
/* ========================================================================= */
/** @brief read a named parameter, this function checks that we have one
 * parameter, and check if we had previously readed the parameter, if an error
 * occurs, report it in the given rval 
 * @param argc number of tokens in the current line
 * @param argv array of strings of tokens
 * @param name named of the parameter
 * @param has_param if we had the parameter before, should be one, if not,
 * should be zero, if successfull, then it will be set to one.
 * @param rval return value if an error while reading occurs.
 * @return one if we found the parameter in the line, or if we had an error
 * while reading the named parameter, zero otherwise. */
int EGioReadNamedParam( const int argc,
												char**argv,
												const char*const name,
												int*const has_param,
												int*const rval);
/* ========================================================================= */
/** @brief read an integer parameter, this function checks that we have one
 * parameter, if an error
 * occurs, report it in the given rval 
 * @param argc number of tokens in the current line
 * @param argv array of strings of tokens
 * @param param named of the parameter
 * should be zero, if successfull, then it will be set to one.
 * @param rval return value if an error while reading occurs.
 * @return one if we found the parameter in the line, or if we had an error
 * while reading the named parameter, zero otherwise. */
int EGioReadIntParam( const int argc,
											char**argv,
											int*const param,
											int*const rval);

/* ========================================================================= */
/** @name Zlib, BZlib compability interface:
 * This functions pretend to provide a common interface to work with plain or
 * compresed files. Up to now, we implement zlib and plain text handling, as
 * well as basic input/output handling. */
/* @{ */
/* ========================================================================= */
/* ========================================================================= */
struct EGioFile_st;
typedef struct EGioFile_st EGioFile_t;
/* ========================================================================= */
/* comon functions */
/* ========================================================================= */
/** @brief Converts, formats, and writes the args to the file under control 
 * of the format string, as in fprintf.
 * @return the number of bytes actually written (0 in case of error).
 * @note The number of bytes written is limited to 4095 (inherited from
 * gzprintf). The caller should assure that this limit is not exceeded.
 * If it is exceeded, then EGioprintf() will return return an error (0) with 
 * nothing written. In this case, there may also be a buffer overflow with
 * unpredictable consequences, which is possible only if zlib was compiled
 * with the insecure functions sprintf() or vsprintf() because the secure
 * snprintf() or vsnprintf() functions were not available. For more details,
 * see zlib's manual. */
int EGioPrintf(EGioFile_t*file,const char *format, ...);
int EGioWrite(EGioFile_t*file,const char* buf);
/* ========================================================================= */
/** @brief open a file for read or write as in fopen. if the file name ends
 * with gz, it will (try to) use gzFile mode, if not, it will use regular FILE
 * modes 
 * @return on success, pointer to an EGioFile_t structure, if can not open
 * file, it will print system error on screen and exit execution. */
EGioFile_t* EGioOpen(const char *path, const char *mode);
/* ========================================================================= */
/** @brief open a C stdandard file FILE as an EGioFile_t, it can be used to
 * open stderr, stdout, stdin, it will use plain access to the file. At
 * closing, it will not close the three standard stdout, stderr, stdin, but
 * other files will be closed.
 * @param file pointer to a std-c FILE structure
 * @return pointer to a EGioFile_t structure, linked to the given file.
 * @note we assume that file points to an already opened file.
 * */
EGioFile_t* EGioOpenFILE(FILE*file);
/* ========================================================================= */
/** @brief close file, flush all pending information, free all internally
 * allocated information.
 * @return zero on success; non-zero otherwise
 * */
int EGioClose(EGioFile_t*file);
/* ========================================================================= */
/** @brief flush all un-writed information into the file.
 * @return zero on success, non-zero otherwise. */
int EGioFlush(EGioFile_t*file);
/* ========================================================================= */
/** @brief reads bytes from file until len-1 characters are read, or a newline
 * character is read and transferred to buf, or an end-of-file condition is
 * encountered. The string is then terminated with a null character.
 * @return buf on success, 0 otherwise. 
 * */
char* EGioGets(char*buf, int len, EGioFile_t*file);
/* ========================================================================= */
/** @brief Test if the given file stream pointer point to the end of file.
 * @return non-zero if stream pointer points to end of file, 0 otherwise.
 * */
int EGioEof(const EGioFile_t*const file);
/* ========================================================================= */
/** @brief Test if the given file stream has an internal error flag
 * @return zero if no error detected, otherwise, return the apropiate error
 * code */
int EGioError(const EGioFile_t*const file);
/* ========================================================================= */
/* end interface for zlib-compresed files */
/* @} */
/* ========================================================================= */
/** @name Deprecated Functions
 * All functions here are marked as deprecated, and may be discontinued in
 * sub-sequent releases */
/* @{ */
/* ========================================================================= */
/** @brief create names with indices */
void EGmvar (char *str,
						 int nind,
						 const char *header,
						 ...);
/* ========================================================================= */
/** @brief this discard all lines starting with comments and stores the next 
 * leading line in current and the next token in next, we assume that next 
 * does not contain data, and that current store the remainings of the
 * current line */
void EGioDisCom (char **next,
								 char **current,
								 const char *delim,
								 const char *coment,
								 char *store,
								 unsigned int storeSize,
								 FILE * in);
/* ========================================================================= */
/** @brief display function for strings
 * @param str pointer to a null terminated string of chars.
 * @param file pointer to a stream where we write the string.
 * @par Description:
 * This function just print the string on the file, it won't add a '\n' at the
 * end. */
void EGdisplayString (void *str,
											FILE * file);

/* @} */
/* ========================================================================= */
/** @} */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef __EGNET_H__
#define __EGNET_H__
#define EGNET_DBGL 0

/* ========================================================================= */
/** @defgroup EGnet EGnet
 *
 * This header contain the definitions to make basic client/server
 * communications. The protocol used to comunicate is TCP/IP. and the type of
 * communication is permanent (within each cycle connect/disconnect
 * start_read/stop_read).
 *
 * @version 0.9.1
 * @par History:
 * - 2005-08-30
 * 						- A different aproach is to always send back and forth the
 * 						information (so that if debugging is enabled, we get confirmation
 * 						that the data was sent right), the drawback is that the
 * 						performance fall by a factor of two, but on the other hand, the
 * 						previous fix had a degradation factor of 8 (in bytes per
 * 						second)... so it seems that this approach is betteer and more
 * 						stable, still waiting for further tests.
 * - 2005-08-29
 * 						- When sending lot's of information during a single connection,
 * 						the internal send/receive data queue may overflow, to avoid this,
 * 						we add a low level syncronization step every
 * 						EG_NET_DATA_QUEUE_SIZE bits.
 * 						- Add EGnetClearSocket and EGnetInitSocket functions.
 * - 2005-06-14
 * 						- Take out the non-blocking versions (with a define) because it
 * 						won't run on some machines, but according to the ISO definitions
 * 						it should.... it's just the way it goes.
 * 						- Add flag to disable non-blocking calls.
 * - 2005-02-09
 * 						- Fix EGnetSendDouble, error comprises values < 0.5
 * - 2004-09-10
 * 						- Renan added some compatibility modifications to run this
 * 						library on windows.
 * - 2004-01-14
 * 						- first implementation/
 * */
/** @file
 * @ingroup EGnet */
/** @addtogroup EGnet */
/** @{ */
/** @example eg_net.ex.c */

/* ========================================================================= */
/** @brief If set to one, check that the information send was properly
 * received, this may slow down the code by a significant factor, and also may
 * fix synchronization issues without enabling EG_NET_SYNCHRONIZE */
#define EG_NET_CONFIRM 0

/* ========================================================================= */
/** @brief If set to one, use synchronization among sender and receiver. */
#define EG_NET_SYNCHRONIZE 0

/* ========================================================================= */
/** @brief Overhead of a MAC/TCP/IP package over the data part of the packet, 
 * note that the MAC header is about 14 bytes long, that IP has an overhead 
 * of 20 bytes plus 4 bytes for options and padding. TCP other 20 bytes plus 
 * up to 44 bytes for options and padding, thus the overhead is between 58 
 * and 102 bytes. Then to send x bytes across a TCP/IP connection,
 * we actually send x bytes + [58-102] bytes. This overhead is the constant
 * that we define bellow. For details on the structure of the MAC/IP/TCP
 * headers, see <A HREF=http://www.networksorcery.com/enp/protocol/tcp.htm>the
  TCP/IP description</A>. Note also that we shouldn't send packets of length 
 * above 572 bytes, thus the actual data length should be less than 470 bytes.
 * */
#define EG_NET_TCPIP_OVERHEAD 128

/* ========================================================================= */
/** @brief minimum length of the data queue in any socket connection. By
 * default it is set to 64Kb
 * */
#define EG_NET_DATA_QUEUE_SIZE 131072U

/* ========================================================================= */
/** @brief Minimum length of the incomming connection queue at the listening
 * socket. */
#define EG_NET_LISTEN_QUEUE_SIZE 16384U

/* ========================================================================= */
/** @brief structure for socket */
typedef struct
{
	int s_fd;						/**< store the file descriptor asociated to the socket */
	int f_fd;						/**< store the file descriptor used to read/write, note 
													 that if the socket is on the server side and is 
													 active, these two fd will be differents, but if it 
													 is on the client side both fd will be the same. */
	unsigned port;			/**< store the port of the connection. */
	unsigned int out_sz;/**< sended bytes without syncronization. */
	unsigned int in_sz;	/**< received bytes without syncronization. */
}
EGsocket_t;

/* ========================================================================= */
/** @brief Set to one to enable non-blocking calls, zero to disable them. What
 * happen in that case is that non-blocking calls behave as regular blocking
 * calls.
 * */
#define EG_NET_ALLOW_NON_BLOCKING 0

/* ========================================================================= */
/** @brief Initialize a socket structure */
#define EGnetInitSocket(skt) memset(skt,0,sizeof(EGsocket_t))

/* ========================================================================= */
/** @brief clear a socket structure and leave it ready to be freed */
#define EGnetClearSocket(__lskt) ({\
	EGsocket_t*const _EGskt = (EGsocket_t*)(__lskt);\
	if(_EGskt->s_fd) close(_EGskt->s_fd);\
	if(_EGskt->f_fd) close(_EGskt->f_fd);\
	memset(_EGskt,0,sizeof(EGsocket_t));\
	0;})

/* ========================================================================= */
/** @brief set a socket to wait for connections. Used as the server side of the
 * connection */
int EGnetListen (EGsocket_t * const skt,
								 unsigned p);

/* ========================================================================= */
/** @brief try to stablish a remote connection */
int EGnetConnect (EGsocket_t * const skt,
									const char *host_name,
									unsigned port);

/* ========================================================================= */
/** @brief close an established connection */
int EGnetDisconnect (EGsocket_t * const skt);

/* ========================================================================= */
/** @brief accept an incomming connection from another program/host. If 
 * no connection is on the queue (of incomming connections), the program will 
 * return EAGAIN, otherwise it return zero on success and non zero (1) in 
 * error. */
int EGnetStartReadNB (EGsocket_t * const skt);

/* ========================================================================= */
/** @brief accept an incomming connection from another program/host, if no 
 * connection is on the queue, the program will block until one is found. */
int EGnetStartRead (EGsocket_t * const skt);

/* ========================================================================= */
/** @brief close an established connection with another program/host */
int EGnetStopRead (EGsocket_t * const skt);

/* ========================================================================= */
/** @brief send a char through a connected socket */
int EGnetSendChar (EGsocket_t * const skt,
									 const int c);

/* ========================================================================= */
/** @brief recieve a char through a connected socket */
int EGnetRecvChar (EGsocket_t * const skt,
									 char *const c);

/* ========================================================================= */
/** @brief send a unsigned short through a connected socket */
int EGnetSendUshort (EGsocket_t * const skt,
										 unsigned n);

/* ========================================================================= */
/** @brief recieve a unsigned short through a connected socket */
int EGnetRecvUshort (EGsocket_t * const skt,
										 unsigned *n);

/* ========================================================================= */
/** @brief send a short through a connected socket */
#define EGnetSendShort(skt,n) EGnetSendUshort(skt,(unsigned)n)

/* ========================================================================= */
/** @brief recieve a short through a connected socket */
int EGnetRecvShort (EGsocket_t * const skt,
										int *n);

/* ========================================================================= */
/** @brief send an unsigned int through a connected socket */
int EGnetSendUint (EGsocket_t * const skt,
									 unsigned int n);

/* ========================================================================= */
/** @brief recieve an unsigned int through a connected socket */
int EGnetRecvUint (EGsocket_t * const skt,
									 unsigned int *n);

/* ========================================================================= */
/** @brief send an int through a connected socket */
#define EGnetSendInt(skt,n) EGnetSendUint(skt,(unsigned) n)

/* ========================================================================= */
/** @brief recieve an int through a connected socket */
int EGnetRecvInt (EGsocket_t * const skt,
									int *n);

/* ========================================================================= */
/** @brief send a double through a connected socket. The current implementation
 * has some limits, it tries to represent the number \f$ d = 2^ex \f$ where
 * \f$0.5\leq|x|<1\f$, unfortunatelly, \f$ |e|\leq 128 \f$, and numbers that
 * can't be represented in this form won't be transmitted in a right way. */
int EGnetSendDouble (EGsocket_t * const skt,
										 const double d);

/* ========================================================================= */
/** @brief recieve a double through a connected socket. The current 
 * implementation
 * has some limits, it tries to represent the number \f$ d = 2^ex \f$ where
 * \f$0.5\leq|x|<1\f$, unfortunatelly, \f$ |e|\leq 128 \f$, and numbers that
 * can't be represented in this form won't be transmitted in a right way. */
int EGnetRecvDouble (EGsocket_t * const skt,
										 double *const d);

/* ========================================================================= */
/** @brief send a string through a connected socket, it will send up to the 
 * '\\0' char at the end of the string (including it). */
int EGnetSendString (EGsocket_t * const skt,
										 const char *const str);

/* ========================================================================= */
/** @brief recieve a string through a connected socket, the string must 
 * have allocated memory and its maximum size be max_size (including the '\\0' 
 * char) */
int EGnetRecvString (EGsocket_t * const skt,
										 char *const str,
										 size_t max_size);

/* ========================================================================= */
/** @} */
#endif
/***********************************************************************\
 *
 * File:           EGrandState_t*.c for multiple streams of Random Numbers
 * Language:       ANSI C
 * Copyright:      Pierre L'Ecuyer, University of Montreal
 * Notice:         This code can be used freely for personal, academic,
 *                 or non-commercial purposes. For commercial purposes, 
 *                 please contact P. L'Ecuyer at: lecuyer@iro.UMontreal.ca
 * Date:           14 August 2001
 *
\***********************************************************************/
/* Minor modifications by Daniel Espinoza to include it in EGlib 
 * - 07082006 */

/* ========================================================================= */
/** @defgroup EGrnd EGrnd
 *
 * Here we define an interface for pseudo-random number generators based in
 * Pierre L'Ecuyer code. It provides a random state structure and a
 * pseudorandom generator with 32 bits of meaningfull data. 
 * The idea is to also provide a common interface to pseudo-random sequences
 * and to allow to use native pseudo-random codes.
 *
 * @version 1.0.1
 * @par History:
 * - 2011-03-01
 * 						- Make the global-seed thread-safe, note that individual random
 * 							states are not thread-safe.
 * */ 
/** @file
 * @ingroup EGrnd */
/** @addtogroup EGrnd */
/** @{
 * @example eg_random.ex.c
 * This is a simple example of the usage of this random number generator 
 * @ref EGrnd */
/* ========================================================================= */
#ifndef __EGRNGSTREAM_H__
#define __EGRNGSTREAM_H__

/* ========================================================================= */
/** @brief random state structure */
typedef struct {
   double Cg[6];	/**< Current state of the stream */
	 double Ig[6];	/**< Initial state of the stream */
} EGrandState_t;

/* ========================================================================= */
/** @brief Initialize a stream to the default initial seed.
 * It also advances the global seed @f$2^{127}@f$ positions.
 * @return zero on success, non-zero otherwise */
int EGrandInit(EGrandState_t*const state);

/* ========================================================================= */
/** @brief Set to the given values the global default seed 
 * @return zero on success, non-zero otherwise */
int EGrandSetGlobalSeed(const unsigned long* seed);

/* ========================================================================= */
/** @brief return 32 (pseudo) random bits from the given random state (and 
 * advance the random seed) 
 * @param g random seed to use.
 * @return 32 (pseudo) random bits, i.e. a number between zero and @f$2^{32}-1@f$ */
uint32_t EGrand(EGrandState_t*const g);

/* ========================================================================= */
/** @brief use 32 bits (i.e. 1 call to #EGrand) to create a (pseudo) random double number between 0 and 1.0.
 * @param g random seed to use.
 * @return a double (pseudo) random number between 0 and 1. */
double EGrandU01(EGrandState_t*const g);

/* ========================================================================= */
/** @brief use 64 bits (i.e. 2 calls to #EGrand) to create a (pseudo) random double number between \f$a\f$ and \f$b\f$.
 * @param g random seed to use.
 * @param a lower bound for the value.
 * @param b upper bound for the value.
 * @return a double (pseudo) random number between \f$a\f$ and \f$b\f$. */
#define EGrandUab(g,a,b) ({\
	const double __egrnd_A = (a), __egrnd_B = (b);\
	__egrnd_A + (__egrnd_B - __egrnd_A)*EGrandU01(g);})

/* ========================================================================= */
/** @brief generate a (pseudo) normal random number with mean \f$\mu\f$ and standard deviation \f$\sigma\f$ using 64 bits of psudorandom numbers (i.e. two calls to #EGrand).
 * @param g random seed to use.
 * @param mu mean for the normal distribution \f$\mu\f$.
 * @param sigma standard deviation of the normal distribution. \f$\sigma\f$.
 * @return a double (pseudo) normal random number.
 * @note We use the so-called Box-Muller transform in normal form to generate
 * the normal distribution, we took this form instead of the polar form because it seems to generate better normal sequences. for more details on this see <A HREF=http://en.wikipedia.org/wiki/Box-Muller_transformation TARGET=_top>this link</A> */
double EGrandNormal(EGrandState_t*const g,const double mu, const double sigma);

/* ========================================================================= */
/** @brief return a (pseudo) random integer between i and j.
 * @param i minimum value for the random number.
 * @param j maximum value for the random number.
 * @param g random seed to use.
 * @return a (pseudo) random number between i and j.
 * @note It uses the high order bits og #EGrand to generate the random 
 * integer.
 * */
int EGrandInt (EGrandState_t*const g,const int i,const int j);

/* ========================================================================= */
/** @brief Reset the random stream to its original state
 * @param g random seed to use.
 * @note This call allows to re-generate a sequence of calls to the random
 * number generator by setting the internal seed or state to its original value
 * (i.e. to the value when it was created). */
void EGrandReset (EGrandState_t*const g);

/* ========================================================================= */
/** @brief Set the (current and original) seed of the given random state to the
 * given seed.
 * @param g random seed to use.
 * @param seed new values to use as seed.
 * @return zero on success, non-zero otherwise.
 * */
int EGrandSetSeed(EGrandState_t*const g, const unsigned long* seed);

/* ========================================================================= */
/** @brief store the curren  state of the given random state.
 * @param g random seed to use.
 * @param seed where to store the current random state of g.
 * */
void EGrandGetState (EGrandState_t*const g, unsigned long *seed);

/* ========================================================================= */
/** @brief advances the (current) state of the random state by \f$k\f$ steps.
 * @param g random seed to use.
 * @param e part of the formula to compute \f$k\f$, can be positive or
 * negative.
 * @param c part of the formula to compute \f$k\f$, can be positive or
 * negative.
 * @note \f$k\f$ is given by the following formula: \f[k = c + \textrm{sign}(e)2^{|e|} \f]
 * where we assume that sign(0) = 0.
 * */
void EGrandAdvanceState (EGrandState_t*const g, const long e,const long c);

/* ========================================================================= */
/** @brief return a (pseudo) random number following an exponential
 * distribution with parameter \f$\lambda\f$ using 32 bits of random numbers
 * (i.e. one call to #EGrand).
 * @param g random seed to use.
 * @param lambda is the \f$\lambda\f$ parameter, it should be positive.
 * @return a (psaudo) random number following from an exponential distribution.
 * */
double EGrandExp(EGrandState_t*const g,const double lambda);

#endif
/* ========================================================================= */
/** @} */
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGtimer EGtimer 
 *
 * Here we implement types and functions for __timer functions
 *
 * @version 1.0.1 
 * @par History:
 * - 2006-01-25
 * 						- Fix compilation errors on sun, change includes accordingly and
 * 						code
 * - 2005-05-31
 * 						- Eliminate the definition of #EGwallClockTimer_t and replace it by
 * 						a macro definition that replace it by #EGtimer_t.
 * - 2004-01-20
 * 						- Add a 'wall clock' __timer (Renan-Marcos) type and functions
 * - 2003-05-08
 * 						- First Implementation
 * @note Up to now, this code will only work on linux machines, and maybe on
 * unix/posix systems.
 * */
/** @file 
 * @ingroup EGtimer */
/** @addtogroup EGtimer */
/** @{ */
/* ========================================================================= */

#ifndef __EG_TIMER_H__
#define __EG_TIMER_H__

/* ========================================================================= */
/** @brief Get system time.
 *
 * This function is for internal purposes only and should not be called from the
 * user space, it ask the (user) time from the system. 
 * @return the time (in seconds) stored as a double. */
#ifdef HAVE_GETRUSAGE
#define __EGzeit() ({\
	struct rusage __EGzeit_ru;\
	int __EGzeit_st = getrusage(RUSAGE_SELF,&__EGzeit_ru);\
	EXIT(__EGzeit_st,"getrusage failed with code error %d (%s)", errno, \
	strerror(errno));\
	(((double)__EGzeit_ru.ru_utime.tv_sec) + \
	((double)__EGzeit_ru.ru_utime.tv_usec)/1000000);})
#else
#ifdef HAVE_TIMES
#ifdef CLK_TCK
#define MACHINE_FREQ CLK_TCK
#else
#define MACHINE_FREQ HZ
#endif
#define __EGzeit() ({\
	struct tms __EGzeit_now;\
	times(&__EGzeit_now);\
	((double) __EGzeit_now.tms_utime)/((double) MACHINE_FREQ);})
#else
#error Your system does not have (or the configure script could not find)\
 getrusage nor times functions, and thus we are unable to provide \
 timing functions. Without them this library will not compile in this system
#endif
#endif

/* ========================================================================= */
/** @brief this structure holds a __timer structure */
typedef struct
{
	double time;	/**< hold the accumulated time */
	double stime;	/**< hols the last time when we start counting, this is only 
										 for internal purposes, the user should only use the 
										 field 'time' */
}
EGtimer_t;

/* ========================================================================= */
/** @brief This is done for backward compability, we used to define
 * EGwallClockTimer_t just as the normal __timer, so in reality we don't need
 * another type, but keep the name so that older code depending on this still
 * compiles. */
#define EGwallClockTimer_t EGtimer_t

/* ========================================================================= */
/** @brief Set a new starting time for the __timer.
 * @param __timer pointer to a EGtimer_t structure.
 * @return starting time (in seconds), and the type is a double. */
#define EGtimerStart(__timer) ({(__timer)->stime = __EGzeit();})

/* ========================================================================= */
/** @brief Stop a 'running' __timer and accumulate the run time.
 * @return the time elapsed since the last 'start' call (in seconds). */
#define EGtimerStop(__timer) ({(__timer)->time += __EGzeit() - (__timer)->stime;})

/* ========================================================================= */
/** @brief this function reset the accumulated time to zero */
#define EGtimerReset(__timer) ({(__timer)->time = 0;})

/* ========================================================================= */
/** @brief Set the starting time the current (wall) time.
 * @return the current wall time. */
#define EGwallClockTimerStart(__timer) ({(__timer)->stime = time(0);})

/* ========================================================================= */
/** @brief Stop a 'running' __timer and accumulate the (wall) runing time.
 * @return the wall time elapsed since the last initialization. */
#define EGwallClockTimerStop(__timer) ({\
	(__timer)->time += difftime(time(0),(__timer)->stime);})

/* ========================================================================= */
/** @brief Reset the accumulated time to zero */
#define EGwallClockTimerReset(__timer) EGtimerReset(__timer)

/* ========================================================================= */
/** @}
 * end of eg_timer.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005-2008 Daniel Espinoza.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef __EG_SYMTAB_H__
#define __EG_SYMTAB_H__
/* ========================================================================= */
/** @defgroup EGsymtab Symbol table structure
 * This version suport addition and finding symbols, as well as getting its
 * associated number, which correspond to the order in which it was added. For
 * now it does not support deletion of elements.
 * */
/** @file
 * @ingroup EGsymtab */
/** @addtogroup EGsymtab */
/** @{ */
/** @example eg_symtab.ex.c
 * This is a simple example of the usage of symbol tables using @ref EGsymtab */
/* ========================================================================= */
/** @brief structure to store a symbol table */
typedef struct EGsymtab_t
{
	size_t nsym;				/**< @brief symbols in table */
	size_t sz;					/**< @brief actual size of some internal arrays (>=nsym) */
	int*symbols;				/**< @brief array of offsets of all symbols in table */ 
	int*sort_perm;			/**< @brief permutation of sorted symbols (used to find 
														by binary search) */
	int must_sort;			/**< @brief flag to indicate whether or not we should 
														re-sort sort_perm */ 
	char*all_sym;				/**< @brief array of all strings */
	size_t all_sz;			/**< @brief length of all_sym */
	size_t use_sz;			/**< @brief actual used space in all_sym */
} EGsymtab_t;
/* ========================================================================= */
/** @brief initialize an EGsymtab_t structure
 * @param __symtab structure to initialize 
 * */
#define EGsymtabInit(__symtab) memset(__symtab,0,sizeof(EGsymtab_t))
/* ========================================================================= */
/** @brief clear any internally allocated memory 
 * @param __symtab structure to clear
 * */
#define EGsymtabClear(__symtab) do{\
	EGsymtab_t*const __EGsymtab = (__symtab);\
	EGfree(__EGsymtab->all_sym);\
	EGfree(__EGsymtab->symbols);\
	EGfree(__EGsymtab->sort_perm);\
	__EGsymtab->nsym = __EGsymtab->sz = __EGsymtab->all_sz = \
	__EGsymtab->use_sz = 0;}while(0)
/* ========================================================================= */
/** @brief return the i-th symbol in the table
 * @note we don't check for limits, i should be >=0 < #EGsymtab_t::nsym
 * @param __i symbol we look for
 * @param __symtab table to use
 * @return pointer to the corresponding string 
 * */
#define EGsymtabSymbol(__symtab,__i) ({\
	const EGsymtab_t*const __EGsymtab = (__symtab);\
	((const char*const)((__EGsymtab)->all_sym+__EGsymtab->symbols[__i]));})
/* ========================================================================= */
/** @brief Add a new element to the symbol table, if the element already
 * exists, then return non zero, otherwise return zero
 * @param symtab table where we will add the symbol
 * @param symbol string to add to the table
 * @return zero on success, non-zero otherwise
 * */
int EGsymtabAdd(EGsymtab_t*const symtab,
								const char*const symbol);
/* ========================================================================= */
/** @brief Look for a symbol in the table, and if found, report the position of
 * the symbol in the table.
 * @param symtab table where we will add the symbol
 * @param symbol string to look up in the table
 * @param pos if not null, return there the position of the symbol in the
 * table.
 * @return one if the symbol is in the table, zero otherwise.
 * */
int EGsymtabLookUp( EGsymtab_t*const symtab,
										const char*const symbol,
										int*const pos);
/* ========================================================================= */
/** @} */
/* end eg_symtab.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005-2008 Daniel Espinoza
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef __EG_KEYTAB_H__
#define __EG_KEYTAB_H__
/* ========================================================================= */
/** @defgroup EGkeytab key table structure
 * This version suport addition and finding keys, as well as getting its
 * associated number, which correspond to the order in which it was added. For
 * now it does not support deletion of elements.
 * */
/** @file
 * @ingroup EGkeytab */
/** @addtogroup EGkeytab */
/** @{ */
/** @example eg_keytab.ex.c
 * This is a simple example of the usage of symbol tables using @ref EGkeytab */
/* ========================================================================= */
/** @brief minimal information to store in the hash table */
typedef struct 
{
	uint64_t key;				/**< @brief key being stored */
	int next;						/**< @brief next element in the hash list 
														(offset of one)*/
	int pos;						/**< @brief position for the asociated key */
} EGkeytabInfo_t;
/* ========================================================================= */
/** @brief structure to store a symbol table */
typedef struct 
{
	size_t nkey;				/**< @brief number of keys in the table */
	size_t sz;					/**< @brief actual size of #EGkeytab_t::key */
	size_t hash_sz;			/**< @brief actual size of #EGkeytab_t::hash */
	EGkeytabInfo_t*key;	/**< @brief array of all key in table */ 
	int* hash;					/**< @brief hash table for inverse mapping */
} EGkeytab_t;
/* ========================================================================= */
/** @brief initialize an EGkeytab_t structure
 * @param __keytab structure to initialize 
 * */
#define EGkeytabInit(__keytab) do{\
	EGkeytab_t*const __EGkeytab = (__keytab);\
	memset(__EGkeytab,0,sizeof(EGkeytab_t));}while(0)
/* ========================================================================= */
/** @brief clear any internally allocated memory 
 * @param __keytab structure to clear
 * */
#define EGkeytabClear(__keytab) do{\
	EGkeytab_t*const __EGkeytab = (__keytab);\
	EGfree(__EGkeytab->key);\
	EGfree(__EGkeytab->hash);\
	__EGkeytab->nkey = __EGkeytab->sz = __EGkeytab->hash_sz = 0;}while(0)
/* ========================================================================= */
/** @brief return the i-th symbol in the table
 * @note we don't check for limits, it should be >=0 < #EGkeytab_t::nkey
 * @param __i symbol we look for
 * @param __keytab table to use
 * @return pointer to the corresponding string 
 * */
#define EGkeytabKey(__keytab,__i) ((const uint64_t)((__keytab)->key[__i].key))
/* ========================================================================= */
/** @brief Add a new element to the key table, if the element already
 * exists, then return non zero, otherwise return zero
 * @param keytab table where we will add the key
 * @param key to add to the table
 * @param check_duplicate if set to one, check that the added key was not added
 * before.
 * @return zero on success, non-zero otherwise
 * */
int EGkeytabAdd(EGkeytab_t*const keytab,
								const uint64_t key,
								const int check_duplicate);
/* ========================================================================= */
/** @brief Look for a key in the table, and if found, report the position of
 * the key in the table.
 * @param keytab table where we will look for the key
 * @param key to look up in the table
 * @param pos if not null, return there the position of the key in the
 * table.
 * @return one if the key is in the table, zero otherwise.
 * */
int EGkeytabLookUp( const EGkeytab_t*const keytab,
										const uint64_t key,
										int*const pos);
/* ========================================================================= */
/** @} */
/* end eg_keytab.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2009 Daniel Espinoza
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGeOctree EGeOctree
 *
 * Here we define basic interface for octrees as an embeded structure.
 *
 * @version 0.0.1
 * @par History:
 * - 2009-10-26
 * 						- first implementation
 * */
/** @file 
 * @ingroup EGeOctree */
/** @addtogroup EGeOctree */
/** @{ */
/** @example eg_octree.ex.c
 * This is a simple example of the usage of octree using @ref EGeOctree */
/* ========================================================================= */
#ifndef __EG_OCTREE_H__
#define __EG_OCTREE_H__
/* ========================================================================= */
/** @brief Debug level for the octree */
#ifndef EG_OCTR_DEBUG
#define EG_OCTR_DEBUG 10
#endif
/* ========================================================================= */
/** @brief basic data structure */
typedef struct EGeOctdata_st
{
	uint16_t x; /** @brief X position in the grid (up to 65536) */
	uint16_t y; /** @brief Y position in the grid (up to 65536) */
	uint16_t z; /** @brief Z position in the grid (up to 65536) */
	uint16_t depth:4; /** @brief depth of the node (0-15) 0 means a leaf */
	uint16_t key:3;		/** @brief position in the parent for this node (0-7) */
	uint16_t nson:4;	/** @brief number of childrens for this node */
	uint16_t unused:5;/** @brief unused bits (for now) */
	struct EGeOctdata_st*up;/** @brief pointer to up-level */
} EGeOctdata_t;

/* ========================================================================= */
/** @brief data structure for intermediate nodes */
typedef struct 
{
	EGeOctdata_t data;	/** @brief Note that both leafs and branches have the 
																 same basic data, but in principle we have 
																 many more leaves than branches */
	EGeOctdata_t*tree[8];/** @brief branches, they are numbered according to 
																 binary encoding of (>=x?)|(>=y?)|(>=z?), from 
																 zero to seven. If the pointer is NULL, then
																 no children in that sub-region. If current
																 level is one, pointer is of type EGeOctdata_t
																 otherwise, is of type EGeOctbranch_t */
} EGeOctbranch_t;
/* ========================================================================= */
/** @brief user alloc function for branches */
typedef EGeOctbranch_t* (*EGeOctalloc_f)(void*adata);
/* ========================================================================= */
/** @brief user free function for branches */
typedef void (*EGeOctfree_f)(void*adata,EGeOctbranch_t*branch);
/* ========================================================================= */
/** @brief data structure for complete tree.
 * @note that branch 0,0,0 should
 * always be a perfect cube of size 2^n */
typedef struct
{
	EGeOctbranch_t* root; /**<@brief root of the octree */
	uint16_t max_x;				/**<@brief X-range of data [0..max_x-1] */
	uint16_t max_y;				/**<@brief Y-range of data [0..max_y-1] */
	uint16_t max_z;				/**<@brief Z-range of data [0..max_z-1] */
	uint16_t height;			/**<@brief ceil( max( log_2(max_x), log_2(max_y),
																							log_2(max_z) ) ) */
	void*adata;						/**<@brief user allocator data */
	EGeOctalloc_f oalloc;	/**<@brief user allocator function for branches */
	EGeOctfree_f ofree;		/**<@brief user free function for branches */
} EGeOctree_t;
/* ========================================================================= */
/** @brief default branch allocator */
EGeOctbranch_t* EGeOctalloc(void*adata);
/* ========================================================================= */
/** @brief default branch free function */
void EGeOctfree(void*adata,EGeOctbranch_t*branch);
/* ========================================================================= */
/** @brief Add a new leaf to the tree */
int EGeOctaddleaf(EGeOctree_t*const tree,EGeOctdata_t*const leaf);
/* ========================================================================= */
/** @brief delete the given leaf from the tree (and erase empty branches), the
 * given leaf will have a NULL parent after the call. If the leaf is not
 * attached to a tree, nothing will hapen */
int EGeOctdelleaf(EGeOctree_t*const tree,EGeOctdata_t*const leaf);
/* ========================================================================= */
/** @brief Find exact node, if no node, return NULL */
EGeOctdata_t*EGeOctfind(
		const EGeOctree_t*const tree,
		const unsigned depth,
		const unsigned x,
		const unsigned y,
		const unsigned z);
/* ========================================================================= */
/** @brief initializator for a tree */
int EGeOctinit(
		EGeOctree_t*const tree,
		uint16_t max_x,
		uint16_t max_y,
		uint16_t max_z,
		void*adata,
		EGeOctalloc_f oalloc,
		EGeOctfree_f ofree);
/* ========================================================================= */
/** @brief clear a tree and leave it as an empty tree */
int EGeOctclear( EGeOctree_t*const tree);
/* ========================================================================= */
/** @brief Return (if any) next brother of the given node in the tree */
EGeOctdata_t* EGeOctbrother(const EGeOctdata_t*const branch);
/* ========================================================================= */
/** @brief Return (if any) first son of the given node in the tree */
EGeOctdata_t* EGeOctson(const EGeOctdata_t*const branch);
/* ========================================================================= */
/** @brief Return (if any) next cousin (i.e. next relative which is not an
 * ancestor of this node, this implies that if there is such a node, it will be
 * higher up in the tree.) */
EGeOctdata_t* EGeOctcousin(const EGeOctdata_t*const branch);
/* ========================================================================= */
/** @} */
/* end of eg_octree.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGaDgraph EGaDgraph
 * Here we define a basic directed graph structure, it holds the number of
 * nodes and edges in the graph, as well as the in and out degree of all
 * nodes, and allow to access the head and tail of any edge. The spirit of this
 * implementation is to use array nested sub-structures rather than pointers
 * to sub-structures, more suited for static data structures, and also more
 * light in memory usage.
 *
 * @version 0.0.1
 * @par History:
 * - 2010-05-04
 * 						- First Implementation.
 *
 * */
/** @file 
 * @ingroup EGaDgraph */
/** @addtogroup EGaDgraph */
/** @{ */
/** @example eg_adgraph.ex.c
 * This is a more detailed example on how to use this module */
/* ========================================================================= */

#ifndef _EG_A_DGRAPH_H
#define _EG_A_DGRAPH_H

/* ========================================================================= */
/** @brief structure that hold all node related structures needed to define a
 * graph structure */
typedef struct
{
	uint32_t in_sz;		/**< @brief number of incomming edges */
	uint32_t in_beg;	/**< @brief beginning of index array of incomming edges */
	uint32_t out_sz;	/**< @brief number of outgoing edges */
	uint32_t out_beg;	/**< @brief beginning of index array of outgoing edges */
}
EGaDN_t;

/* ========================================================================= */
/** @brief structure that hold all edge related structures needed to define a
 * directed graph structure */
typedef struct 
{
	uint32_t head;
	uint32_t tail;
}
EGaDE_t;

/* ========================================================================= */
/** @brief structure that holds all graph related structures needed to define
 * a directed graph. */
typedef struct 
{
	uint32_t n_nodes;	/**< @brief number of nodes in the graph */
	uint32_t n_edges;	/**< @brief number of edges in the graph */
	char*all_nodes;		/**< @brief memory containing all nodes in the graph */
	char*all_edges;		/**< @brief memory containing all edges in the graph */
	uint32_t*all_out;	/**< @brief array of length n_edges containing the index
																of all outgoing edges for every node */
	uint32_t*all_in;	/**< @brief array of length n_edges containing the index
																of all outgoing edges for every node */
	size_t szof_node;	/**< @brief the idea is that all nodes are allocated 
																together in an array once, and all references
																are done by index number in this array. In this
																case szof_node = sizeof(node_structure) */
	size_t szof_edge;	/**< @brief the idea is that all edges are allocated
																together in an array once, and all references
																are done by index number in this array. In this
																case szof_node = sizeof(node_structure) */
}
EGaDG_t;

/* ========================================================================= */
/** @brief macro helpers to acces nodes and edges by reference, note that all
 * structures built on top of the directed graph must have the base
 * data-structure at the beginning
 * @param __nodeid number of the node 
 * @param __graph_st graph structure in use 
 * @return pointer to the corresponding node */
#define EGaDGgetNode(__nodeid,__graph_st) ({\
	const EGaDG_t*const __EGaDG = (const EGaDG_t*const)(__graph_st);\
	((EGaDN_t*)(__EGaDG->all_nodes+(__EGaDG->szof_node*((size_t)(__nodeid)))));})

/* ========================================================================= */
/** @brief macro helpers to acces nodes and edges by reference, note that all
 * structures built on top of the directed graph must have the base
 * data-structure at the beginning 
 * @param __edgeid number of the edge 
 * @param __graph_st graph structure in use 
 * @return pointer to the corresponding edge */
#define EGaDGgetEdge(__edgeid,__graph_st) ({\
	const EGaDG_t*const __EGaDG = (const EGaDG_t*const)(__graph_st);\
	((EGaDE_t*)(__EGaDG->all_edges+(__EGaDG->szof_edge*((size_t)(__edgeid)))));})

/* ========================================================================= */
/** @brief macro to get ID of i-th out edge, we assume that underlying
 * structure starts with the node/graph structure */
#define EGaDGgetOutE(__id,__node_st,__graph_st) (((const EGaDG_t*const)(__graph_st))->all_out[((const EGaDN_t*const)(__node_st))->out_beg+(__id)])

/* ========================================================================= */
/** @brief macro to get ID of i-th in edge, we assume that underlying
 * structure starts with the node/graph structure */
#define EGaDGgetInE(__id,__node_st,__graph_st) (((const EGaDG_t*const)(__graph_st))->all_in[((const EGaDN_t*const)(__node_st))->in_beg+(__id)])

/* ========================================================================= */
/** @brief number of incoming edges */
#define EGaDGgetNin(__node_st) (((const EGaDN_t*const)(__node_st))->in_sz)

/* ========================================================================= */
/** @brief number of outgoing edges */
#define EGaDGgetNout(__node_st) (((const EGaDN_t*const)(__node_st))->out_sz)

/* ========================================================================= */
/** @brief number of nodes */
#define EGaDGgetNnodes(__graph_st) (((const EGaDG_t*const)(__graph_st))->n_nodes)

/* ========================================================================= */
/** @brief number of edges */
#define EGaDGgetNedges(__graph_st) (((const EGaDG_t*const)(__graph_st))->n_edges)

/* ========================================================================= */
/** @brief Initialize a graph structure as an empty graph with no members.
 * @param G pointer to the graph to be initialized.
 * @param n number of nodes
 * @param m number of edges
 * @param szof_node sizeof node structure
 * @param szof_edge sizeof edge structure
 * @param all_nodes array of nodes
 * @param all_edges array of edges
 * @note we assume that the array of edges has the correct head/tails in the
 * structure, and from there, the initalization function computes in/out edges
 * and sub-structures for all nodes, and any internal allocation is performed
 * here.
 * */
void EGaDGInit(
		EGaDG_t*const G, 
		const uint32_t n,
		const uint32_t m,
		const size_t szof_node,
		const size_t szof_edge,
		char*const all_nodes,
		char*const all_edges);
/* ========================================================================= */
/** @brief clear any internal memory allocated in Init */
#define EGaDGClear(__G) {\
	EGaDG_t*const __ADG = (EGaDG_t*const)(__G);\
	EGfree(__ADG->all_out);\
	EGfree(__ADG->all_in);\
	memset(__ADG,0,sizeof(EGaDG_t));}
/* ========================================================================= */
/** @} */
/* end of eg_adgraph.h */
#endif
/*============================================================================

This C header file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic
Package, Release 2b.

Written by John R. Hauser.  This work was made possible in part by the
International Computer Science Institute, located at Suite 600, 1947 Center
Street, Berkeley, California 94704.  Funding was partially provided by the
National Science Foundation under grant MIP-9311980.  The original version
of this code was written as part of a project to build a fixed-point vector
processor in collaboration with the University of California at Berkeley,
overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
is available through the Web page `http://www.cs.berkeley.edu/~jhauser/
arithmetic/SoftFloat.html'.

THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has
been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES
RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS
AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,
COSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE
EFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE
INSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR
OTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.

Derivative works are acceptable, even for commercial purposes, so long as
(1) the source code for the derivative work includes prominent notice that
the work is derivative, and (2) the source code includes prominent notice with
these four paragraphs for those parts of this code that are retained.

=============================================================================*/


#ifndef __SOFT_FLOAT_H__
#define __SOFT_FLOAT_H__

/*----------------------------------------------------------------------------
| The macro `FLOATX80' must be defined to enable the extended double-precision
| floating-point format `floatx80'.  If this macro is not defined, the
| `floatx80' type will not be defined, and none of the functions that either
| input or output the `floatx80' type will be defined.  The same applies to
| the `FLOAT128' macro and the quadruple-precision format `float128'.
*----------------------------------------------------------------------------*/
#define FLOATX80
#define FLOAT128

/*----------------------------------------------------------------------------
| Software IEC/IEEE floating-point types.
*----------------------------------------------------------------------------*/
typedef uint32_t float32;
typedef uint64_t float64;

#ifdef FLOATX80
typedef struct
{
	uint64_t low;
	uint16_t high;
}
floatx80;

#endif /*  */
#ifdef FLOAT128
typedef struct
{
	uint64_t low,
	  high;
}
float128;

#endif /*  */

/*----------------------------------------------------------------------------
| Software IEC/IEEE floating-point underflow tininess-detection mode.
*----------------------------------------------------------------------------*/
extern signed char float_detect_tininess;
enum
{ float_tininess_after_rounding = 0, float_tininess_before_rounding = 1
};

/*----------------------------------------------------------------------------
| Software IEC/IEEE floating-point rounding mode.
*----------------------------------------------------------------------------*/
extern signed char float_rounding_mode;
enum
{ float_round_nearest_even = 0, float_round_down = 1, float_round_up =
		2, float_round_to_zero = 3
};

/*----------------------------------------------------------------------------
| Software IEC/IEEE floating-point exception flags.
*----------------------------------------------------------------------------*/
extern signed char float_exception_flags;
enum
{ float_flag_invalid = 1, float_flag_divbyzero = 4, float_flag_overflow =
		8, float_flag_underflow = 16, float_flag_inexact = 32
};

/*----------------------------------------------------------------------------
| Routine to raise any or all of the software IEC/IEEE floating-point
| exception flags.
*----------------------------------------------------------------------------*/
void float_raise (
	int);

/*----------------------------------------------------------------------------
| Software IEC/IEEE integer-to-floating-point conversion routines.
*----------------------------------------------------------------------------*/
float32 int32_to_float32 (
	int);
float64 int32_to_float64 (
	int);

#ifdef FLOATX80
floatx80 int32_to_floatx80 (
	int);

#endif /*  */
#ifdef FLOAT128
float128 int32_to_float128 (
	int);

#endif /*  */
float32 int64_to_float32 (
	int64_t);
float64 int64_to_float64 (
	int64_t);

#ifdef FLOATX80
floatx80 int64_to_floatx80 (
	int64_t);

#endif /*  */
#ifdef FLOAT128
float128 int64_to_float128 (
	int64_t);

#endif /*  */

/*----------------------------------------------------------------------------
| Software IEC/IEEE single-precision conversion routines.
*----------------------------------------------------------------------------*/
int float32_to_int32 (
	float32);
int float32_to_int32_round_to_zero (
	float32);
int64_t float32_to_int64 (
	float32);
int64_t float32_to_int64_round_to_zero (
	float32);
float64 float32_to_float64 (
	float32);

#ifdef FLOATX80
floatx80 float32_to_floatx80 (
	float32);

#endif /*  */
#ifdef FLOAT128
float128 float32_to_float128 (
	float32);

#endif /*  */

/*----------------------------------------------------------------------------
| Software IEC/IEEE single-precision operations.
*----------------------------------------------------------------------------*/
float32 float32_round_to_int (
	float32);
float32 float32_add (
	float32,
	float32);
float32 float32_sub (
	float32,
	float32);
float32 float32_mul (
	float32,
	float32);
float32 float32_div (
	float32,
	float32);
float32 float32_rem (
	float32,
	float32);
float32 float32_sqrt (
	float32);
int_least8_t float32_eq (
	float32,
	float32);
int_least8_t float32_le (
	float32,
	float32);
int_least8_t float32_lt (
	float32,
	float32);
int_least8_t float32_eq_signaling (
	float32,
	float32);
int_least8_t float32_le_quiet (
	float32,
	float32);
int_least8_t float32_lt_quiet (
	float32,
	float32);
int_least8_t float32_is_signaling_nan (
	float32);

/*----------------------------------------------------------------------------
| Software IEC/IEEE double-precision conversion routines.
*----------------------------------------------------------------------------*/
int float64_to_int32 (
	float64);
int float64_to_int32_round_to_zero (
	float64);
int64_t float64_to_int64 (
	float64);
int64_t float64_to_int64_round_to_zero (
	float64);
float32 float64_to_float32 (
	float64);

#ifdef FLOATX80
floatx80 float64_to_floatx80 (
	float64);

#endif /*  */
#ifdef FLOAT128
float128 float64_to_float128 (
	float64);

#endif /*  */

/*----------------------------------------------------------------------------
| Software IEC/IEEE double-precision operations.
*----------------------------------------------------------------------------*/
float64 float64_round_to_int (
	float64);
float64 float64_add (
	float64,
	float64);
float64 float64_sub (
	float64,
	float64);
float64 float64_mul (
	float64,
	float64);
float64 float64_div (
	float64,
	float64);
float64 float64_rem (
	float64,
	float64);
float64 float64_sqrt (
	float64);
int_least8_t float64_eq (
	float64,
	float64);
int_least8_t float64_le (
	float64,
	float64);
int_least8_t float64_lt (
	float64,
	float64);
int_least8_t float64_eq_signaling (
	float64,
	float64);
int_least8_t float64_le_quiet (
	float64,
	float64);
int_least8_t float64_lt_quiet (
	float64,
	float64);
int_least8_t float64_is_signaling_nan (
	float64);

#ifdef FLOATX80

/*----------------------------------------------------------------------------
| Software IEC/IEEE extended double-precision conversion routines.
*----------------------------------------------------------------------------*/
int floatx80_to_int32 (
	floatx80);
int floatx80_to_int32_round_to_zero (
	floatx80);
int64_t floatx80_to_int64 (
	floatx80);
int64_t floatx80_to_int64_round_to_zero (
	floatx80);
float32 floatx80_to_float32 (
	floatx80);
float64 floatx80_to_float64 (
	floatx80);

#ifdef FLOAT128
float128 floatx80_to_float128 (
	floatx80);

#endif /*  */

/*----------------------------------------------------------------------------
| Software IEC/IEEE extended double-precision rounding precision.  Valid
| values are 32, 64, and 80.
*----------------------------------------------------------------------------*/
extern signed char floatx80_rounding_precision;

/*----------------------------------------------------------------------------
| Software IEC/IEEE extended double-precision operations.
*----------------------------------------------------------------------------*/
floatx80 floatx80_round_to_int (
	floatx80);
floatx80 floatx80_add (
	floatx80,
	floatx80);
floatx80 floatx80_sub (
	floatx80,
	floatx80);
floatx80 floatx80_mul (
	floatx80,
	floatx80);
floatx80 floatx80_div (
	floatx80,
	floatx80);
floatx80 floatx80_rem (
	floatx80,
	floatx80);
floatx80 floatx80_sqrt (
	floatx80);
int_least8_t floatx80_eq (
	floatx80,
	floatx80);
int_least8_t floatx80_le (
	floatx80,
	floatx80);
int_least8_t floatx80_lt (
	floatx80,
	floatx80);
int_least8_t floatx80_eq_signaling (
	floatx80,
	floatx80);
int_least8_t floatx80_le_quiet (
	floatx80,
	floatx80);
int_least8_t floatx80_lt_quiet (
	floatx80,
	floatx80);
int_least8_t floatx80_is_signaling_nan (
	floatx80);

#endif /*  */

#ifdef FLOAT128

/*----------------------------------------------------------------------------
| Software IEC/IEEE quadruple-precision conversion routines.
*----------------------------------------------------------------------------*/
int float128_to_int32 (
	float128);
int float128_to_int32_round_to_zero (
	float128);
int64_t float128_to_int64 (
	float128);
int64_t float128_to_int64_round_to_zero (
	float128);
float32 float128_to_float32 (
	float128);
float64 float128_to_float64 (
	float128);

#ifdef FLOATX80
floatx80 float128_to_floatx80 (
	float128);

#endif /*  */

/*----------------------------------------------------------------------------
| Software IEC/IEEE quadruple-precision operations.
*----------------------------------------------------------------------------*/
float128 float128_round_to_int (
	float128);
float128 float128_add (
	float128,
	float128);
float128 float128_sub (
	float128,
	float128);
float128 float128_mul (
	float128,
	float128);
float128 float128_div (
	float128,
	float128);
float128 float128_rem (
	float128,
	float128);
float128 float128_sqrt (
	float128);
int_least8_t float128_eq (
	float128,
	float128);
int_least8_t float128_le (
	float128,
	float128);
int_least8_t float128_lt (
	float128,
	float128);
int_least8_t float128_eq_signaling (
	float128,
	float128);
int_least8_t float128_le_quiet (
	float128,
	float128);
int_least8_t float128_lt_quiet (
	float128,
	float128);
int_least8_t float128_is_signaling_nan (
	float128);

#endif /*  */
#endif /*  */
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2010 Daniel Espinoza
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGrSet EGrSet
 *
 * Here we define the basic interface for random-access sets. They provide a
 * mean for adding/deleting elements, checking for inclusion in constant
 * time, and looping through the set in time o(|set|).
 *
 * This comes at a price, the structure uses two arrays of length the
 * ``base set'' size. 
 *
 * @version 0.0.1
 * @par History:
 * - 2010-09-02
 * 						- First Implementation
 * */
/** @file 
 * @ingroup EGrSet */
/** @addtogroup EGrSet */
/** @{ */
/** @example eg_raset.ex.c
 * This is a simple example of the usage of heaps using @ref EGrSet */
/* ========================================================================= */
#ifndef __EG_RASET__
#define __EG_RASET__
/* ========================================================================= */
/** @brief Debug level for the heap */
#ifndef EG_RSET_DEBUG
#define EG_RSET_DEBUG 1000
#endif
/* ========================================================================= */
/** @brief set structure */
typedef struct 
{
	int32_t sz;		/**< @brief number of elements in the set */
	int32_t grsz;	/**< @brief number of elements in ground set */
	int32_t asz;	/**< @brief actual length of EGrset_t::set and EGrset_t::inv */
	int32_t*set;	/**< @brief array of length EGrset_t::asz, it contains in 
											positions [0,sz-1] the elements in the set, and in 
											positions [sz,grsz-1] the complement */
	int32_t*inv;	/**< @brief array of length EGrset_t::asz, it contains the
											inverse positions for the complete EGrset_t::set array,
											i.e. set[inv[i]]=i for i in [0,asz-1] */
}
EGrset_t;
/* ========================================================================= */
/** @brief display the contents of the set to the specified FILE buffer */
#define EGrsetDisplay(__EGrset__,__file__) do{\
	const EGrset_t*const __EGs = (__EGrset__);\
	const int32_t __EGsz = __EGs->sz, __EGasz = __EGs->asz, __EGgrsz = __EGs->grsz;\
	int __EGi;\
	fprintf(__file__,"rset %p: sz %"PRId32" asz %"PRId32" grsz %"PRId32"\n\tSet:\n\t\tset:",\
					__EGs, __EGsz,__EGasz,__EGgrsz);\
	for(__EGi=0;__EGi<__EGsz;__EGi++){fprintf(__file__," %2"PRId32,__EGs->set[__EGi]);}\
	fprintf(__file__,"\n\t\tinv:");\
	for(__EGi=0;__EGi<__EGsz;__EGi++){fprintf(__file__," %2"PRId32,__EGs->inv[__EGi]);}\
	fprintf(__file__,"\n\tComplement:\n\t\tset:");\
	for(__EGi=__EGsz;__EGi<__EGgrsz;__EGi++){fprintf(__file__," %2"PRId32,__EGs->set[__EGi]);}\
	fprintf(__file__,"\n\t\tinv:");\
	for(__EGi=__EGsz;__EGi<__EGgrsz;__EGi++){fprintf(__file__," %2"PRId32,__EGs->inv[__EGi]);}\
	fprintf(__file__,"\n\tExtra_Space:\n\t\tset:");\
	for(__EGi=__EGgrsz;__EGi<__EGasz;__EGi++){fprintf(__file__," %2"PRId32,__EGs->set[__EGi]);}\
	fprintf(__file__,"\n\t\tinv:");\
	for(__EGi=__EGgrsz;__EGi<__EGasz;__EGi++){fprintf(__file__," %2"PRId32,__EGs->inv[__EGi]);}\
	fprintf(__file__,"\n");}while(0)
/* ========================================================================= */
/** @brief empty a set 
 * @par __EGrset__ pointer to the structure
 * */
#define EGrsetEmpty(__EGrset__) ((__EGrset__)->sz=0)
/* ========================================================================= */
/** @brief fill a set
 * @par __EGrset__ pointer to the structure
 * */
#define EGrsetFill(__EGrset__) ((__EGrset__)->sz=(__EGrset__)->grsz)
/* ========================================================================= */
/** @brief Initialize an EGrset_t with the given size, note that both
 * ground-size and set size will be __grsz__, but the set will be set empty by
 * default.
 * @par __EGrset__ pointer to the structure
 * @par __grsz__ size of the ground set 
 * */
#define EGrsetInit(__EGrset__,__grsz__) do{\
	EGrset_t*const __EGs__ = (__EGrset__);\
	int __EGi__ = (__EGs__->asz = __EGs__->grsz = (__grsz__));\
	__EGs__->sz = 0;\
	__EGs__->set = EGsMalloc(int32_t,((size_t)__EGi__)*sizeof(int32_t));\
	__EGs__->inv = EGsMalloc(int32_t,((size_t)__EGi__)*sizeof(int32_t));\
	for(;__EGi__--;) __EGs__->inv[__EGi__] = __EGs__->set[__EGi__] = __EGi__;}while(0)
/* ========================================================================= */
/** @brief Clear an EGrset_t
 * @par __EGrset__ pointer to the structure
 * */
#define EGrsetClear(__EGrset__) do{\
	EGrset_t*const __EGs__ = (__EGrset__);\
	EGfree(__EGs__->inv);\
	EGfree(__EGs__->set);\
	__EGs__->asz = __EGs__->sz = __EGs__->grsz = 0;}while(0)
/* ========================================================================= */
/** @brief helper macro to swap elements one and two in both inv and set
 * arrays
 * @par __EGs pointer to the structure (we assume it is internal and safe
 * to use it directly)
 * @par __EGe1 first element (idem, it can be a constant value).
 * @par __EGe2 second element (idem, it can be a constant value).
 * */
#define __EGrsetSwap(__EGs,__EGe1,__EGe2) do{\
	const int32_t __EGt = __EGs->inv[__EGe1];\
	__EGs->inv[__EGe1] = __EGs->inv[__EGe2];\
	__EGs->inv[__EGe2] = __EGt;\
	__EGs->set[__EGt] = __EGe2;\
	__EGs->set[__EGs->inv[__EGe1]] = __EGe1;}while(0)
/* ========================================================================= */
/** @brief Add element __i__
 * @par __EGrset__ pointer to the structure
 * @par __i__ element to add
 * @note if the element was in the set, do nothing
 * */
#define EGrsetAdd(__EGrset__,__i__) do{\
	EGrset_t*const __EGs__ = (__EGrset__);\
	const int32_t __EGi__ = (__i__),__EGp__=__EGs__->inv[__EGi__],__EGr__=__EGs__->set[__EGs__->sz];\
	if(__EGp__>=__EGs__->sz){\
		__EGrsetSwap(__EGs__,__EGi__,__EGr__);\
		__EGs__->sz++;}}while(0)
/* ========================================================================= */
/** @brief Del element __i__
 * @par __EGrset__ pointer to the structure
 * @par __i__ element to del
 * @note if the element was not in the set, do nothing
 * */
#define EGrsetDel(__EGrset__,__i__) do{\
	EGrset_t*const __EGs2__ = (__EGrset__);\
	const int32_t __EGi2__ = (__i__);\
	const int32_t __EGp2__=__EGs2__->inv[__EGi2__],__EGr2__=__EGs2__->set[__EGs2__->sz-1];\
	if(__EGp2__<__EGs2__->sz){\
		__EGrsetSwap(__EGs2__,__EGi2__,__EGr2__);\
		__EGs2__->sz--;}}while(0)
/* ========================================================================= */
/** @brief test if an element is in the set
 * @par __EGrset__ pointer to the structure
 * @par __i__ element to test
 * */
#define EGrsetPeek(__EGrset__,__i__) ((__EGrset__)->sz > (__EGrset__)->inv[__i__])
/* ========================================================================= */
/** @brief Re-set the groud set size.
 * if smaller than  previous value, it implements S = S \ {new_sz,...,old_sz}. 
 * if bigger than previous value, it implements S = S
 * @par EGs pointer to the structure
 * @par grsz new ground set */
void EGrsetSetgrnd(
	EGrset_t*const EGs,
	const int32_t grsz);
/* ========================================================================= */
/** @brief test structure consistency */
#define EGrsetCheck(__EGrset__) ({\
	const EGrset_t*const __EGs__ = (__EGrset__);\
	int32_t __EGi__;\
	int __rval__=0;\
	for(__EGi__=__EGs__->asz ; __EGi__--;){\
		__rval__=+(__EGi__!=__EGs__->inv[__EGs__->set[__EGi__]]);}\
	for(__EGi__=__EGs__->grsz; __EGi__<__EGs__->asz;__EGi__++){\
		__rval__+=(__EGs__->inv[__EGi__]<__EGs__->grsz);}\
	if(__rval__) fprintf(stdout,"ERROR\n");\
	__rval__;})
/* ========================================================================= */
/** @} */
/* end of eg_raset.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGgraphUtil EGgraphUtil
 * Some utility functions to transform among different format of graphs 
 * */
/** @file
 * @ingroup EGgraphUtil */
/** @addtogroup EGgraphUtil */
/** @{ */
#ifndef __EG_GRAPH_UTIL__
#define __EG_GRAPH_UTIL__
/* ========================================================================= */
/** @brief given a graph, defined as an array of edges, compute in_degree,
 * out_degree, in_edge, out_edge, and in_perm and out_perm of edges if those
 * array are provided.
 * @param n number of nodes
 * @param m number of edges
 * @param edges array of length 2m, where \f$e_{i}=(edge[2i],edge[2i+1])\f$ for
 * \f$i=0,\ldots,m-1\f$.
 * @param in_d if non-null, array of length n where we compute in-degree of
 * each node.
 * @param in_beg if non-null (and in_d is not null)
 * \f$in_beg[i]=\sum\limits_{j=0}^{i-1}in_d[j]\f$.
 * @param in_e if non-null (and in_d, in_beg not null), satisfy
 * in_d[in_beg[i]+j] store the tail of the jth incomming edge for node i, for
 * \f$j=0,\ldots,in_d[i]-1\f$. Note that the relation is for each edge,
 * regardless of repetitions, no special sort criteria can be assumed on these
 * edges.
 * @param in_perm if non-null (and in_d, in_beg, in_e not null) satisfy
 * (edge[2*i],edge[2*i+1]) = (in_e[in_perm[i]],edge[2*i+1])
 * @param ou_d if non-null, array of length n where we compute out-degree of
 * each node.
 * @param ou_beg if non-null (and ou_d is not null)
 * \f$ou_beg[i]=\sum\limits_{j=0}^{i-1}ou_d[j]\f$.
 * @param ou_e if non-null (and ou_d, ou_beg not null), satisfy
 * ou_d[ou_beg[i]+j] store the head of the jth outgoing edge for node i, for
 * \f$j=0,\ldots,ou_d[i]-1\f$. Note that the relation is for each edge,
 * regardless of repetitions, no special sort criteria can be assumed on these
 * edges.
 * @param ou_perm if non-null (and ou_d, ou_beg, ou_e not null) satisfy
 * (edge[2*i],edge[2*i+1]) = (edge[2*i],ou_e[ou_perm[i]])
 * @return zero on success 
 * */
int EGguDegree(
	int32_t const n,
	int32_t const m,
	int32_t const*const edges,
	int32_t*const in_d,
	int32_t*const in_beg,
	int32_t*const in_e,
	int32_t*const in_perm,
	int32_t*const ou_d,
	int32_t*const ou_beg,
	int32_t*const ou_e,
	int32_t*const ou_perm);

/* ========================================================================= */
#endif
/** @} */
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef dbl___EG_DMATRIX_H__
#define dbl___EG_DMATRIX_H__

/* ========================================================================= */
/** @defgroup EGdMatrix Dense Matrices
 * Here we define a common interface for dense matrices (i.e. a structure), and
 * some common operations over dense matrices. The definition uses EGlpNum as
 * reference number type, this allow for template initializations.
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2005-10-27
 *  					- First implementation.
 * */
/** @{*/
/** @file
 * @brief This file provide the user interface and function definitions for
 * Dense Matrices.
 * */
/** @example dbl_eg_dmatrix.ex.c */
/* ========================================================================= */
/** @brief structure to hold a dense matrix, we choose a row representation
 * of the matrix, and we allow row and column permutations. All actual values 
 * in the matrix are stored in #dbl_EGdMatrix_t::matval, and the rows in
 * #dbl_EGdMatrix_t::matrow. */
typedef struct dbl_EGdMatrix_t
{
	size_t col_sz;		/**< @brief Number of columns in the matrix. */
	size_t row_sz;		/**< @brief Number of rows in the matrix */
	double **matrow;
										/**< @brief Array of size #dbl_EGdMatrix_t::row_sz containing 
												 all rows of the matrix */
	double *matval;/**< @brief Values for all entries */
	int *col_ord;			/**< @brief Array of size at least #dbl_EGdMatrix_t::col_sz 
												 containing the order ammong all columns i.e. it is a 
												 permutation of {0,....,col_sz-1} which is how the 
												 matrix is treated internally */
	int *row_ord;			/**< @brief Array of size at least #dbl_EGdMatrix_t::row_sz 
												 containing the order ammong all rows, i.e. it is a 
												 permutation of {0,...,row_sz-1} which is how the 
												 matrix is treated internally */
}
dbl_EGdMatrix_t;

/* ========================================================================= */
/** @brief Initialize (as a dense matrix of dimension 0x0) an #dbl_EGdMatrix_t
 * structure.
 * @param __dmatrix dense matrix structure pointer.
 * */
#define dbl_EGdMatrixInit(__dmatrix) memset(__dmatrix,0,sizeof(dbl_EGdMatrix_t))

/* ========================================================================= */
/** @brief Clear a dense matrix structure, i.e. free all internally allocated
 * data of the structure. Note that no further use of the structure can be made
 * unless it is re-initialized and set to a suitable size.
 * @param __dmatrix dense matrix structure pointer.
 * */
#define dbl_EGdMatrixClear(__dmatrix) do{\
	dbl_EGdMatrix_t*const __EGdm = (__dmatrix);\
	dbl_EGlpNumFreeArray(__EGdm->matval);\
	EGfree(__EGdm->matrow);\
	int_EGlpNumFreeArray(__EGdm->col_ord);\
	int_EGlpNumFreeArray(__EGdm->row_ord);} while(0)

/* ========================================================================= */
/** @brief Set new dimensions for a dense matrix structure.
 * @param __dmatrix dense matrix structure pointer.
 * @param __nnewrows number of rows in the matrix.
 * @param __nnewcols number of columns in the matrix.
 * @note Take care that the values stored in the matrix are not initialized to
 * any particular number. Also the ordering (for both column and row) is reset
 * to the standard ordering 0,....,n.
 * */
#define dbl_EGdMatrixSetDimension(__dmatrix,__nnewrows,__nnewcols) do{\
	dbl_EGdMatrix_t*const __EGdm = (__dmatrix);\
	register int __EGdmi;\
	__EGdm->col_sz = (__nnewcols);\
	__EGdm->row_sz = (__nnewrows);\
	dbl_EGlpNumReallocArray(&(__EGdm->matval),__EGdm->col_sz * __EGdm->row_sz);\
	EGrealloc(__EGdm->matrow,__EGdm->row_sz * sizeof(double*));\
	int_EGlpNumReallocArray(&(__EGdm->col_ord),__EGdm->col_sz);\
	int_EGlpNumReallocArray(&(__EGdm->row_ord),__EGdm->row_sz);\
	__EGdmi = (int)(__EGdm->col_sz);\
	while(__EGdmi--) __EGdm->col_ord[__EGdmi] = __EGdmi;\
	__EGdmi = (int)(__EGdm->row_sz);\
	while(__EGdmi--) \
		__EGdm->matrow[__EGdmi] = __EGdm->matval + ((size_t)(__EGdmi) * __EGdm->col_sz);\
	__EGdmi = (int)(__EGdm->row_sz);\
	while(__EGdmi--) __EGdm->row_ord[__EGdmi] = __EGdmi;} while(0)

/* ========================================================================= */
/** @brief Display a given #dbl_EGdMatrix_t structure contents.
 * @param __dmatrix dense matrix structure pointer.
 * @param __nat_order if set to one, display the matrix using the natural 
 * internal order, i.e. we discard the order of columns and rows as defined in
 * #dbl_EGdMatrix_t::col_ord and #dbl_EGdMatrix_t::row_ord. Otherwise, use such orders.
 * @param __ofile pointer to a FILE structure where we want the output to be
 * printed.
 * */
#define dbl_EGdMatrixDisplay(__dmatrix,__nat_order,__ofile) do{\
	dbl_EGdMatrix_t*const __EGdm = (__dmatrix);\
	char* __EGdmstr = 0;\
	size_t __EGdmi, __EGdmj;\
	fprintf(__ofile,"Matrix %p\nDimensions: %zd rows, %zd columns\n", (void*)__EGdm, __EGdm->row_sz, __EGdm->col_sz);\
	if(__nat_order){\
		for(__EGdmi = 0 ; __EGdmi < __EGdm->row_sz ; __EGdmi++){\
			for(__EGdmj = 0 ; __EGdmj < __EGdm->col_sz ; __EGdmj++){\
				__EGdmstr = dbl_EGlpNumGetStr(__EGdm->matrow[__EGdmi][__EGdmj]);\
				fprintf(__ofile,"%10s ", __EGdmstr);\
				EGfree(__EGdmstr);\
			}\
			fprintf(__ofile,"\n");}\
	} else {\
		for(__EGdmi = 0 ; __EGdmi < __EGdm->row_sz ; __EGdmi++){\
			for(__EGdmj = 0 ; __EGdmj < __EGdm->col_sz ; __EGdmj++){\
				__EGdmstr = dbl_EGlpNumGetStr(__EGdm->matrow[__EGdm->row_ord[__EGdmi]][__EGdm->col_ord[__EGdmj]]);\
				fprintf(__ofile,"%10s ", __EGdmstr);\
				EGfree(__EGdmstr);\
			}\
			fprintf(__ofile,"\n");}\
	}} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set rows 
 * '__dest' to '__dest' + '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in row '__dest', and note that rows '__orig' and '__dest' should be different.
 * This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the row whose multiple will be added to the '__dest'
 * row.
 * @param '__dest' row to be replaced by '__dest' + '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' row.
 * @note The index of the row are taken as internal index, i.e. if we give row
 * 'k' we will use the row stored in #dbl_EGdMatrix_t::matrow[k], wich does not
 * mean that we will access the k-th row in the matrix (wich would need to use
 * as index the value #dbl_EGdMatrix_t::row_ord[k] instead). Note that we don't
 * test wether the given multiple is zero or not. we always perform the
 * operation.
 * */
#define dbl_EGdMatrixAddRowMultiple(__dmatrix,__dest,__orig,__num) do{\
	dbl_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (size_t)(__dest);\
	const size_t __EGori = (size_t)(__orig);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) \
		dbl_EGlpNumAddInnProdTo(__EGdm->matrow[__EGdest][__EGdmj],\
												__EGdm->matrow[__EGori][__EGdmj],__num);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set rows 
 * '__dest' to '__dest' - '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in row '__dest', and note that rows '__orig' and '__dest' should be different.
 * This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the row whose multiple will be added to the '__dest'
 * row.
 * @param '__dest' row to be replaced by '__dest' - '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' row.
 * @note The index of the row are taken as internal index, i.e. if we give row
 * 'k' we will use the row stored in #dbl_EGdMatrix_t::matrow[k], wich does not
 * mean that we will access the k-th row in the matrix (wich would need to use
 * as index the value #dbl_EGdMatrix_t::row_ord[k] instead). Note that we don't
 * test wether the given multiple is zero or not. we always perform the
 * operation.
 * */
#define dbl_EGdMatrixSubRowMultiple(__dmatrix,__dest,__orig,__num) do{\
	dbl_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (__dest);\
	const size_t __EGori = (__orig);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) \
		dbl_EGlpNumSubInnProdTo(__EGdm->matrow[__EGdest][__EGdmj],\
												__EGdm->matrow[__EGori][__EGdmj],__num);\
	} while(0)
/* ========================================================================= */
/** @brief Given a number and a row, multiply the complete row by the given
 * number. Note that the number MUST_NOT be stored in the row being multiplied,
 * this is because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param row_ind index of the row being multiplied, note that we will multiply
 * the row stored in #dbl_EGdMatrix_t::matrow[row_ind], wich is different to say
 * that we multiply the row in the row_ind-th position in the row ordering (to
 * do that, then row_ind should be #dbl_EGdMatrix_t::row_ord[k]).
 * @param multiple constant to be multiply to the row.
 * */
#define dbl_EGdMatrixMultiplyRow(__dmatrix,row_ind,multiple) do{\
	dbl_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdmi = (row_ind);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) dbl_EGlpNumMultTo(__EGdm->matrow[__EGdmi][__EGdmj],multiple);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set columns 
 * '__dest' to '__dest' + '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in column '__dest', and note that columns '__orig' and '__dest' should be 
 * different. This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the column whose multiple will be added to the '__dest'
 * column.
 * @param '__dest' column to be replaced by '__dest' + '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' column.
 * @note The index of the column are taken as internal index, i.e. if we give 
 * column 'k' we will use the column stored in #dbl_EGdMatrix_t::matrow[*][k], 
 * wich does not mean that we will access the k-th column in the matrix (wich
 * would need to use as index the value #dbl_EGdMatrix_t::row_ord[k] instead). 
 * Note that we don't test wether the given multiple is zero or not. we 
 * always perform the operation.
 * */
#define dbl_EGdMatrixAddColMultiple(__dmatrix,__dest,__orig,__num) do{\
	dbl_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (__dest);\
	const size_t __EGori = (__orig);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) \
		dbl_EGlpNumAddInnProdTo(__EGdm->matrow[__EGdmj][__EGdest],\
												__EGdm->matrow[__EGdmj][__EGori],__num);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set columns 
 * '__dest' to '__dest' - '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in column '__dest', and note that columns '__orig' and '__dest' should be 
 * different. This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the column whose multiple will be added to the '__dest'
 * column.
 * @param '__dest' column to be replaced by '__dest' - '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' column.
 * @note The index of the column are taken as internal index, i.e. if we give 
 * column 'k' we will use the column stored in #dbl_EGdMatrix_t::matrow[*][k], 
 * wich does not mean that we will access the k-th column in the matrix (wich 
 * would need to use as index the value #dbl_EGdMatrix_t::col_ord[k] instead). 
 * Note that we don't test wether the given multiple is zero or not. we 
 * always perform the operation.
 * */
#define dbl_EGdMatrixSubColMultiple(__dmatrix,__dest,__orig,__num) do{\
	dbl_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (size_t)(__dest);\
	const size_t __EGori = (size_t)(__orig);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) \
		dbl_EGlpNumSubInnProdTo(__EGdm->matrow[__EGdmj][__EGdest],\
												__EGdm->matrow[__EGdmj][__EGori],__num);\
	} while(0)
/* ========================================================================= */
/** @brief Given a number and a column, multiply the complete column by the 
 * given number. Note that the number MUST_NOT be stored in the column being 
 * multiplied, this is because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param __colind index of the column being multiplied, note that we will 
 * multiply the column stored in #dbl_EGdMatrix_t::matrow[*][__colind], wich is 
 * different to say that we multiply the column in the __colind-th position in
 * the column ordering (to do that, then __colind should be 
 * #dbl_EGdMatrix_t::col_ord[k]).
 * @param __mult constant to be multiply to the column.
 * */
#define dbl_EGdMatrixMultiplyCol(__dmatrix,__colind,__mult) do{\
	dbl_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdmi = (__colind);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) dbl_EGlpNumMultTo(__EGdm->matrow[__EGdmj][__EGdmi],__mult);\
	} while(0)


/* ========================================================================= */
/** @brief This function performs gaussian elimination to the given matrix,
 * depending on the given options it may do row/columns permutations allong the
 * way to improve numerical stabillity.
 * @param __dmatrix dense matrix structure pointer.
 * @param do_col_perm if set to one, the try columns permutation to improve
 * numericall stabillity, otherwise, not do column permutations at all.
 * @param do_row_perm if set to one, try row permutations to improve numericall
 * stabillity, otherwise, not do row permutations at all.
 * @param status pointer to where return an status, if the procedure finish all
 * the way (i.e. the matrix is full rank), then we return #EG_ALGSTAT_SUCCESS,
 * if the matrix is found to be partial rank, the status is
 * #EG_ALGSTAT_PARTIAL, otherwise, we return #EG_ALGSTAT_NUMERROR, wich means
 * that we stoped because a zero pivot was found (after checking for allowed
 * row/collumns permmutations).
 * @param rank where to return the (proven) rank of the matrix. This number is
 * accurate if the status is #EG_ALGSTAT_SUCCESS, or #EG_ALGSTAT_PARTIAL, but
 * is just a lower bound if the status is #EG_ALGSTAT_NUMERROR
 * @param zero_tol What is the threshold for a value to be considered zero.
 * @return if no error happen, we return zero, otherwise a non-zero valued is
 * returned. Note that the algorithm status is independent of the return value,
 * non zero values araise only if an error happen during execution, wich is
 * different to say that the algorithm didn't finish correctly. */
int dbl_EGdMatrixGaussianElimination (dbl_EGdMatrix_t * const __dmatrix,
																	const unsigned do_col_perm,
																	const unsigned do_row_perm,
																	unsigned *const rank,
																	const double zero_tol,
																	int *const status);

/* ========================================================================= */
/** @}*/
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef dbl___EG_DBASIS_REDUCTION__
#define dbl___EG_DBASIS_REDUCTION__
/* ========================================================================= */
/** @defgroup EGdBasisRed LLL Basis Reduction
 * Here we define a common interface for dense matrices (i.e. a structure), and
 * some common operations over dense matrices. The definition uses EGlpNum as
 * reference number type, this allow for template initializations.
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2005-10-28
 *  					- First implementation.
 * */
/**  @{ */
/** @file
 * @brief This file provide the user interface and function definitions for
 * the so-called LLL Basis Reduction Algorithm. This algorithm was first
 * presented in the paper "Factoring polynomials with rational coefficients",
 * Mathematische Annalen 261 (1981), p515-534. and has been extensivelly
 * studied elsewere. for more details just Google-it.
 * */
/** @example dbl_eg_dmatrix.ex.c */
/* ========================================================================= */
/** @brief verbosity level */
#define dbl_EG_DBSRED_VERBOSE 0

/* ========================================================================= */
/** @name Profiling structures and functions for the basis reduction algorithm.
 * */
/* @{ */
/* ========================================================================= */
/** @brief where to hold the profile information */
extern uintmax_t dbl_EGdBsRedStats[10];

/* ========================================================================= */
/** @brief where we store the number of calls to #dbl_EGdBsRed */
#define dbl_EG_BSRED_CALLS 0

/* ========================================================================= */
/** @brief where we store the total number of size reductions performed in 
 * #dbl_EGdBsRed */
#define dbl_EG_BSRED_SZRED 1

/* ========================================================================= */
/** @brief where we store the total number of interchanges performed in 
 * #dbl_EGdBsRed */
#define dbl_EG_BSRED_INTR 2

/* ========================================================================= */
/** @brief where we store the total number of innermost loops performed in 
 * #dbl_EGdBsRed */
#define dbl_EG_BSRED_ITT 3

/* ========================================================================= */
/** @brief Print into the given file stream, the current statistics related
 * to the #dbl_EGdBsRed algorithm. And reset all counters to zero.
 * @param __ofile where we want to print the profile information. */
#define dbl_EGdBsRedProfile(__ofile) do{\
	fprintf(__ofile,"LLL Basis Reduction Statistics:\n");\
	fprintf(__ofile,"\tNumber Calls    : %ju\n", dbl_EGdBsRedStats[dbl_EG_BSRED_CALLS]);\
	fprintf(__ofile,"\tLoops           : %ju\n", dbl_EGdBsRedStats[dbl_EG_BSRED_ITT]);\
	fprintf(__ofile,"\tSize Reductions : %ju\n", dbl_EGdBsRedStats[dbl_EG_BSRED_SZRED]);\
	fprintf(__ofile,"\tInterchanges    : %ju\n", dbl_EGdBsRedStats[dbl_EG_BSRED_INTR]);\
	memset(dbl_EGdBsRedStats,0,sizeof(dbl_EGdBsRedStats));} while(0)

/* @} */

/* ========================================================================= */
/** @brief Value used in condition two of the LLL algorithm, remember that this
 * number should be between \f$(1/4,1)\f$. By default we choose \f$\lambda =
 * \frac{2^{20}-1}{2^{20}} \approx .99999904632568359375 \f$. */
#define dbl_EG_DBSRED_ALPHA 0x7ffffp-20

/* ========================================================================= */
/** @brief structure to hold all necesary data to perform the LLL's basis
 * reduction algorithm. */
typedef struct dbl_EGdBsRed_t
{
	size_t dim;				/**< @brief Number of elements in the basis */
	size_t length;		/**< @brief Length of the vectors in the basis, note that
												 it should be that length >= dim */
	size_t basis_sz;	/**< @brief Actual length of the #dbl_EGdBsRed_t::basis 
												 array */
	double **basis;/**< @brief array of pointers to arrays containing the 
												 vector basis in extended (including zero coef) form. 
												 The vectors themselves are considered as allocated 
												 outside. everything else is considered as internally
												 allocated. */
	dbl_EGdMatrix_t GM;		/**< @brief Here we store and compute the Gram-Schmidt 
												 needed for the LLL basis reduction algorithm */
}
dbl_EGdBsRed_t;

/* ========================================================================= */
/** @brief Initialize an #dbl_EGdBsRed_t structure, as a basis with zero elements
 * of dimension zero.
 * @param __bsred pointer to an #dbl_EGdBsRed_t structure.
 * */
#define dbl_EGdBsRedInit(__bsred) do{\
	dbl_EGdBsRed_t*const __EGdbs = (__bsred);\
	memset(__EGdbs,0,sizeof(dbl_EGdBsRed_t));\
	dbl_EGdMatrixInit(&(__EGdbs->GM));} while(0)

/* ========================================================================= */
/** @brief Free any internally allocated memory in a #dbl_EGdBsRed_t structure.
 * @param __bsred pointer to an #dbl_EGdBsRed_t structure.
 * */
#define dbl_EGdBsRedClear(__bsred) do{\
	dbl_EGdBsRed_t*const __EGdbs = (__bsred);\
	if(__EGdbs->basis) EGfree(__EGdbs->basis);\
	dbl_EGdMatrixClear(&(__EGdbs->GM));} while(0)

/* ========================================================================= */
/** @brief reset an #dbl_EGdBsRed_t structure as a basis without elements (note
 * that we do not reset the length of the vectors, just the number of vectors 
 * in the basis).
 * @param __bsred pointer to an #dbl_EGdBsRed_t structure.
 * */
#define dbl_EGdBsRedReset(__bsred) ((__bsred)->dim = 0)

/* ========================================================================= */
/** @brief set the length of the vectors used in the basis for an #dbl_EGdBsRed_t
 * structure.
 * @param __bsred pointer to an #dbl_EGdBsRed_t structure.
 * @param __new_length length of the vectors in the basis.
 * */
#define dbl_EGdBsRedSetLength(__bsred,__new_length) ((__bsred)->length = (__new_length))

/* ========================================================================= */
/** @brief add a new vector to the basis.
 * @param __bsred pointer to an #dbl_EGdBsRed_t structure.
 * @param __new_elem new vector to add to the basis.
 * */
#define dbl_EGdBsRedAddElement(__bsred,__new_elem) do{\
	dbl_EGdBsRed_t*const __EGdbs = (__bsred);\
	if(__EGdbs->basis_sz <= __EGdbs->dim){\
		__EGdbs->basis_sz += 10U;\
		EGrealloc(__EGdbs->basis,sizeof(double*)*__EGdbs->basis_sz);}\
	__EGdbs->basis[__EGdbs->dim++] = (__new_elem);} while(0)

/* ========================================================================= */
/** @brief This function performs the so-called LLL basis reduction algorithm.
 * @param __bsred pointer to an #dbl_EGdBsRed_t structure.
 * @param status where we return the status of the algorithm, if the algorithm
 * finish with non-zero reduced elements, the status is #EG_ALGSTAT_SUCCESS. if
 * the algorithm finish with some zero reduced vector, the status is
 * #EG_ALGSTAT_PARTIAL. if the algorithm stop because of numerical problems,
 * the status is #EG_ALGSTAT_NUMERROR.
 * @param zero_tol threshold for a number to be considered as zero.
 * @param dim pointer to a number where we return the dimension of the basis
 * that the algorithm could prove before running in any numerical problem. If
 * the algorithm stop with status #EG_ALGSTAT_SUCCESS, then this number should
 * be equal to #dbl_EGdBsRed_t::dim. The vectors that we finish reducing are stored
 * in #dbl_EGdMatrix_t::row_ord[0], ... , #dbl_EGdMatrix_t::row_ord[dim], in the
 * #dbl_EGdBsRed_t::GM matrix.
 * @return zero if the algorithm finish, non-zero if an unforeseen error occure
 * during execution. 
 * @par Details:
 * The implementation that we use introduce (as an heuristic step) the sorting
 * of the original basis vectors in increasing order according to their norms,
 * this simple step reduced the total running time of the algorithm, but does
 * not improve the theoretical running time. A second detail is that we only
 * compute the Gram-Schmidth coefficients only once (at the beggining of the
 * program), and then, we only update the changed entries for both operations
 * \a size \a reduction and \a interchange. The advantage of the approach is
 * that we save most Gram-Schmidth computations and also all the recomputations
 * of the inner products of the elements currently in the basis. Again, this
 * are improvements form the practical point of view, but not in practice. The
 * dissadvantage of this approach is that we do accumulate rounding errors in
 * the Gram-Schmidth coefficients allong the way, but if all original vectors
 * coefficients where integer (and not too big), then the error should not grow
 * too much. Still this may happen if the input basis is ill conditioned.
 * */
int dbl_EGdBsRed (dbl_EGdBsRed_t * const __bsred,
							unsigned *const dim,
							const double zero_tol,
							int *const status);

/* ========================================================================= */
/**  @} */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGeHeap EGeHeap
 *
 * Here we define the basic interface for d-heaps as an embeded structure.
 * In this implementation the heap does not grow on the fly, meaning that it 
 * may fills-up during an add call, to avoid that, the user must call 
 * re-allocate when necesary. the heap start as a heap of size zero. 
 * This implementatioon is a minimum-heap implementatiton. Note also that the
 * internal connector array is shifted one position to the left. This is done 
 * so that the first element is in position 1, this also speed-up the 
 * computation of the parent and childrens of a given position.
 *
 * @version 0.0.1
 * @par History:
 * - 2010-09-05
 * 						- dbl_EGeHeapClear will free any internal memory (even if it was
 * 						asked for by the user).
 * - 2005-07-14
 * 						- Add dbl_EGeHeapEmpty to empty the heap (but keep its maximum
 * 							size)
 * 						- Add dbl_EGeHeapIsFull to test wether a heap is full or not.
 * - 2005-07-07
 * 						- First Implementation
 * @note 
 * This implementatiton is designed as a template using as base the types of
 * @ref EGlpNum
 * */
/** @file 
 * @ingroup EGeHeap */
/** @addtogroup EGeHeap */
/** @{ */
/** @example dbl_eg_eheap.ex.c
 * This is a simple example of the usage of heaps using @ref EGeHeap */
/* ========================================================================= */
#ifndef dbl___EG_EHEAP__
#define dbl___EG_EHEAP__
/* ========================================================================= */
/** @brief Debug level for the heap */
#ifndef dbl_EG_EHEAP_DEBUG
#define dbl_EG_EHEAP_DEBUG 1000
#endif

/* ========================================================================= */
/** @name Test macros, enabled only if debug level is high enough. */
/** @{ */
#if dbl_EG_EHEAP_DEBUG <= DEBUG
#define dbl_EGeHeapCHECK_CN(__hp2,__hcn2) EXIT(__hcn2->pos>=__hp2->sz,"Heap Connector possition %d out of range [0,%d]",__hcn2->pos,__hp2->sz)
#define dbl_EGeHeapCHECK_NF(__hp2) EXIT(__hp2->sz >= __hp2->max_sz,"Heap "#__hp2" Is full, can't add an element")
#else
#define dbl_EGeHeapCHECK_CN(__hp,__hcn) 
#define dbl_EGeHeapCHECK_NF(__hp) 
#endif
/** @} */
/* ========================================================================= */
/** @brief Structure to store the information relevant to an element in the
 * heap. */
typedef struct 
{
	double val;		/**< Value of this node in the heap */
	unsigned int pos;	/**< Position in the heap array for this node, if set to
												 #dbl_EG_EHEAP_POISON, then the connector is not in any 
												 heap.*/
}
dbl_EGeHeapCn_t;

/* ========================================================================= */
/** @brief Poison position for heap connector not in a heap. */
#define dbl_EG_EHEAP_POISON UINT_MAX

/* ========================================================================= */
/** @brief Initialize a heap conector structure. This function will allocate any
 * interal memory not allocated by the user, it should be called only once, or
 * after a clear function call.
 * @param __hcn conector to initialize.
 * */
#define dbl_EGeHeapCnInit(__hcn) ({dbl_EGlpNumInitVar((__hcn)->val);(__hcn)->pos = dbl_EG_EHEAP_POISON;})

/* ========================================================================= */
/** @brief Reset a heap conector to the same state as after an init call, this
 * function is provided only for completness.
 * @param __hcn conector to reset
 * */
#define dbl_EGeHeapCnReset(__hcn) ((__hcn)->pos = dbl_EG_EHEAP_POISON)

/* ========================================================================= */
/** @brief Free all internal memory used by this structured not allocated by the
 * user. This function should be called after an init call, and only once.
 * @param __hcn conector to clear.
 * */
#define dbl_EGeHeapCnClear(__hcn) dbl_EGlpNumClearVar((__hcn)->val)

/* ========================================================================= */
/** @brief Structure to hold a whole heap structure, this structure is designed
 * so that it can grow on the fly with a low cost */
typedef struct 
{
	dbl_EGeHeapCn_t **cn;
	unsigned int d;
	unsigned int sz;
	unsigned int max_sz;
}
dbl_EGeHeap_t;

/* ========================================================================= */
/** @brief Return one if the heap is full, zero otherwise.
 * @param __hp heat to check */
#define dbl_EGeHeapIsFull(__hp) ({dbl_EGeHeap_t*const __EGehp = (__hp); __EGehp->sz == __EGehp->max_sz;})

/* ========================================================================= */
/** @brief set the number of elements in hte heap to zero.
 * @param __hp heap to empty.
 * */
#define dbl_EGeHeapEmpty(__hp) ((__hp)->sz = 0)

/* ========================================================================= */
/** @brief Initialize a heap as an empty heap (with no space for conectors).
 * @param __hp heap to initialize.
 * */
#define dbl_EGeHeapInit(__hp) (*(__hp) = (dbl_EGeHeap_t){0,0,0,0})

/* ========================================================================= */
/** @brief Reset the given heap as an empty heap (just as returned by the init
 * call.
 * @param __hp heap to reset 
 * */
#define dbl_EGeHepReset(__hp) dbl_EGeHeapResize(__hp,0)

/* ========================================================================= */
/** @brief Clear a heap structure, and free any internal memory (not allocated
 * by the user).
 * @param __hp heap to clear.
 * */
#define dbl_EGeHeapClear(__hp) dbl_EGeHeapResize(__hp,0)

/* ========================================================================= */
/** @brief get the minimum value in the heap.
 * @param __hp heap where we are working.
 * @param number where to store the result
 * @return zero on success, non-zero otherwise.
 * */
#define dbl_EGeHeapGetMinVal(__hp,number) ({\
	dbl_EGeHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? (dbl_EGlpNumCopy(number,__EGehp->cn[0]->val),0):1;})

/* ========================================================================= */
/** @brief get the minimum conector in the heap, if the heap is empty, return
 * NULL.
 * @param __hp eap where we are working.
 * @return pointer to the minimum element in the heap.
 * */
#define dbl_EGeHeapGetMin(__hp) ({\
	dbl_EGeHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? __EGehp->cn[0] : 0;})

/* ========================================================================= */
/** @brief resize the heap cn array to the given size, if the new size is zero,
 * it is equivalent to free the internal memory, and left the heap as an empty
 * heap with zero space.
 * @param __hp heap where we are working.
 * @param new_sz new size for the  cn array .
 * */
#define dbl_EGeHeapResize(__hp,new_sz) ({\
	dbl_EGeHeap_t*const __EGehp = (__hp);\
	const size_t __EGehp_nsz = (size_t)(new_sz);\
	__EGehp->cn = EGrealloc((__EGehp->cn), __EGehp_nsz * sizeof(dbl_EGeHeapCn_t*));\
	__EGehp->max_sz = (unsigned int)(__EGehp_nsz);})

/* ========================================================================= */
/** @brief return the index of the father of the given index.
 * @param __d breadth of the heap.
 * @param __id position in the array to wich we want to compute it's father.
 * */
#define dbl_EGeHeapFatherId(__d,__id) ((__id)?(((__id)-1)/(__d)):0)

/* ========================================================================= */
/** @brief move an element in the heap up in the heap (position 0 is the top,
 * this kind of move is neded whenever we decrease the value in a heap element).
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * */
#define dbl_EGeHeapSiftUp(__hp,__hcn) ({\
	dbl_EGeHeap_t*const __EGehp = (__hp);\
	dbl_EGeHeapCn_t*const __EGecn = (__hcn);\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfpos = dbl_EGeHeapFatherId(__EGehp->d,__EGcpos);\
	dbl_EGeHeapCn_t*__EGfcn = __EGehp->cn[__EGfpos];\
	dbl_EGeHeapCHECK_CN(__EHehp,__EGecn);\
	while(__EGcpos && \
				dbl_EGlpNumIsLess(__EGecn->val,__EGfcn->val))\
	{\
		__EGfcn->pos = __EGcpos;\
		__EGehp->cn[__EGcpos] = __EGfcn;\
		__EGcpos = __EGfpos;\
		__EGfpos = dbl_EGeHeapFatherId(__EGehp->d,__EGcpos);\
		__EGfcn = __EGehp->cn[__EGfpos];\
	}\
	__EGecn->pos = __EGcpos;\
	__EGehp->cn[__EGcpos] = __EGecn;\
	0;})

/* ========================================================================= */
/** @brief Add an element to the heap
 * @param __hp heap where to add the element.
 * @param __hcn element to be added.
 * @return zero on success, non-zero otherwise.
 * */
#define dbl_EGeHeapAdd(__hp,__hcn) ({\
	dbl_EGeHeap_t*const __EGlhp = (__hp);\
	dbl_EGeHeapCn_t*const __EGlcn = (__hcn);\
	dbl_EGeHeapCHECK_NF(__EGlhp);\
	__EGlcn->pos = __EGlhp->sz, \
	__EGlhp->cn[__EGlhp->sz] = __EGlcn;\
	__EGlhp->sz +=1, \
	dbl_EGeHeapSiftUp(__EGlhp,__EGlcn), 0;})

/* ========================================================================= */
/** @brief Give the first child for a given position.
 * @param __id position that we want to get the first child.
 * @param __d breath of the heap. */
#define dbl_EGeHeapFirstChildId(__d,__id) ((__d)*(__id)+1)

/* ========================================================================= */
/** @brief Move an element down in the heap (position 0 is the
 * top), this kind of operation is needed whenever we increase the value in a
 * heap element.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define dbl_EGeHeapSiftDown(__hp,__hcn) ({\
	dbl_EGeHeap_t*const __EGehp = (__hp);\
	dbl_EGeHeapCn_t*const __EGecn = (__hcn);\
	const unsigned int __EGhsz = __EGehp->sz;\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfchd = dbl_EGeHeapFirstChildId(__EGehp->d,__EGcpos);\
	unsigned int __EGlchd = __EGfchd + __EGehp->d;\
	dbl_EGeHeapCn_t*__EGcchd = 0;\
	register unsigned int __EGehi = 0;\
	dbl_EGeHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGfchd < __EGhsz)\
	{\
		/* detect the minimum child */\
		__EGcchd = __EGehp->cn[__EGfchd];\
		for(__EGehi = __EGlchd > __EGhsz ? __EGhsz-1 : __EGlchd-1 ;\
			__EGehi > __EGfchd ; __EGehi--)\
			if(dbl_EGlpNumIsLess(__EGehp->cn[__EGehi]->val,__EGcchd->val))\
				__EGcchd = __EGehp->cn[__EGehi];\
		/* if the minimum child is less than the current position, move the minimum\
		 * child to the position of the current element */\
		if(dbl_EGlpNumIsLess(__EGcchd->val,__EGecn->val))\
		{\
			__EGfchd = __EGcchd->pos;\
			__EGcchd->pos = __EGcpos;\
			__EGehp->cn[__EGcpos] = __EGcchd;\
			__EGecn->pos = __EGcpos = __EGfchd;\
			__EGehp->cn[__EGcpos] = __EGecn;\
			__EGfchd = dbl_EGeHeapFirstChildId(__EGehp->d,__EGcpos);\
			__EGlchd = __EGfchd + __EGehp->d;\
		}\
		/* else we exit the main loop */\
		else __EGfchd = UINT_MAX;\
	}\
	0;})

/* ========================================================================= */
/** @brief Change the value of an element in the heap.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap that we are going to change it's value.
 * @param __new_val new value for the element.
 * @return zero on success, non-zero otherwise.
 * */
#define dbl_EGeHeapChangeVal(__hp,__hcn,__new_val) ({\
	(dbl_EGlpNumIsLess(__new_val,(__hcn)->val)) ? (dbl_EGlpNumCopy((__hcn)->val,__new_val),dbl_EGeHeapSiftUp(__hp,__hcn)) : (dbl_EGlpNumCopy((__hcn)->val,__new_val),dbl_EGeHeapSiftDown(__hp,__hcn));})

/* ========================================================================= */
/** @brief Eliminate an element from the heap, note that the position stored in
 * the eliminated element is reset to zero.
 * @param __hp heap where we are working.
 * @param __hcn element to eliminate from the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define dbl_EGeHeapDel(__hp,__hcn) ({\
	dbl_EGeHeap_t*const __EGlhp = (__hp);\
	dbl_EGeHeapCn_t*const __EGlhpcn = (__hcn);\
	unsigned int const __EGlcn = __EGlhpcn->pos;\
	unsigned int const __EGlhsz = __EGlhp->sz - 1;\
	__EGlhpcn->pos = dbl_EG_EHEAP_POISON;\
	__EGlhp->sz = __EGlhsz;\
	if(__EGlhsz && __EGlhsz != __EGlcn){\
		__EGlhp->cn[__EGlcn] = __EGlhp->cn[__EGlhp->sz];\
		__EGlhp->cn[__EGlcn]->pos = __EGlcn;\
		dbl_EGeHeapSiftDown(__EGlhp,__EGlhp->cn[__EGlcn]);}\
	__EGlhp->cn[__EGlhp->sz] = 0;})

/* ========================================================================= */
/** @brief Check the integrity of the given heap.
 * @param __hp heap to check.
 * @return zero on success, non-zero otherwise.
 * */
#if dbl_EG_EHEAP_DEBUG <= DEBUG
#define dbl_EGeHeapCheck(__hp) ({\
	dbl_EGeHeap_t*const __EGehp = (__hp);\
	register unsigned int __EGehi = __EGehp->sz;\
	if(__EGehi)\
		while(--__EGehi)\
			if(__EGehp->cn[__EGehi]->pos != __EGehi || dbl_EGlpNumIsLess( __EGehp->cn[\
				 __EGehi]->val,__EGehp->cn[dbl_EGeHeapFatherId(__EGehp->d,__EGehi)]->val))\
			{\
				MESSAGE(dbl_EG_EHEAP_DEBUG,"Element %u is wrong, pos %u val [%lf,%lf]"\
							 ,__EGehi, __EGehp->cn[__EGehi]->pos, \
							 dbl_EGlpNumToLf(__EGehp->cn[__EGehi]->val), \
							 dbl_EGlpNumToLf(__EGehp->cn[dbl_EGeHeapFatherId(__EGehp->d,__EGehi)]->val));\
				break;\
			}\
	__EGehi;})
#else
#define dbl_EGeHeapCheck(__hp) 0
#endif

/* ========================================================================= */
/** @brief set the breath of the heap, this function must be called only when
 * the heap is empty.
 * @param __hp heap to set breath.
 * @param __width new with for the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define dbl_EGeHeapChangeD(__hp,__width) ({\
	dbl_EGeHeap_t*const __EGehp = (__hp);\
	EXIT((__width)<2,"Width should be at least 2 for heaps");\
	__EGehp->sz ? 1 : (__EGehp->d = (__width), 0);})

/* ========================================================================= */
/** @} */
/* end of dbl_eg_eheap.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGeKHeap EGeKHeap
 *
 * Here we define the basic interface for d-heaps with an array of values with
 * the lexicographic order for vectors as an embeded structure.
 * In this implementation the heap does not grow on the fly, meaning that it 
 * may fill-up during an add call, to avoid that, the user must call 
 * re-allocate when necesary. the heap start as a heap of size zero. 
 * This implementatioon is a minimum-heap implementatiton. Note also that the
 * internal connector array is shifted one position to the left. This is done 
 * so that the first element is in position 1, this also speed-up the 
 * computation of the parent and childrens of a given position.
 *
 * @version 0.0.1
 * @par History:
 * - 2010-09-05
 * 						- Change implementation of dbl_EGeKHeapClear to free all internal
 * 						memory, including the one asked for the user during a
 * 						dbl_EGeKHeapResize call.
 * - 2008-07-30
 * 						- First implementation
 * @note 
 * This implementatiton is designed as a template using as base the types of
 * @ref EGlpNum
 * */
/** @file 
 * @ingroup EGeKHeap */
/** @addtogroup EGeKHeap */
/** @{ */
/** @example dbl_eg_ekheap.ex.c
 * This is a simple example of the usage of heaps using @ref EGeKHeap */
/* ========================================================================= */
#ifndef dbl___EG_EKHEAP__
#define dbl___EG_EKHEAP__
/* ========================================================================= */
/** @brief Debug level for the heap */
#ifndef dbl_EG_EKHEAP_DEBUG
#define dbl_EG_EKHEAP_DEBUG 100
#endif

/* ========================================================================= */
/** @name Test macros, enabled only if debug level is high enough. */
/** @{ */
#if dbl_EG_EKHEAP_DEBUG <= DEBUG
#define dbl_EGeKHeapCHECK_CN(__hp2,__hcn2) EXIT(__hcn2->pos>=__hp2->sz,"Heap Connector possition %d out of range [0,%d]",__hcn2->pos,__hp2->sz)
#define dbl_EGeKHeapCHECK_NF(__hp2) EXIT(__hp2->sz >= __hp2->max_sz,"Heap "#__hp2" Is full, can't add an element")
#else
#define dbl_EGeKHeapCHECK_CN(__hp,__hcn) 
#define dbl_EGeKHeapCHECK_NF(__hp) 
#endif
/** @} */
/* ========================================================================= */
/** @brief number of maximum entries in the vector values */
#ifndef dbl_EG_EKHEAP_ENTRY
#define dbl_EG_EKHEAP_ENTRY 3
#endif
/* ========================================================================= */
/** @brief Structure to store the information relevant to an element in the
 * heap. */
typedef struct
{
	double val[dbl_EG_EKHEAP_ENTRY];/**< Value of this node in the heap */
	unsigned int pos;	/**< Position in the heap array for this node, if set to
												 #dbl_EG_EKHEAP_POISON, then the connector is not in any 
												 heap.*/
}
dbl_EGeKHeapCn_t;

/* ========================================================================= */
/** @brief Poison position for heap connector not in a heap. */
#define dbl_EG_EKHEAP_POISON UINT_MAX

/* ========================================================================= */
/** @brief Initialize a heap conector structure. This function will allocate any
 * interal memory not allocated by the user, it should be called only once, or
 * after a clear function call.
 * @param __hcn conector to initialize.
 * */
#define dbl_EGeKHeapCnInit(__hcn) do{\
	dbl_EGeKHeapCn_t*const __EKHcn = (__hcn);\
	int __EKHi = dbl_EG_EKHEAP_ENTRY;\
	memset(__EKHcn,0,sizeof(dbl_EGeKHeapCn_t));\
	for( ; __EKHi-- ; ){dbl_EGlpNumInitVar(__EKHcn->val[__EKHi]);}\
	__EKHcn->pos = dbl_EG_EKHEAP_POISON;}while(0)

/* ========================================================================= */
/** @brief Reset a heap conector to the same state as after an init call, this
 * function is provided only for completness.
 * @param __hcn conector to reset
 * */
#define dbl_EGeKHeapCnReset(__hcn) ((__hcn)->pos = dbl_EG_EKHEAP_POISON)

/* ========================================================================= */
/** @brief Free all internal memory used by this structured not allocated by the
 * user. This function should be called after an init call, and only once.
 * @param __hcn conector to clear.
 * */
#define dbl_EGeKHeapCnClear(__hcn) do{\
	dbl_EGeKHeapCn_t*const __EKHcn = (__hcn);\
	int __EKHi = dbl_EG_EKHEAP_ENTRY;\
	for( ; __EKHi-- ; ){dbl_EGlpNumClearVar(__EKHcn->val[__EKHi]);}}while(0)

/* ========================================================================= */
/** @brief Structure to hold a whole heap structure, this structure is designed
 * so that it can grow on the fly with a low cost */
typedef struct
{
	dbl_EGeKHeapCn_t **cn;
	unsigned int d;
	unsigned int sz;
	unsigned int max_sz;
}
dbl_EGeKHeap_t;

/* ========================================================================= */
/** @brief Return one if the heap is full, zero otherwise.
 * @param __hp heat to check */
#define dbl_EGeKHeapIsFull(__hp) ({dbl_EGeKHeap_t*const __EGekhp = (__hp); __EGekhp->sz == __EGekhp->max_sz;})

/* ========================================================================= */
/** @brief set the number of elements in hte heap to zero.
 * @param __hp heap to empty.
 * */
#define dbl_EGeKHeapEmpty(__hp) ((__hp)->sz = 0)

/* ========================================================================= */
/** @brief Initialize a heap as an empty heap (with no space for conectors).
 * @param __hp heap to initialize.
 * */
#define dbl_EGeKHeapInit(__hp) (*(__hp) = (dbl_EGeKHeap_t){0,0,0,0})

/* ========================================================================= */
/** @brief Reset the given heap as an empty heap (just as returned by the init
 * call.
 * @param __hp heap to reset 
 * */
#define dbl_EGeKHepReset(__hp) dbl_EGeKHeapResize(__hp,0)

/* ========================================================================= */
/** @brief Clear a heap structure, and free any internal memory (not allocated
 * by the user).
 * @param __hp heap to clear.
 * */
#define dbl_EGeKHeapClear(__hp) dbl_EGeKHeapResize(__hp,0)

/* ========================================================================= */
/** @brief get the minimum value in the heap, note that since we are dealing
 * with a vector of values sorted lexicographically, the value is the value in
 * the first coordinate, other values can be accesses through
 * dbl_EGeKHeapGetMinKVal function.
 * @param __hp heap where we are working.
 * @param __number where to store the result
 * @return zero on success, non-zero otherwise.
 * */
#define dbl_EGeKHeapGetMinVal(__hp,__number) ({\
	dbl_EGeKHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? (dbl_EGlpNumCopy(__number,__EGehp->cn[0]->val[0]),0):1;})

/* ========================================================================= */
/** @brief get the k-th value of the first element in the heap.
 * @param __hp heap where we are working.
 * @param __number where to store the result.
 * @param __k which value to get (between 0 and dbl_EG_EKHEAP_ENTRY.
 * @return zero on success, non-zero otherwise.
 * */
#define dbl_EGeKHeapGetMinKVal(__hp,__k,__number) ({\
	dbl_EGeKHeap_t*const __EGehp = (__hp);\
	const int __EGki = (__k);\
	EXITL(dbl_EG_EKHEAP_DEBUG,(__EGki >= dbl_EG_EKHEAP_ENTRY) || (__EGki <0),\
				"K=%d out of range in dbl_EGeKHeapGetMinKVal", __EGki);\
	__EGehp->sz ? (dbl_EGlpNumCopy(__number,__EGehp->cn[0]->val[__EGki]),0):1;})

/* ========================================================================= */
/** @brief get the minimum conector in the heap, if the heap is empty, return
 * NULL.
 * @param __hp eap where we are working.
 * @return pointer to the minimum element in the heap.
 * */
#define dbl_EGeKHeapGetMin(__hp) ({\
	dbl_EGeKHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? __EGehp->cn[0] : 0;})

/* ========================================================================= */
/** @brief resize the heap cn array to the given size, if the new size is zero,
 * it is equivalent to free the internal memory, and left the heap as an empty
 * heap with zero space.
 * @param __hp heap where we are working.
 * @param __new_sz new size for the  cn array .
 * */
#define dbl_EGeKHeapResize(__hp,__new_sz) ({\
	dbl_EGeKHeap_t*const __EGehp = (__hp);\
	const size_t __EGehp_nsz = (size_t)(__new_sz);\
	__EGehp->cn = EGrealloc((__EGehp->cn), __EGehp_nsz * sizeof(dbl_EGeKHeapCn_t*));\
	__EGehp->max_sz = (unsigned int)(__EGehp_nsz);})

/* ========================================================================= */
/** @brief return the index of the father of the given index.
 * @param __d breadth of the heap.
 * @param __id position in the array to wich we want to compute it's father.
 * */
#define dbl_EGeKHeapFatherId(__d,__id) ((__id)?(((__id)-1)/(__d)):0)

/* ========================================================================= */
/** @brief given two heap connectors, return one if the first is less than the
 * second (in  lexicographic order).
 * @param __hcn1 first vector array.
 * @param __hcn2 second vector array.
 * @return one if __hcn1 <_LEX __hcn2 */
#define dbl_EGeKHeapIsLess(__hcn1,__hcn2) ({\
	double*const __EGEKH1 = (__hcn1);\
	double*const __EGEKH2 = (__hcn2);\
	int __EGEKHj = 0, __EGEKHrval = 0;\
	for( ; __EGEKHj < dbl_EG_EKHEAP_ENTRY ; __EGEKHj++)\
	{\
		if(dbl_EGlpNumIsLess(__EGEKH1[__EGEKHj], __EGEKH2[__EGEKHj])){\
			__EGEKHrval = 1; break;}\
		else if (dbl_EGlpNumIsNeq(__EGEKH1[__EGEKHj], __EGEKH2[__EGEKHj],dbl_epsLpNum)){\
			__EGEKHrval = 0; break;}\
	}\
	__EGEKHrval;})

/* ========================================================================= */
/** @brief copy two vector of values (only  dbl_EG_EKHEAP_ENTRY positions) from the
 * rource to the destination.
 * @param src dbl_source array.
 * @param dst destination array.
 * */
void dbl_EGeKHeapCopyVal(double*const dst, const double*const src);

/* ========================================================================= */
/** @brief move an element in the heap up in the heap (position 0 is the top,
 * this kind of move is neded whenever we decrease the value in a heap element).
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define dbl_EGeKHeapSiftUp(__hp,__hcn) ({\
	dbl_EGeKHeap_t*const __EGehp = (__hp);\
	dbl_EGeKHeapCn_t*const __EGecn = (__hcn);\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfpos = dbl_EGeKHeapFatherId(__EGehp->d,__EGcpos);\
	dbl_EGeKHeapCn_t*__EGfcn = __EGehp->cn[__EGfpos];\
	dbl_EGeKHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGcpos && \
				dbl_EGeKHeapIsLess(__EGecn->val,__EGfcn->val))\
	{\
		__EGfcn->pos = __EGcpos;\
		__EGehp->cn[__EGcpos] = __EGfcn;\
		__EGcpos = __EGfpos;\
		__EGfpos = dbl_EGeKHeapFatherId(__EGehp->d,__EGcpos);\
		__EGfcn = __EGehp->cn[__EGfpos];\
	}\
	__EGecn->pos = __EGcpos;\
	__EGehp->cn[__EGcpos] = __EGecn;\
	0;})

/* ========================================================================= */
/** @brief Add an element to the heap
 * @param __hp heap where to add the element.
 * @param __hcn element to be added.
 * @return zero on success, non-zero otherwise.
 * */
#define dbl_EGeKHeapAdd(__hp,__hcn) ({\
	dbl_EGeKHeap_t*const __EGlhp = (__hp);\
	dbl_EGeKHeapCn_t*const __EGlcn = (__hcn);\
	dbl_EGeKHeapCHECK_NF(__EGlhp);\
	__EGlcn->pos = __EGlhp->sz, \
	__EGlhp->cn[__EGlhp->sz] = __EGlcn, \
	__EGlhp->sz +=1, \
	dbl_EGeKHeapSiftUp(__EGlhp,__EGlcn), 0;})

/* ========================================================================= */
/** @brief Give the first child for a given position.
 * @param __id position that we want to get the first child.
 * @param __d breath of the heap. */
#define dbl_EGeKHeapFirstChildId(__d,__id) ((__d)*(__id)+1)

/* ========================================================================= */
/** @brief Move an element down in the heap (position 0 is the
 * top), this kind of operation is needed whenever we increase the value in a
 * heap element.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define dbl_EGeKHeapSiftDown(__hp,__hcn) ({\
	dbl_EGeKHeap_t*const __EGehp = (__hp);\
	dbl_EGeKHeapCn_t*const __EGecn = (__hcn);\
	const unsigned int __EGhsz = __EGehp->sz;\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfchd = dbl_EGeKHeapFirstChildId(__EGehp->d,__EGcpos);\
	unsigned int __EGlchd = __EGfchd + __EGehp->d;\
	dbl_EGeKHeapCn_t*__EGcchd = 0;\
	register unsigned int __EGehi = 0;\
	dbl_EGeKHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGfchd < __EGhsz)\
	{\
		/* detect the minimum child */\
		__EGcchd = __EGehp->cn[__EGfchd];\
		for(__EGehi = __EGlchd > __EGhsz ? __EGhsz-1 : __EGlchd-1 ;\
			__EGehi > __EGfchd ; __EGehi--)\
			if(dbl_EGeKHeapIsLess(__EGehp->cn[__EGehi]->val,__EGcchd->val))\
				__EGcchd = __EGehp->cn[__EGehi];\
		/* if the minimum child is less than the current position, move the minimum\
		 * child to the position of the current element */\
		if(dbl_EGeKHeapIsLess(__EGcchd->val,__EGecn->val))\
		{\
			__EGfchd = __EGcchd->pos;\
			__EGcchd->pos = __EGcpos;\
			__EGehp->cn[__EGcpos] = __EGcchd;\
			__EGecn->pos = __EGcpos = __EGfchd;\
			__EGehp->cn[__EGcpos] = __EGecn;\
			__EGfchd = dbl_EGeKHeapFirstChildId(__EGehp->d,__EGcpos);\
			__EGlchd = __EGfchd + __EGehp->d;\
		}\
		/* else we exit the main loop */\
		else __EGfchd = UINT_MAX;\
	}\
	0;})

/* ========================================================================= */
/** @brief Change the value of an element in the heap.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap that we are going to change it's value.
 * @param __new_val new value for the element (note this is an array of size at
 * least dbl_EG_EKHEAP_ENTRY.
 * @return zero on success, non-zero otherwise.
 * */
#define dbl_EGeKHeapChangeVal(__hp,__hcn,__new_val) ({\
	dbl_EGeKHeapCn_t*const __EGEKHcn = (__hcn);\
	(dbl_EGeKHeapIsLess(__new_val,(__EGEKHcn)->val)) ? (dbl_EGeKHeapCopyVal((__EGEKHcn)->val,__new_val),dbl_EGeKHeapSiftUp(__hp,__EGEKHcn)) : (dbl_EGeKHeapCopyVal((__EGEKHcn)->val,__new_val),dbl_EGeKHeapSiftDown(__hp,__EGEKHcn));})

/* ========================================================================= */
/** @brief Eliminate an element from the heap, note that the position stored in
 * the eliminated element is reset to zero.
 * @param __hp heap where we are working.
 * @param __hcn element to eliminate from the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define dbl_EGeKHeapDel(__hp,__hcn) ({\
	dbl_EGeKHeap_t*const __EGlhp = (__hp);\
	dbl_EGeKHeapCn_t*const __EGlhpcn = (__hcn);\
	unsigned int const __EGlcn = __EGlhpcn->pos;\
	unsigned int const __EGlhsz = __EGlhp->sz - 1;\
	__EGlhpcn->pos = dbl_EG_EKHEAP_POISON;\
	__EGlhp->sz = __EGlhsz;\
	if(__EGlhsz && __EGlhsz != __EGlcn){\
		__EGlhp->cn[__EGlcn] = __EGlhp->cn[__EGlhp->sz];\
		__EGlhp->cn[__EGlcn]->pos = __EGlcn;\
		dbl_EGeKHeapSiftDown(__EGlhp,__EGlhp->cn[__EGlcn]);}\
	__EGlhp->cn[__EGlhp->sz] = 0;})

/* ========================================================================= */
/** @brief Check the integrity of the given heap.
 * @param __hp heap to check.
 * @return zero on success, non-zero otherwise.
 * */
#if dbl_EG_EKHEAP_DEBUG <= DEBUG
#define dbl_EGeKHeapCheck(__hp) ({\
	dbl_EGeKHeap_t*const __EGehp = (__hp);\
	register unsigned int __EGehi = __EGehp->sz;\
	if(__EGehi)\
		while(--__EGehi)\
			if(__EGehp->cn[__EGehi]->pos != __EGehi || \
				dbl_EGeKHeapIsLess( __EGehp->cn[__EGehi]->val,\
												__EGehp->cn[dbl_EGeKHeapFatherId(__EGehp->d,__EGehi)]->val))\
			{\
				MESSAGE(dbl_EG_EKHEAP_DEBUG,"Element %u is wrong, pos %u val [%lf,%lf]"\
							 ,__EGehi, __EGehp->cn[__EGehi]->pos, \
							 dbl_EGlpNumToLf(__EGehp->cn[__EGehi]->val[0]), \
							 dbl_EGlpNumToLf(__EGehp->cn[dbl_EGeKHeapFatherId(__EGehp->d,__EGehi)]->val[0]));\
				break;\
			}\
	__EGehi;})
#else
#define dbl_EGeKHeapCheck(__hp) 0
#endif

/* ========================================================================= */
/** @brief set the breath of the heap, this function must be called only when
 * the heap is empty.
 * @param __hp heap to set breath.
 * @param __width new with for the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define dbl_EGeKHeapChangeD(__hp,__width) ({\
	dbl_EGeKHeap_t*const __EGehp = (__hp);\
	EXIT((__width)<2,"Width should be at least 2 for heaps");\
	__EGehp->sz ? 1 : (__EGehp->d = (__width), 0);})

/* ========================================================================= */
/** @} */
/* end of dbl_eg_ekheap.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGsrkGraph EGsrkGraph
 * This is a group of functions, macros and types designed to work with
 * graphs that are shrinkable, meaning that we can take two nodes in the
 * (current) graph, and shrink them into a single node, and at the same time
 * collapse all edges that become loops and if two edges are parallel, keep
 * just one (but keep a reference to the collapsed edge). At the same time the
 * shrunken nodes keep a list to the nodes 'embeded' or 'shrunken' into the
 * given node. More details in the structure definition and in the example.
 * Note that this implementation only support undirected graphs with actual
 * weights on the edges, the weights must be of type double, and their
 * values are updated during the shrinking procedure, so if anyone want to
 * have the original values omewere else, they will have to keep an extra copy
 * outside. Most of the ideas used in this implementation come from CONCORDE.
 * 
 * @version 0.0.1
 * @par History:
 * - 2005-06-01
 * 						- First Implementation.
 * */
/** @file
 * @ingroup EGsrkGraph */
/** @addtogroup EGsrkGraph */
/** @{ */
/** @example dbl_eg_shrink_graph.ex.c */
/* ========================================================================= */

#ifndef dbl__EGshrinkGraph_h__
#define dbl__EGshrinkGraph_h__
#ifndef dbl_EG_SRK_DEBUG
/* ========================================================================= */
/** @brief debuigging level, the lower the more debugging is carried out */
#define dbl_EG_SRK_DEBUG 100
#endif

/* ========================================================================= */
/** @brief Edge structure for shrinkable graphs */
typedef struct dbl_EGsrkEdge_t
{
	EGeUgraphEdge_t edge;	/**< Actual edge structure for the graph */
	EGeList_t members;		/**< list of other edges shrunken within this edge */
	unsigned int mmb_sz;	/**< length of the members list (without including the 
														 edge itsself */
	double weight;			/**< Weight for the edge */
}
dbl_EGsrkEdge_t;

/* ========================================================================= */
/** @brief Node structure for shrinkable graphs */
typedef struct dbl_EGsrkNode_t
{
	EGeUgraphNode_t node;	/**< actual node structure for the graph */
	EGeList_t members;		/**< list of other nodes shrunken with this node */
	unsigned int mmb_sz;	/**< length of the members list (without including the
														 node itself */
	EGes_t parent;				/**< If this node is the representant for its class, 
														 then this is a 'parent' node, otherwise, is a 
														 shrunken node */
	double weight;			/**< Weight of the @f$\delta(n)@f$ edges for this node
														 (in the shrunken graph), this should be 
														 initialized by the user. */
	dbl_EGsrkEdge_t *hit;			/**< used for internal purposes, in particular, while 
														 merging two adjacency lists, this field is used 
														 to store the first edge touching this node, and 
														 then used to retrieve that information. When we 
														 call #dbl_EGsrkIdentifyNodes this field is assumed 
														 to be NULL */
}
dbl_EGsrkNode_t;

/* ========================================================================= */
/** @brief Graph structure for shrinkable graphs */
typedef struct dbl_EGsrkGraph_t
{
	EGeUgraph_t G;					/**< Actual graph structure. */
	unsigned n_onodes;			/**< Number of original nodes */
	unsigned n_oedges;			/**< Number of original edges */
}
dbl_EGsrkGraph_t;

/* ========================================================================= */
/** @brief Initialize an edge structure.
 * @param e_edge */
#define dbl_EGsrkEdgeInit(e_edge) ({\
	dbl_EGsrkEdge_t*const _EGsrkE = (e_edge);\
	EGeUgraphEdgeInit(&(_EGsrkE->edge));\
	EGeListInit(&(_EGsrkE->members));\
	_EGsrkE->mmb_sz = 0;\
	dbl_EGlpNumInitVar(_EGsrkE->weight);\
	dbl_EGlpNumZero(_EGsrkE->weight);})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of an edge
 * structure.
 * @param e_edge */
#define dbl_EGsrkEdgeClear(e_edge) ({\
	EGeUgraphEdgeClear(&((e_edge)->edge));\
	dbl_EGlpNumClearVar((e_edge)->weight);})

/* ========================================================================= */
/** @brief Initialize a graph structure 
 * @param graph graph to be initialized */
#define dbl_EGsrkGraphInit(graph) ({\
	dbl_EGsrkGraph_t*const _EGsrkG = (graph);\
	EGeUgraphInit(&(_EGsrkG->G));\
	_EGsrkG->n_onodes = _EGsrkG->n_oedges = 0;})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a graph
 * structure.
 * @param graph */
#define dbl_EGsrkGraphClear(graph) EGeUgraphClear(&((graph)->G))

/* ========================================================================= */
/** @brief Initialize a node structure.
 * @param e_node node to be initialized */
#define dbl_EGsrkNodeInit(e_node) ({\
	dbl_EGsrkNode_t*const _EGsrkN = (e_node);\
	EGeUgraphNodeInit(&(_EGsrkN->node));\
	EGeListInit(&(_EGsrkN->members));\
	_EGsrkN->mmb_sz = 0;\
	_EGsrkN->hit = 0;\
	EGesInit(&(_EGsrkN->parent));\
	dbl_EGlpNumInitVar(_EGsrkN->weight);\
	dbl_EGlpNumZero(_EGsrkN->weight);})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a node
 * structure.
 * @param e_node */
#define dbl_EGsrkNodeClear(e_node) ({\
	EGeUgraphNodeClear(&((e_node)->node));\
	dbl_EGlpNumClearVar((e_node)->weight);})

/* ========================================================================= */
/** @brief Add a #dbl_EGsrkNode_t node to a #dbl_EGsrkGraph_t graph.
 * @param graph graph were to add the node.
 * @param N node to add to the graph.
 * @return zero on success, non-zero otherwise.
 * */
#define dbl_EGsrkAddNode(graph,N) EGeUgraphAddNode(&((graph)->G),&((N)->node))

/* ========================================================================= */
/** @brief Add a #dbl_EGsrkEdge_t edge to a #dbl_EGsrkGraph_t graph.
 * @param lG graph were to add the edge.
 * @param head_pt head node of the edge.
 * @param tail_pt tail node of the edge.
 * @param E edge to be added with end-points head_pt and tail_pt.
 * Note that this function will update the accumulated weight of both
 * endpoints of the newly added edge according to the value stored in the
 * #dbl_EGsrkEdge_t::weight field.
 * */
#define dbl_EGsrkAddEdge(lG,head_pt,tail_pt,E) ({\
	dbl_EGsrkNode_t*const _EGsrkH = (head_pt);\
	dbl_EGsrkNode_t*const _EGsrkT = (tail_pt);\
	dbl_EGsrkEdge_t*const _EGsrkE = (E);\
	dbl_EGlpNumAddTo(_EGsrkH->weight,_EGsrkE->weight);\
	dbl_EGlpNumAddTo(_EGsrkT->weight,_EGsrkE->weight);\
	EGeUgraphAddEdge(&((lG)->G),&(_EGsrkH->node),&(_EGsrkT->node),&(_EGsrkE->edge));})

/* ========================================================================= */
/** @brief Given two nodes in the current shrunken graph, shrunk them into one 
 * node.
 * @param G pointer to the graph where we are working
 * @param base first node.
 * @param srkN second node.
 * @return pointer to the new representing node.
 * @note We assume that the field dbl_EGsrkNode_t::hit is identically NULL for all
 * nodes currently in the shrunken graph (including base and srkN). 
 * @note We allways assume that N1 will be the representing node.
 * @note Take note that this structure can't get back the pointer to the srkN
 * node, the user should take care of that if needed.
 * */
dbl_EGsrkNode_t *dbl_EGsrkIdentifyNodes (dbl_EGsrkGraph_t * const G,
																 dbl_EGsrkNode_t * const base,
																 dbl_EGsrkNode_t * const srkN);

/* ========================================================================= */
/** @} 
 * end of dbl_eg_shrink_graph.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgPushRelabel EGalgPushRelabel
 *
 * Here we implement the push-relabel algorithm as defined in the book "Network 
 * Flows" by Magnanti et. all, in chapter 6,7 and 8. Using the variant
 * "Highest-label preflow-push algorithm" (described on page 230) wich choose
 * the active node from wich to push from as the one with highest distance
 * label. This variant has running time @f$ \mathcal{O}(n^2\sqrt{m}) @f$ where
 * @a n is the number of nodes in the graph, and @a m the number of edges in it.
 * Note that the call to #dbl_EGalgPRminSTcut produces a maximum @b pre_flow, to 
 * obtain a flow you should call the #dbl_EGalgPRmaxSTflow that takes the graph 
 * produced by #dbl_EGalgPRminSTcut and convert the preflow into a real flow. We
 * also choose to use to register the number of nodes with distance labels
 * @f$k,\quad\forall k=1,\ldots,n@f$ where @a n is the number of nodes in the
 * network. This is done because whenever the number of nodes with distance
 * labels @a k is zero, then all nodes with distance labels above @a k can be
 * set to @a n (and thus be added to the partially computed cut-set). This is an
 * (inportant) empirical speed-up, but does not affect the worst case complexity
 * analysis.
 * @version 1.0.0
 * @par History:
 * - 2010-05-07
 * 						- Add implementation using eg_adgraph.h
 * - 2005-06-01
 * 						- Add globla relabeling heuristic.
 * - 2005-05-30
 * 						- Final test results on the TSP x-files, all should be right now.
 * - 2005-05-26
 * 						- First Implementation.
 * @note This algorithm is implemented the embedded structures approach. I will
 * give further details on what this implies.
 *
 * @note It is important to note that this algorithm (as implemented here) 
 * @b WILL @b FAIL if an edge has infinite capacities. To handle that case
 * either we must re-program it, or you can put capacities suficiently large on
 * them (for example 2 times the sum of all bounded capacities) for this
 * algorithm to work.
 *
 * @note This implementation does use global relabeling, namelly, the
 * strategy when once in a while (for example every @a n or @a m relabeling
 * operations) we recompute
 * the exact distance labels. The use of this heuristic (together with the gap
 * heuristic) have been reported to be the most successfull in practice (see "On
 * Implementing Push-Relabel Method For The Maximum FLow Problem" from Boris V.
 * Cherkassy and Andrew V. Goldberg.) and also in the test that we have
 * performed on the fractional solutions of TSP's instances from the TSPLIB set
 * of problems using CONCORDE.
 * */
/** @file 
 * @ingroup EGalgPushRelabel */
/** @addtogroup EGalgPushRelabel */
/** @{ */
/** @example dbl_eg_push_relabel.ex.c
 * This is a complete example for the min-cut max-flow problem using the
 * push/relabel implementation offered in EGalgPR. */
#ifndef dbl___EG_PUSH_RELABEL_H__
#define dbl___EG_PUSH_RELABEL_H__
/* ========================================================================= */

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define dbl___PR_DEBUGL__ 100

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define dbl___PR_TEST_VERBOSE__ 100

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define dbl___PR_VERBOSE__ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define dbl___PR_PROFILE__ 100

/* ========================================================================= */
/** @brief If profiling is enable (i.e. #dbl___PR_PROFILE__ <= DEBUG), print 
 * some profiling information of the min s-t cut used up to now, and reset 
 * all internal counters to zero, if profiling is not enabled, nothing 
 * happen. */
/** @{ */
void dbl_EGalgPRprofile(void);
/** @} */
/* ========================================================================= */
/** @brief If set to non-zero, use the global relabeling heuristic (to be called
 * every @a n number of relabel operations performed. if set to zero, it won't
 * use this heuristic. Note thought that it has been shown that this is a very
 * efficient heuristic to reduce the total running time, specially in the
 * #dbl_EGalgPRminSTcut function call. */
#define dbl_EG_PR_RELABEL 1

/* ========================================================================= */
/** @brief If #dbl_EG_PR_RELABEL is set to one, then this initeger controls how
 * often we perform the global relabeling heuristic (in multiples of number of
 * nodes), the default value is 1. */
#define dbl_EG_PR_RELABEL_FREC 1U

/* ========================================================================= */
/** @brief Node structure neede to run Push-Relabel algorithm on a network.
 * @note Notice that the directed graph part is embeded in this structure as
 * well. Note  that we could define internally space for  LVL_list, 
 * but for the sake of speed we include them in the node structure. */
typedef struct dbl_EGalgPRnode_t
{
	EGeDgraphNode_t v;		/**< Actual node structure to work with (EGeDgraph) */
	EGeList_t LVL_list;		/**< Used to store the BFS list used for the first 
														 computations of the exact label distances, and 
														 then to store this node in it's current level list 
														 (this is used to implement the Highest-Label 
														 variant of the Preflow-Push algorithm) */
	EGeList_t T_cut;			/**< Used to speed-up the 'hole' heuristic, it is seted
														 once we enter the algorithm, so their value is 
														 non-important outside the function (but it's 
														 contents will be lost once we enter 
														 #dbl_EGalgPRminSTcut). */
	unsigned int d;				/**< Exact label distance for this node. Note that 
														 nodes with distance lables @f$ \geq n @f$ (where 
														 @a n is the number of nodes in the graph) define 
														 the minimum @f$ s-t@f$ cut that we are looking 
														 for. */
	double e;					/**< Exess flow in the node. Note that in particular 
														 the excess on node @a t (once #dbl_EGalgPRminSTcut 
														 finish) correspond to the minimum cut value. */
}
dbl_EGalgPRnode_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an dbl_EGalgPRnode_t structure */
#define dbl_EGalgPRnodeInit(node_pt) ({\
	dbl_EGalgPRnode_t*const __EGalgPR_in = (node_pt);\
	dbl_EGlpNumInitVar(__EGalgPR_in->e);\
	EGeDgraphNodeInit(&(__EGalgPR_in->v));})

/* ========================================================================= */
/** @brief Reset the given node pointer (as if it were new).
 * @param node_pt pointer to the node to reset.
 * 
 * This function set the node as an empty node not linked with any graph.
 * */
#define dbl_EGalgPRnodeReset(node_pt) EGeDgraphNodeReset(&((node_pt)->v))

/* ========================================================================= */
/** @brief clear a pointer to an dbl_EGalgPRnode_t structure, and let it ready to be
 * freed if necesary. */
#define dbl_EGalgPRnodeClear(node_pt) ({\
	dbl_EGlpNumClearVar((node_pt)->e);\
	EGeDgraphNodeClear(&((node_pt)->v));})

/* ========================================================================= */
/** @brief capacitated edge structure with forward/backward information. */
typedef struct dbl_EGalgPRse_t
{
	EGeDgraphEdge_t e;	/**< actual edge information. */
	double r;				/**< residual capacity of the edge. */
	double u;				/**< maximum capacity on the edge. */
	unsigned char type;	/**< type of edge (0 for forward and 1 for backward */
}
dbl_EGalgPRse_t;

/* ========================================================================= */
/** @brief Edge Structure needed to run Push-Relabel algorithm on a network.
 * @note Notice that the this edge actually has actually two capacited edge
  substructures, one for forward edges and one for backward edge, it is assumed
 * that fw.type == 0 and bw.type == 1. This is needed because the algorithm 
 * asumes that both
 * edges exists (althought one may have zero capacity). Moreover, while
 * computing the residual capacities we need to access both edges e_ij and e_ji
 * at the same time, thus our choice to represent both edges in just one
 * structure. We also assume that the lower bound on the flow of all edges is
 * zero. Note that we don't need to keep explicitly the flow on the edges,
 * because given the residual capacity and the capacity on the edge we have that
 * @f$ x_{ij} - x_{ji} = u_{ij} - r_{ij} @f$ and thus we can set @f$ x_{ij} =
 * (u_{ij}-r_{ij})_+ @f$ and @f$ x_{ji} = (r_{ij}-u_{ij})_+ @f$.
 * if we have computed the maximal flow. */
typedef struct dbl_EGalgPRedge_t
{
	dbl_EGalgPRse_t fw;		/**< forward edge, we assum that fw.type = 0 */
	dbl_EGalgPRse_t bw;		/**< backward edge, we assume that bw.type = 1 */
}
dbl_EGalgPRedge_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an dbl_EGalgPRedge_t structure */
#define dbl_EGalgPRedgeInit(edge_pt) ({\
	dbl_EGalgPRedge_t*const __EGalgPR_ie = (edge_pt);\
	dbl_EGlpNumInitVar(__EGalgPR_ie->fw.r);\
	dbl_EGlpNumInitVar(__EGalgPR_ie->fw.u);\
	dbl_EGlpNumInitVar(__EGalgPR_ie->bw.r);\
	dbl_EGlpNumInitVar(__EGalgPR_ie->bw.u);\
	EGeDgraphEdgeInit(&(__EGalgPR_ie->fw.e));\
	EGeDgraphEdgeInit(&(__EGalgPR_ie->bw.e));\
	__EGalgPR_ie->bw.type = 1;\
	__EGalgPR_ie->fw.type = 0;})

/* ========================================================================= */
/** @brief Reset the given edge pointer (as if it were new).
 * @param edge_pt pointer to the node to reset.
 * 
 * This function set the edge as an empty edge not linked with any graph.
 * */
#define dbl_EGalgPRedgeReset(edge_pt) ({\
	dbl_EGalgPRedge_t*const __EGalgPR_ie = (edge_pt);\
	EGeDgraphEdgeReset(&(__EGalgPR_ie->fw.e));\
	EGeDgraphEdgeReset(&(__EGalgPR_ie->bw.e));\
	__EGalgPR_ie->bw.type = 1;\
	__EGalgPR_ie->fw.type = 0;})


/* ========================================================================= */
/** @brief clear a pointer to an dbl_EGalgPRedge_t structure, and let it ready to be
 * freed if necesary. */
#define dbl_EGalgPRedgeClear(edge_pt) ({\
	dbl_EGlpNumClearVar((edge_pt)->fw.r);\
	dbl_EGlpNumClearVar((edge_pt)->fw.u);\
	dbl_EGlpNumClearVar((edge_pt)->bw.r);\
	dbl_EGlpNumClearVar((edge_pt)->bw.u);\
	EGeDgraphEdgeClear(&((edge_pt)->fw.e));\
	EGeDgraphEdgeClear(&((edge_pt)->bw.e));})

/* ========================================================================= */
/** @brief Graph structure needed to run Push-Relabel algorithm (with highest
 * label node selection rule). */
typedef struct dbl_EGalgPRgraph_t
{
	EGeDgraph_t G;				/**< EGeDgraph structure holding the graph 
														 information. */
}
dbl_EGalgPRgraph_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an dbl_EGalgPRgraph_t structure */
#define dbl_EGalgPRgraphInit(graph_pt) EGeDgraphInit(&((graph_pt)->G))

/* ========================================================================= */
/** @brief Reset the given graph pointer (as if it were new).
 * @param graph_pt pointer to the node to reset.
 * 
 * This function set the graph as an empty graph.
 * */
#define dbl_EGalgPRgraphReset(graph_pt) EGeDgraphReset(&((graph_pt)->G))

/* ========================================================================= */
/** @brief clear a pointer to an dbl_EGalgPRgraph_t structure, and let it ready 
 * to be freed if necesary. */
#define dbl_EGalgPRgraphClear(graph_pt) EGeDgraphClear(&((graph_pt)->G))

/* ========================================================================= */
/** @brief Compute a minimum @f$s-t@f$ cut.
 * @param s pointer to the dbl_source node.
 * @param t pointer to the dbl_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the dbl_EGalgPRgraph_t* in wich we will work.
 * @return zero on success, non-zero otherwise.
 * @par Description:
 * When this funcion finish (successfully) all nodes with field
 * #dbl_EGalgPRnode_t::d bigger than or equal to @a n (the number of nodes in the
 * graph) bellong to the @a s cut, while nodes with value strictly less than @a
 * n will bellong to the @a t cut. The residual capacities imply a maximum
 * pre-flow in the network, to get an acutal maximum flow you should run 
 * #dbl_EGalgPRmaxSTflow function with imput the output graph of this function 
 * (for an example look at the file dbl_eg_push_relabel.ex.c ).
 * @note This implementation uses the @a gap and @a global @a relabeling
 * heuristics to speed-up the computations.
 * */
int dbl_EGalgPRminSTcut (dbl_EGalgPRgraph_t * const G,
										 dbl_EGalgPRnode_t * const s,
										 dbl_EGalgPRnode_t * const t);

/* ========================================================================= */
/** @brief Compute a maximum @f$s-t@f$ flow from the ouput produced by
 * EGalgPRminCur.
 * @param s pointer to the dbl_EGalgPRnode_t* dbl_source node in the network.
 * @param t pointer to the dbl_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the dbl_EGalgPRgraph_t* in wich we will work.
 * @return zero on success, non-zero otherwise.
 * @par Description:
 * We assume that our input graph is the (unaltered) result of a 
 * call to #dbl_EGalgPRminSTcut. Also, note that while computing the actual 
 * max @a s-@a t flow, we don't need to look for @a gap in the array of 
 * distances.
 * Also note that once you call this function, the information in
 * #dbl_EGalgPRnode_t::d don't correspond any more to the cut as defined in
 * #dbl_EGalgPRminSTcut.
 * */
int dbl_EGalgPRmaxSTflow (dbl_EGalgPRgraph_t * const G,
											dbl_EGalgPRnode_t * const s,
											dbl_EGalgPRnode_t * const t);

/* ========================================================================= */
/** @brief Check if the given input graph (with it's residual capacities)
 * represent an optimal solution to the maximum @f$ s-t @f$ flow / minimum
 * capacity @f$ s-t @f$ cut.
 * @param s pointer to the dbl_EGalgPRnode_t* dbl_source node in the network.
 * @param t pointer to the dbl_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the dbl_EGalgPRgraph_t* in wich we will work.
 * @param error worst error while checking for optimality conditions.
 * @return zero if all discrepancies are under the #dbl_epsLpNum threshold, 
 * otherwise, return the number of conditions that don't hold within that
 * threshold, and report in error the worst error found in any condition.
 * @note The input for this function should be the graph as returned by
 * #dbl_EGalgPRmaxSTflow .
 * */
int dbl_EGalgPRoptimalityTest (dbl_EGalgPRgraph_t * const G,
													 dbl_EGalgPRnode_t * const s,
													 dbl_EGalgPRnode_t * const t,
													 double * error);

/* ========================================================================= */
/* @} */
/* end of dbl_eg_push_relabel.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgMinCut EGalgMinCut
 *
 * Here we implement the min-cut algorithm based on the srinking
 * pre-processing of Padberg And Rinaldi in the paper "An Efficient 
 * Algorithm For The Minimum Capacity Cut Problem", Mathematical Programming
 * 47 (1990) pages 19-36. But using as minimum s-t cut code the Push-Relabel
 * max flow algorithm as implemented in the @ref EGalgPushRelabel module. This 
 * implies that we only support positive edge-weights.
 *
 * This implementation allows uses of diferent numbers as supported by
 * @ref EGlpNum module. And follows the philosophy of embeded structures as in
 * @ref EGalgPushRelabel module. Also, much of the approach used in this 
 * implementation come from CONCORDE's implementation.
 *
 * It is usually the case that the Minimum Cut Problem is just a sub-problem
 * of some larger problem, is for that reason that we implement (just as in
 * CONCORDE) a callback function that is called whenever an improving solution
 * is found, so that the user can do something with the given node-cutset and
 * value. for more details see the definition of #dbl_EGalgMCcbk_t .
 *
 * @note 
 * If run with types like EGfp20_t, if the arithmetic produces an overflow,
 * then we are in big trouble, note that the numbers involved in the algorithm
 * may range up to \f$\sum(w_e:e\in E(G))\f$.
 *
 * @version 0.0.1
 * @par History:
 * - 2005-08-19
 * 						- While computing a minimum S-T cut, choose S randomly. and T
 * 							as a node at maximum distance (number of edges) from S.
 * 						- Fix small problem with shrinking level 4
 * - 2005-06-20
 * 						- First Implementation.
 * */
/** @file
 * @ingroup EGalgMinCut */
/** @addtogroup EGalgMinCut */
/** @{ */
/** @example dbl_eg_min_cut.ex.c */
/* ========================================================================= */
#ifndef dbl__EG_MIN_CUT_H
#define dbl__EG_MIN_CUT_H
/* ========================================================================= */
/** @brief Verbosity Level */
#define dbl___MC_VRBLVL_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define dbl___MC_DEBUG_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define dbl___MC_PROFILE_ 0

/* ========================================================================= */
/** If profiling is enable (i.e. #dbl___MC_PROFILE_ <= DEBUG), print 
 * some profiling information of the min cut used up to now, and reset 
 * all internal counters to zero, if profiling is not enabled, nothing 
 * happen. */
/** @{ */
void dbl_EGalgMCprofile(void);
/** @} */

/* ========================================================================= */
/** @brief Call-back function, it receives as input the weight of the cut, the
 * size of the newly found cut, an array containing the cut (of length at
 * least the number of elements in the cut) as integers (as defined by the 
 * #dbl_EGalgMCnode_t::id field), and a pointer to some internal
 * data (as stored in #dbl_EGalgMCcbk_t::param). The function should return zero
 * on success, and non-zero if an error ocours, this error will be propagated
 * through the calling functions. */
typedef int (*dbl_EGalgMCdo_f) (double,
														const unsigned int,
														const unsigned int *const,
														void *);

/* ========================================================================= */
/** @brief Call-back structure for use when an improving minimum cut is found.
 * */
typedef struct dbl_EGalgMCcbk_t
{
	double cutoff;	/**< maximum value for the newly found minimum cut, for 
												 the function to be called. */
	void *param;			/**< external parameter needed by the function */
	dbl_EGalgMCdo_f do_fn;/**< actual function to be called if the cut-off condition 
												 holds */
}
dbl_EGalgMCcbk_t;

/* ========================================================================= */
/** @brief Initialize a call-back structure.
 * @param cb call-back to be initialized. */
#define dbl_EGalgMCcbkInit(cb) ({\
	dbl_EGalgMCcbk_t*const _EGalgMCcb = (cb);\
	dbl_EGlpNumInitVar(_EGalgMCcb->cutoff);\
	_EGalgMCcb->param = 0;\
	_EGalgMCcb->do_fn = 0;})

/* ========================================================================= */
/** @brief Free all internal memory asociated with this structure (not
 * allocated by the user).
 * @param cb call-back strucure to be cleared */
#define dbl_EGalgMCcbkClear(cb) dbl_EGlpNumClearVar((cb)->cutoff)

/* ========================================================================= */
/** @brief Node structure for Minimum Cut */
typedef struct dbl_EGalgMCnode_t
{
	dbl_EGsrkNode_t node;		/**< Actual shrinkable node */
	unsigned int id;		/**< External Identifier for the node */
	EGeList_t lvl_cn;		/**< Connector for the level list */
	unsigned int dbl_lvl;		/**< Current node level test to be performed */
	unsigned int new_id;/**< internal data, it's values can be discarded */
	dbl_EGsrkEdge_t *hit;		/**< Used to speed-up the Padberg-Rinaldi tests. */
}
dbl_EGalgMCnode_t;

/* ========================================================================= */
/** @brief Initialize a node structure for use.
 * @param N node to be initialized */
#define dbl_EGalgMCnodeInit(N) ({\
	dbl_EGalgMCnode_t*const _EGalgMCn = (N);\
	dbl_EGsrkNodeInit(&(_EGalgMCn->node));\
	_EGalgMCn->lvl_cn = (EGeList_t){0,0};\
	_EGalgMCn->dbl_lvl = 0;\
	_EGalgMCn->id = UINT_MAX;\
	_EGalgMCn->new_id = UINT_MAX;\
	_EGalgMCn->hit = 0;})

/* ========================================================================= */
/** @brief Clear any internal memory (not allocated by the user) used by this
 * structure.
 * @param N node to be cleared */
#define dbl_EGalgMCnodeClear(N) dbl_EGsrkNodeClear(&((N)->node))

/* ========================================================================= */
/** @brief Edge structure for the Minimum Cut */
typedef struct dbl_EGalgMCedge_t
{
	dbl_EGsrkEdge_t edge;	/**< Actual shrinkable edge */
	unsigned int id;	/**< External Identifier for the edge */
}
dbl_EGalgMCedge_t;

/* ========================================================================= */
/** @brief Initialize an edge structure for use.
 * @param E edge to be initialized */
#define dbl_EGalgMCedgeInit(E) ({\
	dbl_EGalgMCedge_t*const _EGalgMCe = (E);\
	dbl_EGsrkEdgeInit(&(_EGalgMCe->edge));\
	_EGalgMCe->id = UINT_MAX;})

/* ========================================================================= */
/** @brief Clear any internal memory (not allocated by the user) used by this
 * structure.
 * @param E node to be cleared */
#define dbl_EGalgMCedgeClear(E) dbl_EGsrkEdgeClear(&((E)->edge))

/* ========================================================================= */
/** @brief Graph Structure for Minimum Cut.
 *
 * Note that this structure also holds some parameters as the epsilon to use
  in the comparisons, the current best cut found (or bound), and the current
 * cut found so-far. As well as an array containing all edges and nodes in
 * thee graph (remember that when we Identify two nodes, we loose any
 * reference to the shrinked node in the graph structure as discussed in
 * #dbl_EGsrkIdentifyNodes ) 
 * */
typedef struct dbl_EGalgMCgraph_t
{
	dbl_EGsrkGraph_t G;						/**< Actual shrinking graph used */
	double epsilon;				/**< error tolerance used for equality testing */
	double cut_val;				/**< if #dbl_EGalgMCgraph_t::cut_sz is not zero, then 
																 this is the value of the (currenlty) best 
																 minimum cut found so far. otherwise is a bound 
																 on the value of the minimum cut (note that this
																 value should be set before actually computing 
																 the minimum cut, and can be set to the value 
																 of @f$\delta(v)@f$ for some node @a v in the 
																 graph. */
	unsigned int cut_sz;			/**< number of nodes in the current best cut, if 
																 set to zero, then no cut has been found 
																 (so far) */
	EGeList_t lvl_list[5];		/**< List of nodes in different levels of tests */
	unsigned int *cut;				/**< Array  storing the current cut, the size of 
																 this array should be at least 
																 #dbl_EGsrkGraph_t::n_onodes */
	dbl_EGalgMCnode_t *all_nodes;	/**< Array containing all nodes of the graph. */
	dbl_EGalgMCedge_t *all_edges;	/**< Array containing all edges of the graph. */
}
dbl_EGalgMCgraph_t;

/* ========================================================================= */
/** @brief Initialize a graph structure for use.
 * @param Graph graph to be initialized */
#define dbl_EGalgMCgraphInit(Graph) ({\
	dbl_EGalgMCgraph_t*const _EGalgMCg = (Graph);\
	dbl_EGsrkGraphInit(&(_EGalgMCg->G));\
	dbl_EGlpNumInitVar(_EGalgMCg->epsilon);\
	dbl_EGlpNumZero(_EGalgMCg->epsilon);\
	dbl_EGlpNumInitVar(_EGalgMCg->cut_val);\
	dbl_EGlpNumZero(_EGalgMCg->cut_val);\
	_EGalgMCg->cut_sz = 0;\
	EGeListInit(_EGalgMCg->lvl_list);\
	EGeListInit(_EGalgMCg->lvl_list+1);\
	EGeListInit(_EGalgMCg->lvl_list+2);\
	EGeListInit(_EGalgMCg->lvl_list+3);\
	EGeListInit(_EGalgMCg->lvl_list+4);\
	_EGalgMCg->cut = 0;\
	_EGalgMCg->all_nodes = 0;\
	_EGalgMCg->all_edges = 0;})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a graph
 * structure.
 * @param Graph graph to be cleared. */
#define dbl_EGalgMCgraphClear(Graph) ({\
	dbl_EGsrkGraphClear(&((Graph)->G));\
	dbl_EGlpNumClearVar((Graph)->epsilon);\
	dbl_EGlpNumClearVar((Graph)->cut_val);})

/* ========================================================================= */
/** @brief Shrink two nodes in the graph, and update internal structures.
 * @param Graph current graph.
 * @param N node to keep in graph.
 * @param M node to shrink within N. */
#define dbl_EGalgMCidentifyNodes(Graph,N,M) ({\
	dbl_EGalgMCgraph_t*const _EGalgMCg = (Graph);\
	dbl_EGalgMCnode_t*const _EGalgMCn = (N), *const _EGalgMCm = (M);\
	MESSAGE(dbl___MC_DEBUG_,"Shrinking nodes with weight %lf %lf", \
					dbl_EGlpNumToLf(_EGalgMCn->node.weight), \
					dbl_EGlpNumToLf(_EGalgMCm->node.weight));\
	dbl_EGsrkIdentifyNodes(&(_EGalgMCg->G), &(_EGalgMCn->node), &(_EGalgMCm->node));\
	if(_EGalgMCn->dbl_lvl < 5)\
	{\
		EGeListDel(&(_EGalgMCm->lvl_cn));\
		EGeListMoveAfter(&(_EGalgMCn->lvl_cn), _EGalgMCg->lvl_list);\
	}\
	else EGeListAddAfter(&(_EGalgMCn->lvl_cn), _EGalgMCg->lvl_list);\
	_EGalgMCn->dbl_lvl = 0;})

/* ========================================================================= */
/** @brief Identify all Padberg and Rinaldy edges. i.e. shrink all edges that
 * satisfy the conditions in their paper. we choose to make tests over pair of
 * nodes linked by an edge. 
 * @param max_lvl set a limit on wich tests to perform. for example, if set to
 * 1, only the first and second tests will be carried out.
 * @param G graph over wich we are working. 
 * @param cb call back structure to use (if set to NULL it is not used).
 * @return zero on success, non-zero otherwise. 
 *
 * Note that while doing this identification process, we update the values of
 * #dbl_EGalgMCgraph_t::cut, #dbl_EGalgMCgraph_t::cut_sz and #dbl_EGalgMCgraph_t::cut_val,
 * as well as performing the actual shrinking procedure.
 *
 * The original theorem (for local conditions on shrinking) is the following:
 * Let @f$ Z @f$ be a proper subset of @f$ V @f$ (the set of all nodes in the
 * graph), @f$ |Z|\geq2 @f$, and let 
 * @f[ P(Z) = \bigcup\left\{ N(u)\cap N(v):u\neq v, u,v\in Z \right\} @f]
 * where @f$ N(u) @f$ if the set of neighbours of @f$ u @f$. If there exists
 * @f$ Y\subseteq P(Z) @f$ such that for every nonempty proper subset @f$ W
 * @f$ of @f$ Z @f$ and for every @f$ T\subseteq Y @f$ either:
 * -# @f$ w(\delta(W))/2 \leq w(W:(Y-T)+(Z-W)) @f$ or
 * -# @f$ w(\delta(Z-W))/2 \leq w(Z-W:T+W) @f$.
 * Then there exists a minimum cut @f$(X:V-X)@f$ such that either @f$
 * Z\subseteq X @f$ or @f$ X\subseteq Z @f$.
 *
 * And the original theorem (in fact is the corollary 3.5 in the paper) 
 * regarding global conditions for shrinking is the following:
 * Let @f$ u\neq v\in V @f$, and let @f$ q @f$ be an upper bound on the
 * minimum cut value, and @f$ lb_{uv} @f$ be a lower bound in the value of a
 * minimum @f$ u-v @f$ cut, then if @f$ lb_{uv}\geq q @f$ the set 
 * @f$ \{u,v\} @f$ is shrinkable.
 * 
 * The actual tests that we perform (for every edge) are the following:
 * -# If @f$ w(\delta(u)) < @f$ #dbl_EGalgMCgraph_t::cut_val, update the minimum
 * cut value and set.
 * -# If @f$ w_{uv} \geq \min\{w(\delta(u)),w(\delta(v))\}/2 @f$ then we can 
 * safely shrink edge @f$ uv @f$.
 * -# If we have a triangle @f$ uv,\quad vw,\quad wu  @f$, with 
 * @f$ w_{uv} + w_{vw} \geq w(\delta(v))/2 @f$ and  
 * @f$ w_{uw} + w_{vw} \geq w(\delta(w))/2 @f$ then we can safely shrink edge
 * @f$ wv @f$.
 * -# Compute lower bound on the cut that separates the endpoints of the
 * current edge as :
 * @f[ lb_{uv}=w_{uv}+\sum\limits_{w\in N(u)\cap N(v)}\min\{w_{uw},w_{vw}\} @f]
 * If  @f$ lb_{uv} \geq  @f$ #dbl_EGalgMCgraph_t::cut_val , then we can shrink the edge  @f$ uv @f$.
 * -# Consider the edge @f$ uv @f$ and two common neighbours @f$ x,y @f$. If  
 * @f$ w_{ux} + w_{uy} + w_{uv} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{vx} + w_{vy} + w_{vu} \geq w(\delta(v))/2 @f$ and at least one of 
 * @f$ w_{uv} + w_{uy} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{uv} + w_{vx} \geq w(\delta(v))/2 @f$ and at least one of 
 * @f$ w_{uv} + w_{ux} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{uv} + w_{vy} \geq w(\delta(v))/2 @f$ then we can safely shrink edge
 * @f$ uv @f$.
 *
 * We make thiese tests in order, i.e. first we perform all level 1 tests,
 * then level2, and so on, and whenever two nodes are Identify (shrinked) we
 * set the level of the node to 1 (i.e. in the next test we will test the
 * first condition). This is done using an array of (5) lists, where all nodes
 * are distributed. Originally all nodes should be in the first lists (i.e.
 * all nodes should be tested to improve the current best cut by themselves).
 * */
int dbl_EGalgMCidentifyPRedges (dbl_EGalgMCgraph_t * const G,
														dbl_EGalgMCcbk_t * const cb,
														const unsigned int max_lvl);

/* ========================================================================= */
/** @brief Compute a minimum cut on the given graph. 
 * @param max_lvl set a limit on wich tests to perform during the
 * Padberg-Rinaldy shrinking step. for example, if set to
 * 1, only the first and second tests will be carried out.
 * @param G graph over wich we are working. 
 * @param cb call back structure to use (if set to NULL it is not used).
 * @return zero on success, non-zero otherwise. 
 *
 * This function takes as input a graph, and perform the minimum cut algorithm
 * as described in the paper "An Efficient 
 * Algorithm For The Minimum Capacity Cut Problem", Mathematical Programming
 * 47 (1990) pages 19-36. 
 *
 * Note that the graph should have all fields properly initialized.
 * */
int dbl_EGalgMC (dbl_EGalgMCgraph_t * const G,
						 dbl_EGalgMCcbk_t * const cb,
						 const unsigned int max_lvl);

/* ========================================================================= */
/** @} 
 * end dbl_eg_min_cut.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef dbl___EG_NUMUTIL_H__
#define dbl___EG_NUMUTIL_H__

/* ========================================================================= */
/** @defgroup EGlpNumUtil General Number Utilities
 * Here we put some utilities common for different number types but thaat we
 * want to implement as templates, like permutation sorting, inner product of
 * vectors, and so-on..
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2007-10-08
 *  					- Separate template file and independet file into eg_nummacros.h
 *  					- Move EGabs, EGswap, EGmin and EGmax to this file
 *  - 2005-10-31
 *  					- First implementation.
 * */
/** @{*/
/** @file
 * @brief This file provide the user interface and function definitions for
 * general number utilities.
 * */
/* ========================================================================= */
/** @brief compute the inner product of two arrays.
 * @param arr1 first array.
 * @param arr2 second array.
 * @param length number of entries to consider in both arrays, from zero to
 * length - 1.
 * @param rop where to store the result.
 * */
#define dbl_EGlpNumInnProd(__rop,__arr1,__arr2,__length) dbl___EGlpNumInnProd((&(__rop)),__arr1,__arr2,__length)
/* ========================================================================= */
/** @brief internal version, this is done to avoid using stdc99 and rely on
 * more basic stdc89 */
void dbl___EGlpNumInnProd(double*rop,double*const arr1,double*const arr2, const size_t length);
/* ========================================================================= */
/** @brief Sort (in increasing order) a sub-set of entries in an array using 
 * quicksort, by permutating the order of the elements in the subset rather 
 * than in the whole original array.
 * @param sz length of the permutation array.
 * @param perm array of indices of elements that we want to sort.
 * @param elem array (of length at least max(perm[k]:k=0,...,sz-1)) containing
 * the elements to be sorted.
 * @note The array of elements is not changed by this function.
 * @note This code is based in concorde's implementation of
 * permutation-quick-sort.
 * */
void dbl_EGutilPermSort (const size_t sz,
										 int *const perm,
										 const double * const elem);

/* ========================================================================= */
/** @brief Sort (in decreasing order) a sub-set of entries in an array using 
 * quicksort, by permutating the order of the elements in the subset rather 
 * than in the whole original array.
 * @param sz length of the permutation array.
 * @param perm array of indices of elements that we want to sort.
 * @param elem array (of length at least max(perm[k]:k=0,...,sz-1)) containing
 * the elements to be sorted.
 * @note The array of elements is not changed by this function.
 * @note This code is based in concorde's implementation of
 * permutation-quick-sort.
 * */
void dbl_EGutilPermSort2 (const size_t sz,
										 int*const perm,
										 const double*const elem);

/* ========================================================================= */
/** @}*/
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgDijkstra EGalgDijkstra
 * Dijkstra implementation with 2-heaps
 * */
/** @file
 * @ingroup EGalgDijkstra */
/** @addtogroup EGalgDijkstra */
/** @{ */
/** @example dbl_eg_dijkstra.ex.c */
/* ========================================================================= */
#ifndef dbl___EG_DIJKSTRA_H
#define dbl___EG_DIJKSTRA_H
/* ========================================================================= */
/** @brief Verbosity Level */
#define dbl_DJK_VRBLVL_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define dbl_DJK_DEBUG_ 100

/* ========================================================================= */
/** @brief implement dijkstra.
 * */
int dbl_EGalgDJK (
		int32_t const nnodes,
		int32_t const nedges,
		int32_t const*const ou_d,
		int32_t const*const ou_beg,
		int32_t const*const ou_e,
		double const*const weight,
		int32_t const s,
		int32_t const nt,
		int32_t const*const t,
		int32_t*const father,
		double*const dist
		);

/* ========================================================================= */
/** @brief read from a file in .x format (as in the concorde's .x files), the
 * format is as follows:
 * nnodes nedges
 * tail_1 head_1 weight_1
 * ...    ...    ....
 * tail_nnodes head_nnodes weight_nnodes
 * comments are allowed, if they start with % or #.
 * @param input file containing the data
 * @param n where to store the number of nodes
 * @param m where to store the number of edges
 * @param edges pointer to an array where to store the edges, note that memory
 * will be allocated in (*edges)
 * @param weight pointer to the array where we will store the weights, note
 * that this array will be allocated using dbl_EGlpNumAllocArray, and should be
 * deallocated using dbl_EGlpNumFreeArray.
 * @return zero on success, non-zero otherwise 
 * */
int dbl_EGguReadXgraph(
		EGioFile_t*const input,
		int32_t*const n,
		int32_t*const m,
		int32_t**const edges,
		double**const weight);
/* ========================================================================= */
/** @} 
 * end dbl_eg_dijkstra.h */
#endif

/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef fp20___EG_DMATRIX_H__
#define fp20___EG_DMATRIX_H__

/* ========================================================================= */
/** @defgroup EGdMatrix Dense Matrices
 * Here we define a common interface for dense matrices (i.e. a structure), and
 * some common operations over dense matrices. The definition uses EGlpNum as
 * reference number type, this allow for template initializations.
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2005-10-27
 *  					- First implementation.
 * */
/** @{*/
/** @file
 * @brief This file provide the user interface and function definitions for
 * Dense Matrices.
 * */
/** @example fp20_eg_dmatrix.ex.c */
/* ========================================================================= */
/** @brief structure to hold a dense matrix, we choose a row representation
 * of the matrix, and we allow row and column permutations. All actual values 
 * in the matrix are stored in #fp20_EGdMatrix_t::matval, and the rows in
 * #fp20_EGdMatrix_t::matrow. */
typedef struct fp20_EGdMatrix_t
{
	size_t col_sz;		/**< @brief Number of columns in the matrix. */
	size_t row_sz;		/**< @brief Number of rows in the matrix */
	EGfp20_t **matrow;
										/**< @brief Array of size #fp20_EGdMatrix_t::row_sz containing 
												 all rows of the matrix */
	EGfp20_t *matval;/**< @brief Values for all entries */
	int *col_ord;			/**< @brief Array of size at least #fp20_EGdMatrix_t::col_sz 
												 containing the order ammong all columns i.e. it is a 
												 permutation of {0,....,col_sz-1} which is how the 
												 matrix is treated internally */
	int *row_ord;			/**< @brief Array of size at least #fp20_EGdMatrix_t::row_sz 
												 containing the order ammong all rows, i.e. it is a 
												 permutation of {0,...,row_sz-1} which is how the 
												 matrix is treated internally */
}
fp20_EGdMatrix_t;

/* ========================================================================= */
/** @brief Initialize (as a dense matrix of dimension 0x0) an #fp20_EGdMatrix_t
 * structure.
 * @param __dmatrix dense matrix structure pointer.
 * */
#define fp20_EGdMatrixInit(__dmatrix) memset(__dmatrix,0,sizeof(fp20_EGdMatrix_t))

/* ========================================================================= */
/** @brief Clear a dense matrix structure, i.e. free all internally allocated
 * data of the structure. Note that no further use of the structure can be made
 * unless it is re-initialized and set to a suitable size.
 * @param __dmatrix dense matrix structure pointer.
 * */
#define fp20_EGdMatrixClear(__dmatrix) do{\
	fp20_EGdMatrix_t*const __EGdm = (__dmatrix);\
	fp20_EGlpNumFreeArray(__EGdm->matval);\
	EGfree(__EGdm->matrow);\
	int_EGlpNumFreeArray(__EGdm->col_ord);\
	int_EGlpNumFreeArray(__EGdm->row_ord);} while(0)

/* ========================================================================= */
/** @brief Set new dimensions for a dense matrix structure.
 * @param __dmatrix dense matrix structure pointer.
 * @param __nnewrows number of rows in the matrix.
 * @param __nnewcols number of columns in the matrix.
 * @note Take care that the values stored in the matrix are not initialized to
 * any particular number. Also the ordering (for both column and row) is reset
 * to the standard ordering 0,....,n.
 * */
#define fp20_EGdMatrixSetDimension(__dmatrix,__nnewrows,__nnewcols) do{\
	fp20_EGdMatrix_t*const __EGdm = (__dmatrix);\
	register int __EGdmi;\
	__EGdm->col_sz = (__nnewcols);\
	__EGdm->row_sz = (__nnewrows);\
	fp20_EGlpNumReallocArray(&(__EGdm->matval),__EGdm->col_sz * __EGdm->row_sz);\
	EGrealloc(__EGdm->matrow,__EGdm->row_sz * sizeof(EGfp20_t*));\
	int_EGlpNumReallocArray(&(__EGdm->col_ord),__EGdm->col_sz);\
	int_EGlpNumReallocArray(&(__EGdm->row_ord),__EGdm->row_sz);\
	__EGdmi = (int)(__EGdm->col_sz);\
	while(__EGdmi--) __EGdm->col_ord[__EGdmi] = __EGdmi;\
	__EGdmi = (int)(__EGdm->row_sz);\
	while(__EGdmi--) \
		__EGdm->matrow[__EGdmi] = __EGdm->matval + ((size_t)(__EGdmi) * __EGdm->col_sz);\
	__EGdmi = (int)(__EGdm->row_sz);\
	while(__EGdmi--) __EGdm->row_ord[__EGdmi] = __EGdmi;} while(0)

/* ========================================================================= */
/** @brief Display a given #fp20_EGdMatrix_t structure contents.
 * @param __dmatrix dense matrix structure pointer.
 * @param __nat_order if set to one, display the matrix using the natural 
 * internal order, i.e. we discard the order of columns and rows as defined in
 * #fp20_EGdMatrix_t::col_ord and #fp20_EGdMatrix_t::row_ord. Otherwise, use such orders.
 * @param __ofile pointer to a FILE structure where we want the output to be
 * printed.
 * */
#define fp20_EGdMatrixDisplay(__dmatrix,__nat_order,__ofile) do{\
	fp20_EGdMatrix_t*const __EGdm = (__dmatrix);\
	char* __EGdmstr = 0;\
	size_t __EGdmi, __EGdmj;\
	fprintf(__ofile,"Matrix %p\nDimensions: %zd rows, %zd columns\n", (void*)__EGdm, __EGdm->row_sz, __EGdm->col_sz);\
	if(__nat_order){\
		for(__EGdmi = 0 ; __EGdmi < __EGdm->row_sz ; __EGdmi++){\
			for(__EGdmj = 0 ; __EGdmj < __EGdm->col_sz ; __EGdmj++){\
				__EGdmstr = fp20_EGlpNumGetStr(__EGdm->matrow[__EGdmi][__EGdmj]);\
				fprintf(__ofile,"%10s ", __EGdmstr);\
				EGfree(__EGdmstr);\
			}\
			fprintf(__ofile,"\n");}\
	} else {\
		for(__EGdmi = 0 ; __EGdmi < __EGdm->row_sz ; __EGdmi++){\
			for(__EGdmj = 0 ; __EGdmj < __EGdm->col_sz ; __EGdmj++){\
				__EGdmstr = fp20_EGlpNumGetStr(__EGdm->matrow[__EGdm->row_ord[__EGdmi]][__EGdm->col_ord[__EGdmj]]);\
				fprintf(__ofile,"%10s ", __EGdmstr);\
				EGfree(__EGdmstr);\
			}\
			fprintf(__ofile,"\n");}\
	}} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set rows 
 * '__dest' to '__dest' + '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in row '__dest', and note that rows '__orig' and '__dest' should be different.
 * This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the row whose multiple will be added to the '__dest'
 * row.
 * @param '__dest' row to be replaced by '__dest' + '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' row.
 * @note The index of the row are taken as internal index, i.e. if we give row
 * 'k' we will use the row stored in #fp20_EGdMatrix_t::matrow[k], wich does not
 * mean that we will access the k-th row in the matrix (wich would need to use
 * as index the value #fp20_EGdMatrix_t::row_ord[k] instead). Note that we don't
 * test wether the given multiple is zero or not. we always perform the
 * operation.
 * */
#define fp20_EGdMatrixAddRowMultiple(__dmatrix,__dest,__orig,__num) do{\
	fp20_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (size_t)(__dest);\
	const size_t __EGori = (size_t)(__orig);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) \
		fp20_EGlpNumAddInnProdTo(__EGdm->matrow[__EGdest][__EGdmj],\
												__EGdm->matrow[__EGori][__EGdmj],__num);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set rows 
 * '__dest' to '__dest' - '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in row '__dest', and note that rows '__orig' and '__dest' should be different.
 * This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the row whose multiple will be added to the '__dest'
 * row.
 * @param '__dest' row to be replaced by '__dest' - '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' row.
 * @note The index of the row are taken as internal index, i.e. if we give row
 * 'k' we will use the row stored in #fp20_EGdMatrix_t::matrow[k], wich does not
 * mean that we will access the k-th row in the matrix (wich would need to use
 * as index the value #fp20_EGdMatrix_t::row_ord[k] instead). Note that we don't
 * test wether the given multiple is zero or not. we always perform the
 * operation.
 * */
#define fp20_EGdMatrixSubRowMultiple(__dmatrix,__dest,__orig,__num) do{\
	fp20_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (__dest);\
	const size_t __EGori = (__orig);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) \
		fp20_EGlpNumSubInnProdTo(__EGdm->matrow[__EGdest][__EGdmj],\
												__EGdm->matrow[__EGori][__EGdmj],__num);\
	} while(0)
/* ========================================================================= */
/** @brief Given a number and a row, multiply the complete row by the given
 * number. Note that the number MUST_NOT be stored in the row being multiplied,
 * this is because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param row_ind index of the row being multiplied, note that we will multiply
 * the row stored in #fp20_EGdMatrix_t::matrow[row_ind], wich is different to say
 * that we multiply the row in the row_ind-th position in the row ordering (to
 * do that, then row_ind should be #fp20_EGdMatrix_t::row_ord[k]).
 * @param multiple constant to be multiply to the row.
 * */
#define fp20_EGdMatrixMultiplyRow(__dmatrix,row_ind,multiple) do{\
	fp20_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdmi = (row_ind);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) fp20_EGlpNumMultTo(__EGdm->matrow[__EGdmi][__EGdmj],multiple);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set columns 
 * '__dest' to '__dest' + '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in column '__dest', and note that columns '__orig' and '__dest' should be 
 * different. This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the column whose multiple will be added to the '__dest'
 * column.
 * @param '__dest' column to be replaced by '__dest' + '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' column.
 * @note The index of the column are taken as internal index, i.e. if we give 
 * column 'k' we will use the column stored in #fp20_EGdMatrix_t::matrow[*][k], 
 * wich does not mean that we will access the k-th column in the matrix (wich
 * would need to use as index the value #fp20_EGdMatrix_t::row_ord[k] instead). 
 * Note that we don't test wether the given multiple is zero or not. we 
 * always perform the operation.
 * */
#define fp20_EGdMatrixAddColMultiple(__dmatrix,__dest,__orig,__num) do{\
	fp20_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (__dest);\
	const size_t __EGori = (__orig);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) \
		fp20_EGlpNumAddInnProdTo(__EGdm->matrow[__EGdmj][__EGdest],\
												__EGdm->matrow[__EGdmj][__EGori],__num);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set columns 
 * '__dest' to '__dest' - '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in column '__dest', and note that columns '__orig' and '__dest' should be 
 * different. This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the column whose multiple will be added to the '__dest'
 * column.
 * @param '__dest' column to be replaced by '__dest' - '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' column.
 * @note The index of the column are taken as internal index, i.e. if we give 
 * column 'k' we will use the column stored in #fp20_EGdMatrix_t::matrow[*][k], 
 * wich does not mean that we will access the k-th column in the matrix (wich 
 * would need to use as index the value #fp20_EGdMatrix_t::col_ord[k] instead). 
 * Note that we don't test wether the given multiple is zero or not. we 
 * always perform the operation.
 * */
#define fp20_EGdMatrixSubColMultiple(__dmatrix,__dest,__orig,__num) do{\
	fp20_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (size_t)(__dest);\
	const size_t __EGori = (size_t)(__orig);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) \
		fp20_EGlpNumSubInnProdTo(__EGdm->matrow[__EGdmj][__EGdest],\
												__EGdm->matrow[__EGdmj][__EGori],__num);\
	} while(0)
/* ========================================================================= */
/** @brief Given a number and a column, multiply the complete column by the 
 * given number. Note that the number MUST_NOT be stored in the column being 
 * multiplied, this is because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param __colind index of the column being multiplied, note that we will 
 * multiply the column stored in #fp20_EGdMatrix_t::matrow[*][__colind], wich is 
 * different to say that we multiply the column in the __colind-th position in
 * the column ordering (to do that, then __colind should be 
 * #fp20_EGdMatrix_t::col_ord[k]).
 * @param __mult constant to be multiply to the column.
 * */
#define fp20_EGdMatrixMultiplyCol(__dmatrix,__colind,__mult) do{\
	fp20_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdmi = (__colind);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) fp20_EGlpNumMultTo(__EGdm->matrow[__EGdmj][__EGdmi],__mult);\
	} while(0)


/* ========================================================================= */
/** @brief This function performs gaussian elimination to the given matrix,
 * depending on the given options it may do row/columns permutations allong the
 * way to improve numerical stabillity.
 * @param __dmatrix dense matrix structure pointer.
 * @param do_col_perm if set to one, the try columns permutation to improve
 * numericall stabillity, otherwise, not do column permutations at all.
 * @param do_row_perm if set to one, try row permutations to improve numericall
 * stabillity, otherwise, not do row permutations at all.
 * @param status pointer to where return an status, if the procedure finish all
 * the way (i.e. the matrix is full rank), then we return #EG_ALGSTAT_SUCCESS,
 * if the matrix is found to be partial rank, the status is
 * #EG_ALGSTAT_PARTIAL, otherwise, we return #EG_ALGSTAT_NUMERROR, wich means
 * that we stoped because a zero pivot was found (after checking for allowed
 * row/collumns permmutations).
 * @param rank where to return the (proven) rank of the matrix. This number is
 * accurate if the status is #EG_ALGSTAT_SUCCESS, or #EG_ALGSTAT_PARTIAL, but
 * is just a lower bound if the status is #EG_ALGSTAT_NUMERROR
 * @param zero_tol What is the threshold for a value to be considered zero.
 * @return if no error happen, we return zero, otherwise a non-zero valued is
 * returned. Note that the algorithm status is independent of the return value,
 * non zero values araise only if an error happen during execution, wich is
 * different to say that the algorithm didn't finish correctly. */
int fp20_EGdMatrixGaussianElimination (fp20_EGdMatrix_t * const __dmatrix,
																	const unsigned do_col_perm,
																	const unsigned do_row_perm,
																	unsigned *const rank,
																	const EGfp20_t zero_tol,
																	int *const status);

/* ========================================================================= */
/** @}*/
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef fp20___EG_DBASIS_REDUCTION__
#define fp20___EG_DBASIS_REDUCTION__
/* ========================================================================= */
/** @defgroup EGdBasisRed LLL Basis Reduction
 * Here we define a common interface for dense matrices (i.e. a structure), and
 * some common operations over dense matrices. The definition uses EGlpNum as
 * reference number type, this allow for template initializations.
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2005-10-28
 *  					- First implementation.
 * */
/**  @{ */
/** @file
 * @brief This file provide the user interface and function definitions for
 * the so-called LLL Basis Reduction Algorithm. This algorithm was first
 * presented in the paper "Factoring polynomials with rational coefficients",
 * Mathematische Annalen 261 (1981), p515-534. and has been extensivelly
 * studied elsewere. for more details just Google-it.
 * */
/** @example fp20_eg_dmatrix.ex.c */
/* ========================================================================= */
/** @brief verbosity level */
#define fp20_EG_DBSRED_VERBOSE 0

/* ========================================================================= */
/** @name Profiling structures and functions for the basis reduction algorithm.
 * */
/* @{ */
/* ========================================================================= */
/** @brief where to hold the profile information */
extern uintmax_t fp20_EGdBsRedStats[10];

/* ========================================================================= */
/** @brief where we store the number of calls to #fp20_EGdBsRed */
#define fp20_EG_BSRED_CALLS 0

/* ========================================================================= */
/** @brief where we store the total number of size reductions performed in 
 * #fp20_EGdBsRed */
#define fp20_EG_BSRED_SZRED 1

/* ========================================================================= */
/** @brief where we store the total number of interchanges performed in 
 * #fp20_EGdBsRed */
#define fp20_EG_BSRED_INTR 2

/* ========================================================================= */
/** @brief where we store the total number of innermost loops performed in 
 * #fp20_EGdBsRed */
#define fp20_EG_BSRED_ITT 3

/* ========================================================================= */
/** @brief Print into the given file stream, the current statistics related
 * to the #fp20_EGdBsRed algorithm. And reset all counters to zero.
 * @param __ofile where we want to print the profile information. */
#define fp20_EGdBsRedProfile(__ofile) do{\
	fprintf(__ofile,"LLL Basis Reduction Statistics:\n");\
	fprintf(__ofile,"\tNumber Calls    : %ju\n", fp20_EGdBsRedStats[fp20_EG_BSRED_CALLS]);\
	fprintf(__ofile,"\tLoops           : %ju\n", fp20_EGdBsRedStats[fp20_EG_BSRED_ITT]);\
	fprintf(__ofile,"\tSize Reductions : %ju\n", fp20_EGdBsRedStats[fp20_EG_BSRED_SZRED]);\
	fprintf(__ofile,"\tInterchanges    : %ju\n", fp20_EGdBsRedStats[fp20_EG_BSRED_INTR]);\
	memset(fp20_EGdBsRedStats,0,sizeof(fp20_EGdBsRedStats));} while(0)

/* @} */

/* ========================================================================= */
/** @brief Value used in condition two of the LLL algorithm, remember that this
 * number should be between \f$(1/4,1)\f$. By default we choose \f$\lambda =
 * \frac{2^{20}-1}{2^{20}} \approx .99999904632568359375 \f$. */
#define fp20_EG_DBSRED_ALPHA 0x7ffffp-20

/* ========================================================================= */
/** @brief structure to hold all necesary data to perform the LLL's basis
 * reduction algorithm. */
typedef struct fp20_EGdBsRed_t
{
	size_t dim;				/**< @brief Number of elements in the basis */
	size_t length;		/**< @brief Length of the vectors in the basis, note that
												 it should be that length >= dim */
	size_t basis_sz;	/**< @brief Actual length of the #fp20_EGdBsRed_t::basis 
												 array */
	EGfp20_t **basis;/**< @brief array of pointers to arrays containing the 
												 vector basis in extended (including zero coef) form. 
												 The vectors themselves are considered as allocated 
												 outside. everything else is considered as internally
												 allocated. */
	fp20_EGdMatrix_t GM;		/**< @brief Here we store and compute the Gram-Schmidt 
												 needed for the LLL basis reduction algorithm */
}
fp20_EGdBsRed_t;

/* ========================================================================= */
/** @brief Initialize an #fp20_EGdBsRed_t structure, as a basis with zero elements
 * of dimension zero.
 * @param __bsred pointer to an #fp20_EGdBsRed_t structure.
 * */
#define fp20_EGdBsRedInit(__bsred) do{\
	fp20_EGdBsRed_t*const __EGdbs = (__bsred);\
	memset(__EGdbs,0,sizeof(fp20_EGdBsRed_t));\
	fp20_EGdMatrixInit(&(__EGdbs->GM));} while(0)

/* ========================================================================= */
/** @brief Free any internally allocated memory in a #fp20_EGdBsRed_t structure.
 * @param __bsred pointer to an #fp20_EGdBsRed_t structure.
 * */
#define fp20_EGdBsRedClear(__bsred) do{\
	fp20_EGdBsRed_t*const __EGdbs = (__bsred);\
	if(__EGdbs->basis) EGfree(__EGdbs->basis);\
	fp20_EGdMatrixClear(&(__EGdbs->GM));} while(0)

/* ========================================================================= */
/** @brief reset an #fp20_EGdBsRed_t structure as a basis without elements (note
 * that we do not reset the length of the vectors, just the number of vectors 
 * in the basis).
 * @param __bsred pointer to an #fp20_EGdBsRed_t structure.
 * */
#define fp20_EGdBsRedReset(__bsred) ((__bsred)->dim = 0)

/* ========================================================================= */
/** @brief set the length of the vectors used in the basis for an #fp20_EGdBsRed_t
 * structure.
 * @param __bsred pointer to an #fp20_EGdBsRed_t structure.
 * @param __new_length length of the vectors in the basis.
 * */
#define fp20_EGdBsRedSetLength(__bsred,__new_length) ((__bsred)->length = (__new_length))

/* ========================================================================= */
/** @brief add a new vector to the basis.
 * @param __bsred pointer to an #fp20_EGdBsRed_t structure.
 * @param __new_elem new vector to add to the basis.
 * */
#define fp20_EGdBsRedAddElement(__bsred,__new_elem) do{\
	fp20_EGdBsRed_t*const __EGdbs = (__bsred);\
	if(__EGdbs->basis_sz <= __EGdbs->dim){\
		__EGdbs->basis_sz += 10U;\
		EGrealloc(__EGdbs->basis,sizeof(EGfp20_t*)*__EGdbs->basis_sz);}\
	__EGdbs->basis[__EGdbs->dim++] = (__new_elem);} while(0)

/* ========================================================================= */
/** @brief This function performs the so-called LLL basis reduction algorithm.
 * @param __bsred pointer to an #fp20_EGdBsRed_t structure.
 * @param status where we return the status of the algorithm, if the algorithm
 * finish with non-zero reduced elements, the status is #EG_ALGSTAT_SUCCESS. if
 * the algorithm finish with some zero reduced vector, the status is
 * #EG_ALGSTAT_PARTIAL. if the algorithm stop because of numerical problems,
 * the status is #EG_ALGSTAT_NUMERROR.
 * @param zero_tol threshold for a number to be considered as zero.
 * @param dim pointer to a number where we return the dimension of the basis
 * that the algorithm could prove before running in any numerical problem. If
 * the algorithm stop with status #EG_ALGSTAT_SUCCESS, then this number should
 * be equal to #fp20_EGdBsRed_t::dim. The vectors that we finish reducing are stored
 * in #fp20_EGdMatrix_t::row_ord[0], ... , #fp20_EGdMatrix_t::row_ord[dim], in the
 * #fp20_EGdBsRed_t::GM matrix.
 * @return zero if the algorithm finish, non-zero if an unforeseen error occure
 * during execution. 
 * @par Details:
 * The implementation that we use introduce (as an heuristic step) the sorting
 * of the original basis vectors in increasing order according to their norms,
 * this simple step reduced the total running time of the algorithm, but does
 * not improve the theoretical running time. A second detail is that we only
 * compute the Gram-Schmidth coefficients only once (at the beggining of the
 * program), and then, we only update the changed entries for both operations
 * \a size \a reduction and \a interchange. The advantage of the approach is
 * that we save most Gram-Schmidth computations and also all the recomputations
 * of the inner products of the elements currently in the basis. Again, this
 * are improvements form the practical point of view, but not in practice. The
 * dissadvantage of this approach is that we do accumulate rounding errors in
 * the Gram-Schmidth coefficients allong the way, but if all original vectors
 * coefficients where integer (and not too big), then the error should not grow
 * too much. Still this may happen if the input basis is ill conditioned.
 * */
int fp20_EGdBsRed (fp20_EGdBsRed_t * const __bsred,
							unsigned *const dim,
							const EGfp20_t zero_tol,
							int *const status);

/* ========================================================================= */
/**  @} */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGeHeap EGeHeap
 *
 * Here we define the basic interface for d-heaps as an embeded structure.
 * In this implementation the heap does not grow on the fly, meaning that it 
 * may fills-up during an add call, to avoid that, the user must call 
 * re-allocate when necesary. the heap start as a heap of size zero. 
 * This implementatioon is a minimum-heap implementatiton. Note also that the
 * internal connector array is shifted one position to the left. This is done 
 * so that the first element is in position 1, this also speed-up the 
 * computation of the parent and childrens of a given position.
 *
 * @version 0.0.1
 * @par History:
 * - 2010-09-05
 * 						- fp20_EGeHeapClear will free any internal memory (even if it was
 * 						asked for by the user).
 * - 2005-07-14
 * 						- Add fp20_EGeHeapEmpty to empty the heap (but keep its maximum
 * 							size)
 * 						- Add fp20_EGeHeapIsFull to test wether a heap is full or not.
 * - 2005-07-07
 * 						- First Implementation
 * @note 
 * This implementatiton is designed as a template using as base the types of
 * @ref EGlpNum
 * */
/** @file 
 * @ingroup EGeHeap */
/** @addtogroup EGeHeap */
/** @{ */
/** @example fp20_eg_eheap.ex.c
 * This is a simple example of the usage of heaps using @ref EGeHeap */
/* ========================================================================= */
#ifndef fp20___EG_EHEAP__
#define fp20___EG_EHEAP__
/* ========================================================================= */
/** @brief Debug level for the heap */
#ifndef fp20_EG_EHEAP_DEBUG
#define fp20_EG_EHEAP_DEBUG 1000
#endif

/* ========================================================================= */
/** @name Test macros, enabled only if debug level is high enough. */
/** @{ */
#if fp20_EG_EHEAP_DEBUG <= DEBUG
#define fp20_EGeHeapCHECK_CN(__hp2,__hcn2) EXIT(__hcn2->pos>=__hp2->sz,"Heap Connector possition %d out of range [0,%d]",__hcn2->pos,__hp2->sz)
#define fp20_EGeHeapCHECK_NF(__hp2) EXIT(__hp2->sz >= __hp2->max_sz,"Heap "#__hp2" Is full, can't add an element")
#else
#define fp20_EGeHeapCHECK_CN(__hp,__hcn) 
#define fp20_EGeHeapCHECK_NF(__hp) 
#endif
/** @} */
/* ========================================================================= */
/** @brief Structure to store the information relevant to an element in the
 * heap. */
typedef struct 
{
	EGfp20_t val;		/**< Value of this node in the heap */
	unsigned int pos;	/**< Position in the heap array for this node, if set to
												 #fp20_EG_EHEAP_POISON, then the connector is not in any 
												 heap.*/
}
fp20_EGeHeapCn_t;

/* ========================================================================= */
/** @brief Poison position for heap connector not in a heap. */
#define fp20_EG_EHEAP_POISON UINT_MAX

/* ========================================================================= */
/** @brief Initialize a heap conector structure. This function will allocate any
 * interal memory not allocated by the user, it should be called only once, or
 * after a clear function call.
 * @param __hcn conector to initialize.
 * */
#define fp20_EGeHeapCnInit(__hcn) ({fp20_EGlpNumInitVar((__hcn)->val);(__hcn)->pos = fp20_EG_EHEAP_POISON;})

/* ========================================================================= */
/** @brief Reset a heap conector to the same state as after an init call, this
 * function is provided only for completness.
 * @param __hcn conector to reset
 * */
#define fp20_EGeHeapCnReset(__hcn) ((__hcn)->pos = fp20_EG_EHEAP_POISON)

/* ========================================================================= */
/** @brief Free all internal memory used by this structured not allocated by the
 * user. This function should be called after an init call, and only once.
 * @param __hcn conector to clear.
 * */
#define fp20_EGeHeapCnClear(__hcn) fp20_EGlpNumClearVar((__hcn)->val)

/* ========================================================================= */
/** @brief Structure to hold a whole heap structure, this structure is designed
 * so that it can grow on the fly with a low cost */
typedef struct 
{
	fp20_EGeHeapCn_t **cn;
	unsigned int d;
	unsigned int sz;
	unsigned int max_sz;
}
fp20_EGeHeap_t;

/* ========================================================================= */
/** @brief Return one if the heap is full, zero otherwise.
 * @param __hp heat to check */
#define fp20_EGeHeapIsFull(__hp) ({fp20_EGeHeap_t*const __EGehp = (__hp); __EGehp->sz == __EGehp->max_sz;})

/* ========================================================================= */
/** @brief set the number of elements in hte heap to zero.
 * @param __hp heap to empty.
 * */
#define fp20_EGeHeapEmpty(__hp) ((__hp)->sz = 0)

/* ========================================================================= */
/** @brief Initialize a heap as an empty heap (with no space for conectors).
 * @param __hp heap to initialize.
 * */
#define fp20_EGeHeapInit(__hp) (*(__hp) = (fp20_EGeHeap_t){0,0,0,0})

/* ========================================================================= */
/** @brief Reset the given heap as an empty heap (just as returned by the init
 * call.
 * @param __hp heap to reset 
 * */
#define fp20_EGeHepReset(__hp) fp20_EGeHeapResize(__hp,0)

/* ========================================================================= */
/** @brief Clear a heap structure, and free any internal memory (not allocated
 * by the user).
 * @param __hp heap to clear.
 * */
#define fp20_EGeHeapClear(__hp) fp20_EGeHeapResize(__hp,0)

/* ========================================================================= */
/** @brief get the minimum value in the heap.
 * @param __hp heap where we are working.
 * @param number where to store the result
 * @return zero on success, non-zero otherwise.
 * */
#define fp20_EGeHeapGetMinVal(__hp,number) ({\
	fp20_EGeHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? (fp20_EGlpNumCopy(number,__EGehp->cn[0]->val),0):1;})

/* ========================================================================= */
/** @brief get the minimum conector in the heap, if the heap is empty, return
 * NULL.
 * @param __hp eap where we are working.
 * @return pointer to the minimum element in the heap.
 * */
#define fp20_EGeHeapGetMin(__hp) ({\
	fp20_EGeHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? __EGehp->cn[0] : 0;})

/* ========================================================================= */
/** @brief resize the heap cn array to the given size, if the new size is zero,
 * it is equivalent to free the internal memory, and left the heap as an empty
 * heap with zero space.
 * @param __hp heap where we are working.
 * @param new_sz new size for the  cn array .
 * */
#define fp20_EGeHeapResize(__hp,new_sz) ({\
	fp20_EGeHeap_t*const __EGehp = (__hp);\
	const size_t __EGehp_nsz = (size_t)(new_sz);\
	__EGehp->cn = EGrealloc((__EGehp->cn), __EGehp_nsz * sizeof(fp20_EGeHeapCn_t*));\
	__EGehp->max_sz = (unsigned int)(__EGehp_nsz);})

/* ========================================================================= */
/** @brief return the index of the father of the given index.
 * @param __d breadth of the heap.
 * @param __id position in the array to wich we want to compute it's father.
 * */
#define fp20_EGeHeapFatherId(__d,__id) ((__id)?(((__id)-1)/(__d)):0)

/* ========================================================================= */
/** @brief move an element in the heap up in the heap (position 0 is the top,
 * this kind of move is neded whenever we decrease the value in a heap element).
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * */
#define fp20_EGeHeapSiftUp(__hp,__hcn) ({\
	fp20_EGeHeap_t*const __EGehp = (__hp);\
	fp20_EGeHeapCn_t*const __EGecn = (__hcn);\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfpos = fp20_EGeHeapFatherId(__EGehp->d,__EGcpos);\
	fp20_EGeHeapCn_t*__EGfcn = __EGehp->cn[__EGfpos];\
	fp20_EGeHeapCHECK_CN(__EHehp,__EGecn);\
	while(__EGcpos && \
				fp20_EGlpNumIsLess(__EGecn->val,__EGfcn->val))\
	{\
		__EGfcn->pos = __EGcpos;\
		__EGehp->cn[__EGcpos] = __EGfcn;\
		__EGcpos = __EGfpos;\
		__EGfpos = fp20_EGeHeapFatherId(__EGehp->d,__EGcpos);\
		__EGfcn = __EGehp->cn[__EGfpos];\
	}\
	__EGecn->pos = __EGcpos;\
	__EGehp->cn[__EGcpos] = __EGecn;\
	0;})

/* ========================================================================= */
/** @brief Add an element to the heap
 * @param __hp heap where to add the element.
 * @param __hcn element to be added.
 * @return zero on success, non-zero otherwise.
 * */
#define fp20_EGeHeapAdd(__hp,__hcn) ({\
	fp20_EGeHeap_t*const __EGlhp = (__hp);\
	fp20_EGeHeapCn_t*const __EGlcn = (__hcn);\
	fp20_EGeHeapCHECK_NF(__EGlhp);\
	__EGlcn->pos = __EGlhp->sz, \
	__EGlhp->cn[__EGlhp->sz] = __EGlcn;\
	__EGlhp->sz +=1, \
	fp20_EGeHeapSiftUp(__EGlhp,__EGlcn), 0;})

/* ========================================================================= */
/** @brief Give the first child for a given position.
 * @param __id position that we want to get the first child.
 * @param __d breath of the heap. */
#define fp20_EGeHeapFirstChildId(__d,__id) ((__d)*(__id)+1)

/* ========================================================================= */
/** @brief Move an element down in the heap (position 0 is the
 * top), this kind of operation is needed whenever we increase the value in a
 * heap element.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define fp20_EGeHeapSiftDown(__hp,__hcn) ({\
	fp20_EGeHeap_t*const __EGehp = (__hp);\
	fp20_EGeHeapCn_t*const __EGecn = (__hcn);\
	const unsigned int __EGhsz = __EGehp->sz;\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfchd = fp20_EGeHeapFirstChildId(__EGehp->d,__EGcpos);\
	unsigned int __EGlchd = __EGfchd + __EGehp->d;\
	fp20_EGeHeapCn_t*__EGcchd = 0;\
	register unsigned int __EGehi = 0;\
	fp20_EGeHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGfchd < __EGhsz)\
	{\
		/* detect the minimum child */\
		__EGcchd = __EGehp->cn[__EGfchd];\
		for(__EGehi = __EGlchd > __EGhsz ? __EGhsz-1 : __EGlchd-1 ;\
			__EGehi > __EGfchd ; __EGehi--)\
			if(fp20_EGlpNumIsLess(__EGehp->cn[__EGehi]->val,__EGcchd->val))\
				__EGcchd = __EGehp->cn[__EGehi];\
		/* if the minimum child is less than the current position, move the minimum\
		 * child to the position of the current element */\
		if(fp20_EGlpNumIsLess(__EGcchd->val,__EGecn->val))\
		{\
			__EGfchd = __EGcchd->pos;\
			__EGcchd->pos = __EGcpos;\
			__EGehp->cn[__EGcpos] = __EGcchd;\
			__EGecn->pos = __EGcpos = __EGfchd;\
			__EGehp->cn[__EGcpos] = __EGecn;\
			__EGfchd = fp20_EGeHeapFirstChildId(__EGehp->d,__EGcpos);\
			__EGlchd = __EGfchd + __EGehp->d;\
		}\
		/* else we exit the main loop */\
		else __EGfchd = UINT_MAX;\
	}\
	0;})

/* ========================================================================= */
/** @brief Change the value of an element in the heap.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap that we are going to change it's value.
 * @param __new_val new value for the element.
 * @return zero on success, non-zero otherwise.
 * */
#define fp20_EGeHeapChangeVal(__hp,__hcn,__new_val) ({\
	(fp20_EGlpNumIsLess(__new_val,(__hcn)->val)) ? (fp20_EGlpNumCopy((__hcn)->val,__new_val),fp20_EGeHeapSiftUp(__hp,__hcn)) : (fp20_EGlpNumCopy((__hcn)->val,__new_val),fp20_EGeHeapSiftDown(__hp,__hcn));})

/* ========================================================================= */
/** @brief Eliminate an element from the heap, note that the position stored in
 * the eliminated element is reset to zero.
 * @param __hp heap where we are working.
 * @param __hcn element to eliminate from the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define fp20_EGeHeapDel(__hp,__hcn) ({\
	fp20_EGeHeap_t*const __EGlhp = (__hp);\
	fp20_EGeHeapCn_t*const __EGlhpcn = (__hcn);\
	unsigned int const __EGlcn = __EGlhpcn->pos;\
	unsigned int const __EGlhsz = __EGlhp->sz - 1;\
	__EGlhpcn->pos = fp20_EG_EHEAP_POISON;\
	__EGlhp->sz = __EGlhsz;\
	if(__EGlhsz && __EGlhsz != __EGlcn){\
		__EGlhp->cn[__EGlcn] = __EGlhp->cn[__EGlhp->sz];\
		__EGlhp->cn[__EGlcn]->pos = __EGlcn;\
		fp20_EGeHeapSiftDown(__EGlhp,__EGlhp->cn[__EGlcn]);}\
	__EGlhp->cn[__EGlhp->sz] = 0;})

/* ========================================================================= */
/** @brief Check the integrity of the given heap.
 * @param __hp heap to check.
 * @return zero on success, non-zero otherwise.
 * */
#if fp20_EG_EHEAP_DEBUG <= DEBUG
#define fp20_EGeHeapCheck(__hp) ({\
	fp20_EGeHeap_t*const __EGehp = (__hp);\
	register unsigned int __EGehi = __EGehp->sz;\
	if(__EGehi)\
		while(--__EGehi)\
			if(__EGehp->cn[__EGehi]->pos != __EGehi || fp20_EGlpNumIsLess( __EGehp->cn[\
				 __EGehi]->val,__EGehp->cn[fp20_EGeHeapFatherId(__EGehp->d,__EGehi)]->val))\
			{\
				MESSAGE(fp20_EG_EHEAP_DEBUG,"Element %u is wrong, pos %u val [%lf,%lf]"\
							 ,__EGehi, __EGehp->cn[__EGehi]->pos, \
							 fp20_EGlpNumToLf(__EGehp->cn[__EGehi]->val), \
							 fp20_EGlpNumToLf(__EGehp->cn[fp20_EGeHeapFatherId(__EGehp->d,__EGehi)]->val));\
				break;\
			}\
	__EGehi;})
#else
#define fp20_EGeHeapCheck(__hp) 0
#endif

/* ========================================================================= */
/** @brief set the breath of the heap, this function must be called only when
 * the heap is empty.
 * @param __hp heap to set breath.
 * @param __width new with for the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define fp20_EGeHeapChangeD(__hp,__width) ({\
	fp20_EGeHeap_t*const __EGehp = (__hp);\
	EXIT((__width)<2,"Width should be at least 2 for heaps");\
	__EGehp->sz ? 1 : (__EGehp->d = (__width), 0);})

/* ========================================================================= */
/** @} */
/* end of fp20_eg_eheap.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGeKHeap EGeKHeap
 *
 * Here we define the basic interface for d-heaps with an array of values with
 * the lexicographic order for vectors as an embeded structure.
 * In this implementation the heap does not grow on the fly, meaning that it 
 * may fill-up during an add call, to avoid that, the user must call 
 * re-allocate when necesary. the heap start as a heap of size zero. 
 * This implementatioon is a minimum-heap implementatiton. Note also that the
 * internal connector array is shifted one position to the left. This is done 
 * so that the first element is in position 1, this also speed-up the 
 * computation of the parent and childrens of a given position.
 *
 * @version 0.0.1
 * @par History:
 * - 2010-09-05
 * 						- Change implementation of fp20_EGeKHeapClear to free all internal
 * 						memory, including the one asked for the user during a
 * 						fp20_EGeKHeapResize call.
 * - 2008-07-30
 * 						- First implementation
 * @note 
 * This implementatiton is designed as a template using as base the types of
 * @ref EGlpNum
 * */
/** @file 
 * @ingroup EGeKHeap */
/** @addtogroup EGeKHeap */
/** @{ */
/** @example fp20_eg_ekheap.ex.c
 * This is a simple example of the usage of heaps using @ref EGeKHeap */
/* ========================================================================= */
#ifndef fp20___EG_EKHEAP__
#define fp20___EG_EKHEAP__
/* ========================================================================= */
/** @brief Debug level for the heap */
#ifndef fp20_EG_EKHEAP_DEBUG
#define fp20_EG_EKHEAP_DEBUG 100
#endif

/* ========================================================================= */
/** @name Test macros, enabled only if debug level is high enough. */
/** @{ */
#if fp20_EG_EKHEAP_DEBUG <= DEBUG
#define fp20_EGeKHeapCHECK_CN(__hp2,__hcn2) EXIT(__hcn2->pos>=__hp2->sz,"Heap Connector possition %d out of range [0,%d]",__hcn2->pos,__hp2->sz)
#define fp20_EGeKHeapCHECK_NF(__hp2) EXIT(__hp2->sz >= __hp2->max_sz,"Heap "#__hp2" Is full, can't add an element")
#else
#define fp20_EGeKHeapCHECK_CN(__hp,__hcn) 
#define fp20_EGeKHeapCHECK_NF(__hp) 
#endif
/** @} */
/* ========================================================================= */
/** @brief number of maximum entries in the vector values */
#ifndef fp20_EG_EKHEAP_ENTRY
#define fp20_EG_EKHEAP_ENTRY 3
#endif
/* ========================================================================= */
/** @brief Structure to store the information relevant to an element in the
 * heap. */
typedef struct
{
	EGfp20_t val[fp20_EG_EKHEAP_ENTRY];/**< Value of this node in the heap */
	unsigned int pos;	/**< Position in the heap array for this node, if set to
												 #fp20_EG_EKHEAP_POISON, then the connector is not in any 
												 heap.*/
}
fp20_EGeKHeapCn_t;

/* ========================================================================= */
/** @brief Poison position for heap connector not in a heap. */
#define fp20_EG_EKHEAP_POISON UINT_MAX

/* ========================================================================= */
/** @brief Initialize a heap conector structure. This function will allocate any
 * interal memory not allocated by the user, it should be called only once, or
 * after a clear function call.
 * @param __hcn conector to initialize.
 * */
#define fp20_EGeKHeapCnInit(__hcn) do{\
	fp20_EGeKHeapCn_t*const __EKHcn = (__hcn);\
	int __EKHi = fp20_EG_EKHEAP_ENTRY;\
	memset(__EKHcn,0,sizeof(fp20_EGeKHeapCn_t));\
	for( ; __EKHi-- ; ){fp20_EGlpNumInitVar(__EKHcn->val[__EKHi]);}\
	__EKHcn->pos = fp20_EG_EKHEAP_POISON;}while(0)

/* ========================================================================= */
/** @brief Reset a heap conector to the same state as after an init call, this
 * function is provided only for completness.
 * @param __hcn conector to reset
 * */
#define fp20_EGeKHeapCnReset(__hcn) ((__hcn)->pos = fp20_EG_EKHEAP_POISON)

/* ========================================================================= */
/** @brief Free all internal memory used by this structured not allocated by the
 * user. This function should be called after an init call, and only once.
 * @param __hcn conector to clear.
 * */
#define fp20_EGeKHeapCnClear(__hcn) do{\
	fp20_EGeKHeapCn_t*const __EKHcn = (__hcn);\
	int __EKHi = fp20_EG_EKHEAP_ENTRY;\
	for( ; __EKHi-- ; ){fp20_EGlpNumClearVar(__EKHcn->val[__EKHi]);}}while(0)

/* ========================================================================= */
/** @brief Structure to hold a whole heap structure, this structure is designed
 * so that it can grow on the fly with a low cost */
typedef struct
{
	fp20_EGeKHeapCn_t **cn;
	unsigned int d;
	unsigned int sz;
	unsigned int max_sz;
}
fp20_EGeKHeap_t;

/* ========================================================================= */
/** @brief Return one if the heap is full, zero otherwise.
 * @param __hp heat to check */
#define fp20_EGeKHeapIsFull(__hp) ({fp20_EGeKHeap_t*const __EGekhp = (__hp); __EGekhp->sz == __EGekhp->max_sz;})

/* ========================================================================= */
/** @brief set the number of elements in hte heap to zero.
 * @param __hp heap to empty.
 * */
#define fp20_EGeKHeapEmpty(__hp) ((__hp)->sz = 0)

/* ========================================================================= */
/** @brief Initialize a heap as an empty heap (with no space for conectors).
 * @param __hp heap to initialize.
 * */
#define fp20_EGeKHeapInit(__hp) (*(__hp) = (fp20_EGeKHeap_t){0,0,0,0})

/* ========================================================================= */
/** @brief Reset the given heap as an empty heap (just as returned by the init
 * call.
 * @param __hp heap to reset 
 * */
#define fp20_EGeKHepReset(__hp) fp20_EGeKHeapResize(__hp,0)

/* ========================================================================= */
/** @brief Clear a heap structure, and free any internal memory (not allocated
 * by the user).
 * @param __hp heap to clear.
 * */
#define fp20_EGeKHeapClear(__hp) fp20_EGeKHeapResize(__hp,0)

/* ========================================================================= */
/** @brief get the minimum value in the heap, note that since we are dealing
 * with a vector of values sorted lexicographically, the value is the value in
 * the first coordinate, other values can be accesses through
 * fp20_EGeKHeapGetMinKVal function.
 * @param __hp heap where we are working.
 * @param __number where to store the result
 * @return zero on success, non-zero otherwise.
 * */
#define fp20_EGeKHeapGetMinVal(__hp,__number) ({\
	fp20_EGeKHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? (fp20_EGlpNumCopy(__number,__EGehp->cn[0]->val[0]),0):1;})

/* ========================================================================= */
/** @brief get the k-th value of the first element in the heap.
 * @param __hp heap where we are working.
 * @param __number where to store the result.
 * @param __k which value to get (between 0 and fp20_EG_EKHEAP_ENTRY.
 * @return zero on success, non-zero otherwise.
 * */
#define fp20_EGeKHeapGetMinKVal(__hp,__k,__number) ({\
	fp20_EGeKHeap_t*const __EGehp = (__hp);\
	const int __EGki = (__k);\
	EXITL(fp20_EG_EKHEAP_DEBUG,(__EGki >= fp20_EG_EKHEAP_ENTRY) || (__EGki <0),\
				"K=%d out of range in fp20_EGeKHeapGetMinKVal", __EGki);\
	__EGehp->sz ? (fp20_EGlpNumCopy(__number,__EGehp->cn[0]->val[__EGki]),0):1;})

/* ========================================================================= */
/** @brief get the minimum conector in the heap, if the heap is empty, return
 * NULL.
 * @param __hp eap where we are working.
 * @return pointer to the minimum element in the heap.
 * */
#define fp20_EGeKHeapGetMin(__hp) ({\
	fp20_EGeKHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? __EGehp->cn[0] : 0;})

/* ========================================================================= */
/** @brief resize the heap cn array to the given size, if the new size is zero,
 * it is equivalent to free the internal memory, and left the heap as an empty
 * heap with zero space.
 * @param __hp heap where we are working.
 * @param __new_sz new size for the  cn array .
 * */
#define fp20_EGeKHeapResize(__hp,__new_sz) ({\
	fp20_EGeKHeap_t*const __EGehp = (__hp);\
	const size_t __EGehp_nsz = (size_t)(__new_sz);\
	__EGehp->cn = EGrealloc((__EGehp->cn), __EGehp_nsz * sizeof(fp20_EGeKHeapCn_t*));\
	__EGehp->max_sz = (unsigned int)(__EGehp_nsz);})

/* ========================================================================= */
/** @brief return the index of the father of the given index.
 * @param __d breadth of the heap.
 * @param __id position in the array to wich we want to compute it's father.
 * */
#define fp20_EGeKHeapFatherId(__d,__id) ((__id)?(((__id)-1)/(__d)):0)

/* ========================================================================= */
/** @brief given two heap connectors, return one if the first is less than the
 * second (in  lexicographic order).
 * @param __hcn1 first vector array.
 * @param __hcn2 second vector array.
 * @return one if __hcn1 <_LEX __hcn2 */
#define fp20_EGeKHeapIsLess(__hcn1,__hcn2) ({\
	EGfp20_t*const __EGEKH1 = (__hcn1);\
	EGfp20_t*const __EGEKH2 = (__hcn2);\
	int __EGEKHj = 0, __EGEKHrval = 0;\
	for( ; __EGEKHj < fp20_EG_EKHEAP_ENTRY ; __EGEKHj++)\
	{\
		if(fp20_EGlpNumIsLess(__EGEKH1[__EGEKHj], __EGEKH2[__EGEKHj])){\
			__EGEKHrval = 1; break;}\
		else if (fp20_EGlpNumIsNeq(__EGEKH1[__EGEKHj], __EGEKH2[__EGEKHj],fp20_epsLpNum)){\
			__EGEKHrval = 0; break;}\
	}\
	__EGEKHrval;})

/* ========================================================================= */
/** @brief copy two vector of values (only  fp20_EG_EKHEAP_ENTRY positions) from the
 * rource to the destination.
 * @param src fp20_source array.
 * @param dst destination array.
 * */
void fp20_EGeKHeapCopyVal(EGfp20_t*const dst, const EGfp20_t*const src);

/* ========================================================================= */
/** @brief move an element in the heap up in the heap (position 0 is the top,
 * this kind of move is neded whenever we decrease the value in a heap element).
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define fp20_EGeKHeapSiftUp(__hp,__hcn) ({\
	fp20_EGeKHeap_t*const __EGehp = (__hp);\
	fp20_EGeKHeapCn_t*const __EGecn = (__hcn);\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfpos = fp20_EGeKHeapFatherId(__EGehp->d,__EGcpos);\
	fp20_EGeKHeapCn_t*__EGfcn = __EGehp->cn[__EGfpos];\
	fp20_EGeKHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGcpos && \
				fp20_EGeKHeapIsLess(__EGecn->val,__EGfcn->val))\
	{\
		__EGfcn->pos = __EGcpos;\
		__EGehp->cn[__EGcpos] = __EGfcn;\
		__EGcpos = __EGfpos;\
		__EGfpos = fp20_EGeKHeapFatherId(__EGehp->d,__EGcpos);\
		__EGfcn = __EGehp->cn[__EGfpos];\
	}\
	__EGecn->pos = __EGcpos;\
	__EGehp->cn[__EGcpos] = __EGecn;\
	0;})

/* ========================================================================= */
/** @brief Add an element to the heap
 * @param __hp heap where to add the element.
 * @param __hcn element to be added.
 * @return zero on success, non-zero otherwise.
 * */
#define fp20_EGeKHeapAdd(__hp,__hcn) ({\
	fp20_EGeKHeap_t*const __EGlhp = (__hp);\
	fp20_EGeKHeapCn_t*const __EGlcn = (__hcn);\
	fp20_EGeKHeapCHECK_NF(__EGlhp);\
	__EGlcn->pos = __EGlhp->sz, \
	__EGlhp->cn[__EGlhp->sz] = __EGlcn, \
	__EGlhp->sz +=1, \
	fp20_EGeKHeapSiftUp(__EGlhp,__EGlcn), 0;})

/* ========================================================================= */
/** @brief Give the first child for a given position.
 * @param __id position that we want to get the first child.
 * @param __d breath of the heap. */
#define fp20_EGeKHeapFirstChildId(__d,__id) ((__d)*(__id)+1)

/* ========================================================================= */
/** @brief Move an element down in the heap (position 0 is the
 * top), this kind of operation is needed whenever we increase the value in a
 * heap element.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define fp20_EGeKHeapSiftDown(__hp,__hcn) ({\
	fp20_EGeKHeap_t*const __EGehp = (__hp);\
	fp20_EGeKHeapCn_t*const __EGecn = (__hcn);\
	const unsigned int __EGhsz = __EGehp->sz;\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfchd = fp20_EGeKHeapFirstChildId(__EGehp->d,__EGcpos);\
	unsigned int __EGlchd = __EGfchd + __EGehp->d;\
	fp20_EGeKHeapCn_t*__EGcchd = 0;\
	register unsigned int __EGehi = 0;\
	fp20_EGeKHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGfchd < __EGhsz)\
	{\
		/* detect the minimum child */\
		__EGcchd = __EGehp->cn[__EGfchd];\
		for(__EGehi = __EGlchd > __EGhsz ? __EGhsz-1 : __EGlchd-1 ;\
			__EGehi > __EGfchd ; __EGehi--)\
			if(fp20_EGeKHeapIsLess(__EGehp->cn[__EGehi]->val,__EGcchd->val))\
				__EGcchd = __EGehp->cn[__EGehi];\
		/* if the minimum child is less than the current position, move the minimum\
		 * child to the position of the current element */\
		if(fp20_EGeKHeapIsLess(__EGcchd->val,__EGecn->val))\
		{\
			__EGfchd = __EGcchd->pos;\
			__EGcchd->pos = __EGcpos;\
			__EGehp->cn[__EGcpos] = __EGcchd;\
			__EGecn->pos = __EGcpos = __EGfchd;\
			__EGehp->cn[__EGcpos] = __EGecn;\
			__EGfchd = fp20_EGeKHeapFirstChildId(__EGehp->d,__EGcpos);\
			__EGlchd = __EGfchd + __EGehp->d;\
		}\
		/* else we exit the main loop */\
		else __EGfchd = UINT_MAX;\
	}\
	0;})

/* ========================================================================= */
/** @brief Change the value of an element in the heap.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap that we are going to change it's value.
 * @param __new_val new value for the element (note this is an array of size at
 * least fp20_EG_EKHEAP_ENTRY.
 * @return zero on success, non-zero otherwise.
 * */
#define fp20_EGeKHeapChangeVal(__hp,__hcn,__new_val) ({\
	fp20_EGeKHeapCn_t*const __EGEKHcn = (__hcn);\
	(fp20_EGeKHeapIsLess(__new_val,(__EGEKHcn)->val)) ? (fp20_EGeKHeapCopyVal((__EGEKHcn)->val,__new_val),fp20_EGeKHeapSiftUp(__hp,__EGEKHcn)) : (fp20_EGeKHeapCopyVal((__EGEKHcn)->val,__new_val),fp20_EGeKHeapSiftDown(__hp,__EGEKHcn));})

/* ========================================================================= */
/** @brief Eliminate an element from the heap, note that the position stored in
 * the eliminated element is reset to zero.
 * @param __hp heap where we are working.
 * @param __hcn element to eliminate from the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define fp20_EGeKHeapDel(__hp,__hcn) ({\
	fp20_EGeKHeap_t*const __EGlhp = (__hp);\
	fp20_EGeKHeapCn_t*const __EGlhpcn = (__hcn);\
	unsigned int const __EGlcn = __EGlhpcn->pos;\
	unsigned int const __EGlhsz = __EGlhp->sz - 1;\
	__EGlhpcn->pos = fp20_EG_EKHEAP_POISON;\
	__EGlhp->sz = __EGlhsz;\
	if(__EGlhsz && __EGlhsz != __EGlcn){\
		__EGlhp->cn[__EGlcn] = __EGlhp->cn[__EGlhp->sz];\
		__EGlhp->cn[__EGlcn]->pos = __EGlcn;\
		fp20_EGeKHeapSiftDown(__EGlhp,__EGlhp->cn[__EGlcn]);}\
	__EGlhp->cn[__EGlhp->sz] = 0;})

/* ========================================================================= */
/** @brief Check the integrity of the given heap.
 * @param __hp heap to check.
 * @return zero on success, non-zero otherwise.
 * */
#if fp20_EG_EKHEAP_DEBUG <= DEBUG
#define fp20_EGeKHeapCheck(__hp) ({\
	fp20_EGeKHeap_t*const __EGehp = (__hp);\
	register unsigned int __EGehi = __EGehp->sz;\
	if(__EGehi)\
		while(--__EGehi)\
			if(__EGehp->cn[__EGehi]->pos != __EGehi || \
				fp20_EGeKHeapIsLess( __EGehp->cn[__EGehi]->val,\
												__EGehp->cn[fp20_EGeKHeapFatherId(__EGehp->d,__EGehi)]->val))\
			{\
				MESSAGE(fp20_EG_EKHEAP_DEBUG,"Element %u is wrong, pos %u val [%lf,%lf]"\
							 ,__EGehi, __EGehp->cn[__EGehi]->pos, \
							 fp20_EGlpNumToLf(__EGehp->cn[__EGehi]->val[0]), \
							 fp20_EGlpNumToLf(__EGehp->cn[fp20_EGeKHeapFatherId(__EGehp->d,__EGehi)]->val[0]));\
				break;\
			}\
	__EGehi;})
#else
#define fp20_EGeKHeapCheck(__hp) 0
#endif

/* ========================================================================= */
/** @brief set the breath of the heap, this function must be called only when
 * the heap is empty.
 * @param __hp heap to set breath.
 * @param __width new with for the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define fp20_EGeKHeapChangeD(__hp,__width) ({\
	fp20_EGeKHeap_t*const __EGehp = (__hp);\
	EXIT((__width)<2,"Width should be at least 2 for heaps");\
	__EGehp->sz ? 1 : (__EGehp->d = (__width), 0);})

/* ========================================================================= */
/** @} */
/* end of fp20_eg_ekheap.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGsrkGraph EGsrkGraph
 * This is a group of functions, macros and types designed to work with
 * graphs that are shrinkable, meaning that we can take two nodes in the
 * (current) graph, and shrink them into a single node, and at the same time
 * collapse all edges that become loops and if two edges are parallel, keep
 * just one (but keep a reference to the collapsed edge). At the same time the
 * shrunken nodes keep a list to the nodes 'embeded' or 'shrunken' into the
 * given node. More details in the structure definition and in the example.
 * Note that this implementation only support undirected graphs with actual
 * weights on the edges, the weights must be of type EGfp20_t, and their
 * values are updated during the shrinking procedure, so if anyone want to
 * have the original values omewere else, they will have to keep an extra copy
 * outside. Most of the ideas used in this implementation come from CONCORDE.
 * 
 * @version 0.0.1
 * @par History:
 * - 2005-06-01
 * 						- First Implementation.
 * */
/** @file
 * @ingroup EGsrkGraph */
/** @addtogroup EGsrkGraph */
/** @{ */
/** @example fp20_eg_shrink_graph.ex.c */
/* ========================================================================= */

#ifndef fp20__EGshrinkGraph_h__
#define fp20__EGshrinkGraph_h__
#ifndef fp20_EG_SRK_DEBUG
/* ========================================================================= */
/** @brief debuigging level, the lower the more debugging is carried out */
#define fp20_EG_SRK_DEBUG 100
#endif

/* ========================================================================= */
/** @brief Edge structure for shrinkable graphs */
typedef struct fp20_EGsrkEdge_t
{
	EGeUgraphEdge_t edge;	/**< Actual edge structure for the graph */
	EGeList_t members;		/**< list of other edges shrunken within this edge */
	unsigned int mmb_sz;	/**< length of the members list (without including the 
														 edge itsself */
	EGfp20_t weight;			/**< Weight for the edge */
}
fp20_EGsrkEdge_t;

/* ========================================================================= */
/** @brief Node structure for shrinkable graphs */
typedef struct fp20_EGsrkNode_t
{
	EGeUgraphNode_t node;	/**< actual node structure for the graph */
	EGeList_t members;		/**< list of other nodes shrunken with this node */
	unsigned int mmb_sz;	/**< length of the members list (without including the
														 node itself */
	EGes_t parent;				/**< If this node is the representant for its class, 
														 then this is a 'parent' node, otherwise, is a 
														 shrunken node */
	EGfp20_t weight;			/**< Weight of the @f$\delta(n)@f$ edges for this node
														 (in the shrunken graph), this should be 
														 initialized by the user. */
	fp20_EGsrkEdge_t *hit;			/**< used for internal purposes, in particular, while 
														 merging two adjacency lists, this field is used 
														 to store the first edge touching this node, and 
														 then used to retrieve that information. When we 
														 call #fp20_EGsrkIdentifyNodes this field is assumed 
														 to be NULL */
}
fp20_EGsrkNode_t;

/* ========================================================================= */
/** @brief Graph structure for shrinkable graphs */
typedef struct fp20_EGsrkGraph_t
{
	EGeUgraph_t G;					/**< Actual graph structure. */
	unsigned n_onodes;			/**< Number of original nodes */
	unsigned n_oedges;			/**< Number of original edges */
}
fp20_EGsrkGraph_t;

/* ========================================================================= */
/** @brief Initialize an edge structure.
 * @param e_edge */
#define fp20_EGsrkEdgeInit(e_edge) ({\
	fp20_EGsrkEdge_t*const _EGsrkE = (e_edge);\
	EGeUgraphEdgeInit(&(_EGsrkE->edge));\
	EGeListInit(&(_EGsrkE->members));\
	_EGsrkE->mmb_sz = 0;\
	fp20_EGlpNumInitVar(_EGsrkE->weight);\
	fp20_EGlpNumZero(_EGsrkE->weight);})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of an edge
 * structure.
 * @param e_edge */
#define fp20_EGsrkEdgeClear(e_edge) ({\
	EGeUgraphEdgeClear(&((e_edge)->edge));\
	fp20_EGlpNumClearVar((e_edge)->weight);})

/* ========================================================================= */
/** @brief Initialize a graph structure 
 * @param graph graph to be initialized */
#define fp20_EGsrkGraphInit(graph) ({\
	fp20_EGsrkGraph_t*const _EGsrkG = (graph);\
	EGeUgraphInit(&(_EGsrkG->G));\
	_EGsrkG->n_onodes = _EGsrkG->n_oedges = 0;})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a graph
 * structure.
 * @param graph */
#define fp20_EGsrkGraphClear(graph) EGeUgraphClear(&((graph)->G))

/* ========================================================================= */
/** @brief Initialize a node structure.
 * @param e_node node to be initialized */
#define fp20_EGsrkNodeInit(e_node) ({\
	fp20_EGsrkNode_t*const _EGsrkN = (e_node);\
	EGeUgraphNodeInit(&(_EGsrkN->node));\
	EGeListInit(&(_EGsrkN->members));\
	_EGsrkN->mmb_sz = 0;\
	_EGsrkN->hit = 0;\
	EGesInit(&(_EGsrkN->parent));\
	fp20_EGlpNumInitVar(_EGsrkN->weight);\
	fp20_EGlpNumZero(_EGsrkN->weight);})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a node
 * structure.
 * @param e_node */
#define fp20_EGsrkNodeClear(e_node) ({\
	EGeUgraphNodeClear(&((e_node)->node));\
	fp20_EGlpNumClearVar((e_node)->weight);})

/* ========================================================================= */
/** @brief Add a #fp20_EGsrkNode_t node to a #fp20_EGsrkGraph_t graph.
 * @param graph graph were to add the node.
 * @param N node to add to the graph.
 * @return zero on success, non-zero otherwise.
 * */
#define fp20_EGsrkAddNode(graph,N) EGeUgraphAddNode(&((graph)->G),&((N)->node))

/* ========================================================================= */
/** @brief Add a #fp20_EGsrkEdge_t edge to a #fp20_EGsrkGraph_t graph.
 * @param lG graph were to add the edge.
 * @param head_pt head node of the edge.
 * @param tail_pt tail node of the edge.
 * @param E edge to be added with end-points head_pt and tail_pt.
 * Note that this function will update the accumulated weight of both
 * endpoints of the newly added edge according to the value stored in the
 * #fp20_EGsrkEdge_t::weight field.
 * */
#define fp20_EGsrkAddEdge(lG,head_pt,tail_pt,E) ({\
	fp20_EGsrkNode_t*const _EGsrkH = (head_pt);\
	fp20_EGsrkNode_t*const _EGsrkT = (tail_pt);\
	fp20_EGsrkEdge_t*const _EGsrkE = (E);\
	fp20_EGlpNumAddTo(_EGsrkH->weight,_EGsrkE->weight);\
	fp20_EGlpNumAddTo(_EGsrkT->weight,_EGsrkE->weight);\
	EGeUgraphAddEdge(&((lG)->G),&(_EGsrkH->node),&(_EGsrkT->node),&(_EGsrkE->edge));})

/* ========================================================================= */
/** @brief Given two nodes in the current shrunken graph, shrunk them into one 
 * node.
 * @param G pointer to the graph where we are working
 * @param base first node.
 * @param srkN second node.
 * @return pointer to the new representing node.
 * @note We assume that the field fp20_EGsrkNode_t::hit is identically NULL for all
 * nodes currently in the shrunken graph (including base and srkN). 
 * @note We allways assume that N1 will be the representing node.
 * @note Take note that this structure can't get back the pointer to the srkN
 * node, the user should take care of that if needed.
 * */
fp20_EGsrkNode_t *fp20_EGsrkIdentifyNodes (fp20_EGsrkGraph_t * const G,
																 fp20_EGsrkNode_t * const base,
																 fp20_EGsrkNode_t * const srkN);

/* ========================================================================= */
/** @} 
 * end of fp20_eg_shrink_graph.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgPushRelabel EGalgPushRelabel
 *
 * Here we implement the push-relabel algorithm as defined in the book "Network 
 * Flows" by Magnanti et. all, in chapter 6,7 and 8. Using the variant
 * "Highest-label preflow-push algorithm" (described on page 230) wich choose
 * the active node from wich to push from as the one with highest distance
 * label. This variant has running time @f$ \mathcal{O}(n^2\sqrt{m}) @f$ where
 * @a n is the number of nodes in the graph, and @a m the number of edges in it.
 * Note that the call to #fp20_EGalgPRminSTcut produces a maximum @b pre_flow, to 
 * obtain a flow you should call the #fp20_EGalgPRmaxSTflow that takes the graph 
 * produced by #fp20_EGalgPRminSTcut and convert the preflow into a real flow. We
 * also choose to use to register the number of nodes with distance labels
 * @f$k,\quad\forall k=1,\ldots,n@f$ where @a n is the number of nodes in the
 * network. This is done because whenever the number of nodes with distance
 * labels @a k is zero, then all nodes with distance labels above @a k can be
 * set to @a n (and thus be added to the partially computed cut-set). This is an
 * (inportant) empirical speed-up, but does not affect the worst case complexity
 * analysis.
 * @version 1.0.0
 * @par History:
 * - 2010-05-07
 * 						- Add implementation using eg_adgraph.h
 * - 2005-06-01
 * 						- Add globla relabeling heuristic.
 * - 2005-05-30
 * 						- Final test results on the TSP x-files, all should be right now.
 * - 2005-05-26
 * 						- First Implementation.
 * @note This algorithm is implemented the embedded structures approach. I will
 * give further details on what this implies.
 *
 * @note It is important to note that this algorithm (as implemented here) 
 * @b WILL @b FAIL if an edge has infinite capacities. To handle that case
 * either we must re-program it, or you can put capacities suficiently large on
 * them (for example 2 times the sum of all bounded capacities) for this
 * algorithm to work.
 *
 * @note This implementation does use global relabeling, namelly, the
 * strategy when once in a while (for example every @a n or @a m relabeling
 * operations) we recompute
 * the exact distance labels. The use of this heuristic (together with the gap
 * heuristic) have been reported to be the most successfull in practice (see "On
 * Implementing Push-Relabel Method For The Maximum FLow Problem" from Boris V.
 * Cherkassy and Andrew V. Goldberg.) and also in the test that we have
 * performed on the fractional solutions of TSP's instances from the TSPLIB set
 * of problems using CONCORDE.
 * */
/** @file 
 * @ingroup EGalgPushRelabel */
/** @addtogroup EGalgPushRelabel */
/** @{ */
/** @example fp20_eg_push_relabel.ex.c
 * This is a complete example for the min-cut max-flow problem using the
 * push/relabel implementation offered in EGalgPR. */
#ifndef fp20___EG_PUSH_RELABEL_H__
#define fp20___EG_PUSH_RELABEL_H__
/* ========================================================================= */

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define fp20___PR_DEBUGL__ 100

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define fp20___PR_TEST_VERBOSE__ 100

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define fp20___PR_VERBOSE__ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define fp20___PR_PROFILE__ 100

/* ========================================================================= */
/** @brief If profiling is enable (i.e. #fp20___PR_PROFILE__ <= DEBUG), print 
 * some profiling information of the min s-t cut used up to now, and reset 
 * all internal counters to zero, if profiling is not enabled, nothing 
 * happen. */
/** @{ */
void fp20_EGalgPRprofile(void);
/** @} */
/* ========================================================================= */
/** @brief If set to non-zero, use the global relabeling heuristic (to be called
 * every @a n number of relabel operations performed. if set to zero, it won't
 * use this heuristic. Note thought that it has been shown that this is a very
 * efficient heuristic to reduce the total running time, specially in the
 * #fp20_EGalgPRminSTcut function call. */
#define fp20_EG_PR_RELABEL 1

/* ========================================================================= */
/** @brief If #fp20_EG_PR_RELABEL is set to one, then this initeger controls how
 * often we perform the global relabeling heuristic (in multiples of number of
 * nodes), the default value is 1. */
#define fp20_EG_PR_RELABEL_FREC 1U

/* ========================================================================= */
/** @brief Node structure neede to run Push-Relabel algorithm on a network.
 * @note Notice that the directed graph part is embeded in this structure as
 * well. Note  that we could define internally space for  LVL_list, 
 * but for the sake of speed we include them in the node structure. */
typedef struct fp20_EGalgPRnode_t
{
	EGeDgraphNode_t v;		/**< Actual node structure to work with (EGeDgraph) */
	EGeList_t LVL_list;		/**< Used to store the BFS list used for the first 
														 computations of the exact label distances, and 
														 then to store this node in it's current level list 
														 (this is used to implement the Highest-Label 
														 variant of the Preflow-Push algorithm) */
	EGeList_t T_cut;			/**< Used to speed-up the 'hole' heuristic, it is seted
														 once we enter the algorithm, so their value is 
														 non-important outside the function (but it's 
														 contents will be lost once we enter 
														 #fp20_EGalgPRminSTcut). */
	unsigned int d;				/**< Exact label distance for this node. Note that 
														 nodes with distance lables @f$ \geq n @f$ (where 
														 @a n is the number of nodes in the graph) define 
														 the minimum @f$ s-t@f$ cut that we are looking 
														 for. */
	EGfp20_t e;					/**< Exess flow in the node. Note that in particular 
														 the excess on node @a t (once #fp20_EGalgPRminSTcut 
														 finish) correspond to the minimum cut value. */
}
fp20_EGalgPRnode_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an fp20_EGalgPRnode_t structure */
#define fp20_EGalgPRnodeInit(node_pt) ({\
	fp20_EGalgPRnode_t*const __EGalgPR_in = (node_pt);\
	fp20_EGlpNumInitVar(__EGalgPR_in->e);\
	EGeDgraphNodeInit(&(__EGalgPR_in->v));})

/* ========================================================================= */
/** @brief Reset the given node pointer (as if it were new).
 * @param node_pt pointer to the node to reset.
 * 
 * This function set the node as an empty node not linked with any graph.
 * */
#define fp20_EGalgPRnodeReset(node_pt) EGeDgraphNodeReset(&((node_pt)->v))

/* ========================================================================= */
/** @brief clear a pointer to an fp20_EGalgPRnode_t structure, and let it ready to be
 * freed if necesary. */
#define fp20_EGalgPRnodeClear(node_pt) ({\
	fp20_EGlpNumClearVar((node_pt)->e);\
	EGeDgraphNodeClear(&((node_pt)->v));})

/* ========================================================================= */
/** @brief capacitated edge structure with forward/backward information. */
typedef struct fp20_EGalgPRse_t
{
	EGeDgraphEdge_t e;	/**< actual edge information. */
	EGfp20_t r;				/**< residual capacity of the edge. */
	EGfp20_t u;				/**< maximum capacity on the edge. */
	unsigned char type;	/**< type of edge (0 for forward and 1 for backward */
}
fp20_EGalgPRse_t;

/* ========================================================================= */
/** @brief Edge Structure needed to run Push-Relabel algorithm on a network.
 * @note Notice that the this edge actually has actually two capacited edge
  substructures, one for forward edges and one for backward edge, it is assumed
 * that fw.type == 0 and bw.type == 1. This is needed because the algorithm 
 * asumes that both
 * edges exists (althought one may have zero capacity). Moreover, while
 * computing the residual capacities we need to access both edges e_ij and e_ji
 * at the same time, thus our choice to represent both edges in just one
 * structure. We also assume that the lower bound on the flow of all edges is
 * zero. Note that we don't need to keep explicitly the flow on the edges,
 * because given the residual capacity and the capacity on the edge we have that
 * @f$ x_{ij} - x_{ji} = u_{ij} - r_{ij} @f$ and thus we can set @f$ x_{ij} =
 * (u_{ij}-r_{ij})_+ @f$ and @f$ x_{ji} = (r_{ij}-u_{ij})_+ @f$.
 * if we have computed the maximal flow. */
typedef struct fp20_EGalgPRedge_t
{
	fp20_EGalgPRse_t fw;		/**< forward edge, we assum that fw.type = 0 */
	fp20_EGalgPRse_t bw;		/**< backward edge, we assume that bw.type = 1 */
}
fp20_EGalgPRedge_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an fp20_EGalgPRedge_t structure */
#define fp20_EGalgPRedgeInit(edge_pt) ({\
	fp20_EGalgPRedge_t*const __EGalgPR_ie = (edge_pt);\
	fp20_EGlpNumInitVar(__EGalgPR_ie->fw.r);\
	fp20_EGlpNumInitVar(__EGalgPR_ie->fw.u);\
	fp20_EGlpNumInitVar(__EGalgPR_ie->bw.r);\
	fp20_EGlpNumInitVar(__EGalgPR_ie->bw.u);\
	EGeDgraphEdgeInit(&(__EGalgPR_ie->fw.e));\
	EGeDgraphEdgeInit(&(__EGalgPR_ie->bw.e));\
	__EGalgPR_ie->bw.type = 1;\
	__EGalgPR_ie->fw.type = 0;})

/* ========================================================================= */
/** @brief Reset the given edge pointer (as if it were new).
 * @param edge_pt pointer to the node to reset.
 * 
 * This function set the edge as an empty edge not linked with any graph.
 * */
#define fp20_EGalgPRedgeReset(edge_pt) ({\
	fp20_EGalgPRedge_t*const __EGalgPR_ie = (edge_pt);\
	EGeDgraphEdgeReset(&(__EGalgPR_ie->fw.e));\
	EGeDgraphEdgeReset(&(__EGalgPR_ie->bw.e));\
	__EGalgPR_ie->bw.type = 1;\
	__EGalgPR_ie->fw.type = 0;})


/* ========================================================================= */
/** @brief clear a pointer to an fp20_EGalgPRedge_t structure, and let it ready to be
 * freed if necesary. */
#define fp20_EGalgPRedgeClear(edge_pt) ({\
	fp20_EGlpNumClearVar((edge_pt)->fw.r);\
	fp20_EGlpNumClearVar((edge_pt)->fw.u);\
	fp20_EGlpNumClearVar((edge_pt)->bw.r);\
	fp20_EGlpNumClearVar((edge_pt)->bw.u);\
	EGeDgraphEdgeClear(&((edge_pt)->fw.e));\
	EGeDgraphEdgeClear(&((edge_pt)->bw.e));})

/* ========================================================================= */
/** @brief Graph structure needed to run Push-Relabel algorithm (with highest
 * label node selection rule). */
typedef struct fp20_EGalgPRgraph_t
{
	EGeDgraph_t G;				/**< EGeDgraph structure holding the graph 
														 information. */
}
fp20_EGalgPRgraph_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an fp20_EGalgPRgraph_t structure */
#define fp20_EGalgPRgraphInit(graph_pt) EGeDgraphInit(&((graph_pt)->G))

/* ========================================================================= */
/** @brief Reset the given graph pointer (as if it were new).
 * @param graph_pt pointer to the node to reset.
 * 
 * This function set the graph as an empty graph.
 * */
#define fp20_EGalgPRgraphReset(graph_pt) EGeDgraphReset(&((graph_pt)->G))

/* ========================================================================= */
/** @brief clear a pointer to an fp20_EGalgPRgraph_t structure, and let it ready 
 * to be freed if necesary. */
#define fp20_EGalgPRgraphClear(graph_pt) EGeDgraphClear(&((graph_pt)->G))

/* ========================================================================= */
/** @brief Compute a minimum @f$s-t@f$ cut.
 * @param s pointer to the fp20_source node.
 * @param t pointer to the fp20_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the fp20_EGalgPRgraph_t* in wich we will work.
 * @return zero on success, non-zero otherwise.
 * @par Description:
 * When this funcion finish (successfully) all nodes with field
 * #fp20_EGalgPRnode_t::d bigger than or equal to @a n (the number of nodes in the
 * graph) bellong to the @a s cut, while nodes with value strictly less than @a
 * n will bellong to the @a t cut. The residual capacities imply a maximum
 * pre-flow in the network, to get an acutal maximum flow you should run 
 * #fp20_EGalgPRmaxSTflow function with imput the output graph of this function 
 * (for an example look at the file fp20_eg_push_relabel.ex.c ).
 * @note This implementation uses the @a gap and @a global @a relabeling
 * heuristics to speed-up the computations.
 * */
int fp20_EGalgPRminSTcut (fp20_EGalgPRgraph_t * const G,
										 fp20_EGalgPRnode_t * const s,
										 fp20_EGalgPRnode_t * const t);

/* ========================================================================= */
/** @brief Compute a maximum @f$s-t@f$ flow from the ouput produced by
 * EGalgPRminCur.
 * @param s pointer to the fp20_EGalgPRnode_t* fp20_source node in the network.
 * @param t pointer to the fp20_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the fp20_EGalgPRgraph_t* in wich we will work.
 * @return zero on success, non-zero otherwise.
 * @par Description:
 * We assume that our input graph is the (unaltered) result of a 
 * call to #fp20_EGalgPRminSTcut. Also, note that while computing the actual 
 * max @a s-@a t flow, we don't need to look for @a gap in the array of 
 * distances.
 * Also note that once you call this function, the information in
 * #fp20_EGalgPRnode_t::d don't correspond any more to the cut as defined in
 * #fp20_EGalgPRminSTcut.
 * */
int fp20_EGalgPRmaxSTflow (fp20_EGalgPRgraph_t * const G,
											fp20_EGalgPRnode_t * const s,
											fp20_EGalgPRnode_t * const t);

/* ========================================================================= */
/** @brief Check if the given input graph (with it's residual capacities)
 * represent an optimal solution to the maximum @f$ s-t @f$ flow / minimum
 * capacity @f$ s-t @f$ cut.
 * @param s pointer to the fp20_EGalgPRnode_t* fp20_source node in the network.
 * @param t pointer to the fp20_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the fp20_EGalgPRgraph_t* in wich we will work.
 * @param error worst error while checking for optimality conditions.
 * @return zero if all discrepancies are under the #fp20_epsLpNum threshold, 
 * otherwise, return the number of conditions that don't hold within that
 * threshold, and report in error the worst error found in any condition.
 * @note The input for this function should be the graph as returned by
 * #fp20_EGalgPRmaxSTflow .
 * */
int fp20_EGalgPRoptimalityTest (fp20_EGalgPRgraph_t * const G,
													 fp20_EGalgPRnode_t * const s,
													 fp20_EGalgPRnode_t * const t,
													 EGfp20_t * error);

/* ========================================================================= */
/* @} */
/* end of fp20_eg_push_relabel.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgMinCut EGalgMinCut
 *
 * Here we implement the min-cut algorithm based on the srinking
 * pre-processing of Padberg And Rinaldi in the paper "An Efficient 
 * Algorithm For The Minimum Capacity Cut Problem", Mathematical Programming
 * 47 (1990) pages 19-36. But using as minimum s-t cut code the Push-Relabel
 * max flow algorithm as implemented in the @ref EGalgPushRelabel module. This 
 * implies that we only support positive edge-weights.
 *
 * This implementation allows uses of diferent numbers as supported by
 * @ref EGlpNum module. And follows the philosophy of embeded structures as in
 * @ref EGalgPushRelabel module. Also, much of the approach used in this 
 * implementation come from CONCORDE's implementation.
 *
 * It is usually the case that the Minimum Cut Problem is just a sub-problem
 * of some larger problem, is for that reason that we implement (just as in
 * CONCORDE) a callback function that is called whenever an improving solution
 * is found, so that the user can do something with the given node-cutset and
 * value. for more details see the definition of #fp20_EGalgMCcbk_t .
 *
 * @note 
 * If run with types like EGfp20_t, if the arithmetic produces an overflow,
 * then we are in big trouble, note that the numbers involved in the algorithm
 * may range up to \f$\sum(w_e:e\in E(G))\f$.
 *
 * @version 0.0.1
 * @par History:
 * - 2005-08-19
 * 						- While computing a minimum S-T cut, choose S randomly. and T
 * 							as a node at maximum distance (number of edges) from S.
 * 						- Fix small problem with shrinking level 4
 * - 2005-06-20
 * 						- First Implementation.
 * */
/** @file
 * @ingroup EGalgMinCut */
/** @addtogroup EGalgMinCut */
/** @{ */
/** @example fp20_eg_min_cut.ex.c */
/* ========================================================================= */
#ifndef fp20__EG_MIN_CUT_H
#define fp20__EG_MIN_CUT_H
/* ========================================================================= */
/** @brief Verbosity Level */
#define fp20___MC_VRBLVL_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define fp20___MC_DEBUG_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define fp20___MC_PROFILE_ 0

/* ========================================================================= */
/** If profiling is enable (i.e. #fp20___MC_PROFILE_ <= DEBUG), print 
 * some profiling information of the min cut used up to now, and reset 
 * all internal counters to zero, if profiling is not enabled, nothing 
 * happen. */
/** @{ */
void fp20_EGalgMCprofile(void);
/** @} */

/* ========================================================================= */
/** @brief Call-back function, it receives as input the weight of the cut, the
 * size of the newly found cut, an array containing the cut (of length at
 * least the number of elements in the cut) as integers (as defined by the 
 * #fp20_EGalgMCnode_t::id field), and a pointer to some internal
 * data (as stored in #fp20_EGalgMCcbk_t::param). The function should return zero
 * on success, and non-zero if an error ocours, this error will be propagated
 * through the calling functions. */
typedef int (*fp20_EGalgMCdo_f) (EGfp20_t,
														const unsigned int,
														const unsigned int *const,
														void *);

/* ========================================================================= */
/** @brief Call-back structure for use when an improving minimum cut is found.
 * */
typedef struct fp20_EGalgMCcbk_t
{
	EGfp20_t cutoff;	/**< maximum value for the newly found minimum cut, for 
												 the function to be called. */
	void *param;			/**< external parameter needed by the function */
	fp20_EGalgMCdo_f do_fn;/**< actual function to be called if the cut-off condition 
												 holds */
}
fp20_EGalgMCcbk_t;

/* ========================================================================= */
/** @brief Initialize a call-back structure.
 * @param cb call-back to be initialized. */
#define fp20_EGalgMCcbkInit(cb) ({\
	fp20_EGalgMCcbk_t*const _EGalgMCcb = (cb);\
	fp20_EGlpNumInitVar(_EGalgMCcb->cutoff);\
	_EGalgMCcb->param = 0;\
	_EGalgMCcb->do_fn = 0;})

/* ========================================================================= */
/** @brief Free all internal memory asociated with this structure (not
 * allocated by the user).
 * @param cb call-back strucure to be cleared */
#define fp20_EGalgMCcbkClear(cb) fp20_EGlpNumClearVar((cb)->cutoff)

/* ========================================================================= */
/** @brief Node structure for Minimum Cut */
typedef struct fp20_EGalgMCnode_t
{
	fp20_EGsrkNode_t node;		/**< Actual shrinkable node */
	unsigned int id;		/**< External Identifier for the node */
	EGeList_t lvl_cn;		/**< Connector for the level list */
	unsigned int fp20_lvl;		/**< Current node level test to be performed */
	unsigned int new_id;/**< internal data, it's values can be discarded */
	fp20_EGsrkEdge_t *hit;		/**< Used to speed-up the Padberg-Rinaldi tests. */
}
fp20_EGalgMCnode_t;

/* ========================================================================= */
/** @brief Initialize a node structure for use.
 * @param N node to be initialized */
#define fp20_EGalgMCnodeInit(N) ({\
	fp20_EGalgMCnode_t*const _EGalgMCn = (N);\
	fp20_EGsrkNodeInit(&(_EGalgMCn->node));\
	_EGalgMCn->lvl_cn = (EGeList_t){0,0};\
	_EGalgMCn->fp20_lvl = 0;\
	_EGalgMCn->id = UINT_MAX;\
	_EGalgMCn->new_id = UINT_MAX;\
	_EGalgMCn->hit = 0;})

/* ========================================================================= */
/** @brief Clear any internal memory (not allocated by the user) used by this
 * structure.
 * @param N node to be cleared */
#define fp20_EGalgMCnodeClear(N) fp20_EGsrkNodeClear(&((N)->node))

/* ========================================================================= */
/** @brief Edge structure for the Minimum Cut */
typedef struct fp20_EGalgMCedge_t
{
	fp20_EGsrkEdge_t edge;	/**< Actual shrinkable edge */
	unsigned int id;	/**< External Identifier for the edge */
}
fp20_EGalgMCedge_t;

/* ========================================================================= */
/** @brief Initialize an edge structure for use.
 * @param E edge to be initialized */
#define fp20_EGalgMCedgeInit(E) ({\
	fp20_EGalgMCedge_t*const _EGalgMCe = (E);\
	fp20_EGsrkEdgeInit(&(_EGalgMCe->edge));\
	_EGalgMCe->id = UINT_MAX;})

/* ========================================================================= */
/** @brief Clear any internal memory (not allocated by the user) used by this
 * structure.
 * @param E node to be cleared */
#define fp20_EGalgMCedgeClear(E) fp20_EGsrkEdgeClear(&((E)->edge))

/* ========================================================================= */
/** @brief Graph Structure for Minimum Cut.
 *
 * Note that this structure also holds some parameters as the epsilon to use
  in the comparisons, the current best cut found (or bound), and the current
 * cut found so-far. As well as an array containing all edges and nodes in
 * thee graph (remember that when we Identify two nodes, we loose any
 * reference to the shrinked node in the graph structure as discussed in
 * #fp20_EGsrkIdentifyNodes ) 
 * */
typedef struct fp20_EGalgMCgraph_t
{
	fp20_EGsrkGraph_t G;						/**< Actual shrinking graph used */
	EGfp20_t epsilon;				/**< error tolerance used for equality testing */
	EGfp20_t cut_val;				/**< if #fp20_EGalgMCgraph_t::cut_sz is not zero, then 
																 this is the value of the (currenlty) best 
																 minimum cut found so far. otherwise is a bound 
																 on the value of the minimum cut (note that this
																 value should be set before actually computing 
																 the minimum cut, and can be set to the value 
																 of @f$\delta(v)@f$ for some node @a v in the 
																 graph. */
	unsigned int cut_sz;			/**< number of nodes in the current best cut, if 
																 set to zero, then no cut has been found 
																 (so far) */
	EGeList_t lvl_list[5];		/**< List of nodes in different levels of tests */
	unsigned int *cut;				/**< Array  storing the current cut, the size of 
																 this array should be at least 
																 #fp20_EGsrkGraph_t::n_onodes */
	fp20_EGalgMCnode_t *all_nodes;	/**< Array containing all nodes of the graph. */
	fp20_EGalgMCedge_t *all_edges;	/**< Array containing all edges of the graph. */
}
fp20_EGalgMCgraph_t;

/* ========================================================================= */
/** @brief Initialize a graph structure for use.
 * @param Graph graph to be initialized */
#define fp20_EGalgMCgraphInit(Graph) ({\
	fp20_EGalgMCgraph_t*const _EGalgMCg = (Graph);\
	fp20_EGsrkGraphInit(&(_EGalgMCg->G));\
	fp20_EGlpNumInitVar(_EGalgMCg->epsilon);\
	fp20_EGlpNumZero(_EGalgMCg->epsilon);\
	fp20_EGlpNumInitVar(_EGalgMCg->cut_val);\
	fp20_EGlpNumZero(_EGalgMCg->cut_val);\
	_EGalgMCg->cut_sz = 0;\
	EGeListInit(_EGalgMCg->lvl_list);\
	EGeListInit(_EGalgMCg->lvl_list+1);\
	EGeListInit(_EGalgMCg->lvl_list+2);\
	EGeListInit(_EGalgMCg->lvl_list+3);\
	EGeListInit(_EGalgMCg->lvl_list+4);\
	_EGalgMCg->cut = 0;\
	_EGalgMCg->all_nodes = 0;\
	_EGalgMCg->all_edges = 0;})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a graph
 * structure.
 * @param Graph graph to be cleared. */
#define fp20_EGalgMCgraphClear(Graph) ({\
	fp20_EGsrkGraphClear(&((Graph)->G));\
	fp20_EGlpNumClearVar((Graph)->epsilon);\
	fp20_EGlpNumClearVar((Graph)->cut_val);})

/* ========================================================================= */
/** @brief Shrink two nodes in the graph, and update internal structures.
 * @param Graph current graph.
 * @param N node to keep in graph.
 * @param M node to shrink within N. */
#define fp20_EGalgMCidentifyNodes(Graph,N,M) ({\
	fp20_EGalgMCgraph_t*const _EGalgMCg = (Graph);\
	fp20_EGalgMCnode_t*const _EGalgMCn = (N), *const _EGalgMCm = (M);\
	MESSAGE(fp20___MC_DEBUG_,"Shrinking nodes with weight %lf %lf", \
					fp20_EGlpNumToLf(_EGalgMCn->node.weight), \
					fp20_EGlpNumToLf(_EGalgMCm->node.weight));\
	fp20_EGsrkIdentifyNodes(&(_EGalgMCg->G), &(_EGalgMCn->node), &(_EGalgMCm->node));\
	if(_EGalgMCn->fp20_lvl < 5)\
	{\
		EGeListDel(&(_EGalgMCm->lvl_cn));\
		EGeListMoveAfter(&(_EGalgMCn->lvl_cn), _EGalgMCg->lvl_list);\
	}\
	else EGeListAddAfter(&(_EGalgMCn->lvl_cn), _EGalgMCg->lvl_list);\
	_EGalgMCn->fp20_lvl = 0;})

/* ========================================================================= */
/** @brief Identify all Padberg and Rinaldy edges. i.e. shrink all edges that
 * satisfy the conditions in their paper. we choose to make tests over pair of
 * nodes linked by an edge. 
 * @param max_lvl set a limit on wich tests to perform. for example, if set to
 * 1, only the first and second tests will be carried out.
 * @param G graph over wich we are working. 
 * @param cb call back structure to use (if set to NULL it is not used).
 * @return zero on success, non-zero otherwise. 
 *
 * Note that while doing this identification process, we update the values of
 * #fp20_EGalgMCgraph_t::cut, #fp20_EGalgMCgraph_t::cut_sz and #fp20_EGalgMCgraph_t::cut_val,
 * as well as performing the actual shrinking procedure.
 *
 * The original theorem (for local conditions on shrinking) is the following:
 * Let @f$ Z @f$ be a proper subset of @f$ V @f$ (the set of all nodes in the
 * graph), @f$ |Z|\geq2 @f$, and let 
 * @f[ P(Z) = \bigcup\left\{ N(u)\cap N(v):u\neq v, u,v\in Z \right\} @f]
 * where @f$ N(u) @f$ if the set of neighbours of @f$ u @f$. If there exists
 * @f$ Y\subseteq P(Z) @f$ such that for every nonempty proper subset @f$ W
 * @f$ of @f$ Z @f$ and for every @f$ T\subseteq Y @f$ either:
 * -# @f$ w(\delta(W))/2 \leq w(W:(Y-T)+(Z-W)) @f$ or
 * -# @f$ w(\delta(Z-W))/2 \leq w(Z-W:T+W) @f$.
 * Then there exists a minimum cut @f$(X:V-X)@f$ such that either @f$
 * Z\subseteq X @f$ or @f$ X\subseteq Z @f$.
 *
 * And the original theorem (in fact is the corollary 3.5 in the paper) 
 * regarding global conditions for shrinking is the following:
 * Let @f$ u\neq v\in V @f$, and let @f$ q @f$ be an upper bound on the
 * minimum cut value, and @f$ lb_{uv} @f$ be a lower bound in the value of a
 * minimum @f$ u-v @f$ cut, then if @f$ lb_{uv}\geq q @f$ the set 
 * @f$ \{u,v\} @f$ is shrinkable.
 * 
 * The actual tests that we perform (for every edge) are the following:
 * -# If @f$ w(\delta(u)) < @f$ #fp20_EGalgMCgraph_t::cut_val, update the minimum
 * cut value and set.
 * -# If @f$ w_{uv} \geq \min\{w(\delta(u)),w(\delta(v))\}/2 @f$ then we can 
 * safely shrink edge @f$ uv @f$.
 * -# If we have a triangle @f$ uv,\quad vw,\quad wu  @f$, with 
 * @f$ w_{uv} + w_{vw} \geq w(\delta(v))/2 @f$ and  
 * @f$ w_{uw} + w_{vw} \geq w(\delta(w))/2 @f$ then we can safely shrink edge
 * @f$ wv @f$.
 * -# Compute lower bound on the cut that separates the endpoints of the
 * current edge as :
 * @f[ lb_{uv}=w_{uv}+\sum\limits_{w\in N(u)\cap N(v)}\min\{w_{uw},w_{vw}\} @f]
 * If  @f$ lb_{uv} \geq  @f$ #fp20_EGalgMCgraph_t::cut_val , then we can shrink the edge  @f$ uv @f$.
 * -# Consider the edge @f$ uv @f$ and two common neighbours @f$ x,y @f$. If  
 * @f$ w_{ux} + w_{uy} + w_{uv} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{vx} + w_{vy} + w_{vu} \geq w(\delta(v))/2 @f$ and at least one of 
 * @f$ w_{uv} + w_{uy} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{uv} + w_{vx} \geq w(\delta(v))/2 @f$ and at least one of 
 * @f$ w_{uv} + w_{ux} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{uv} + w_{vy} \geq w(\delta(v))/2 @f$ then we can safely shrink edge
 * @f$ uv @f$.
 *
 * We make thiese tests in order, i.e. first we perform all level 1 tests,
 * then level2, and so on, and whenever two nodes are Identify (shrinked) we
 * set the level of the node to 1 (i.e. in the next test we will test the
 * first condition). This is done using an array of (5) lists, where all nodes
 * are distributed. Originally all nodes should be in the first lists (i.e.
 * all nodes should be tested to improve the current best cut by themselves).
 * */
int fp20_EGalgMCidentifyPRedges (fp20_EGalgMCgraph_t * const G,
														fp20_EGalgMCcbk_t * const cb,
														const unsigned int max_lvl);

/* ========================================================================= */
/** @brief Compute a minimum cut on the given graph. 
 * @param max_lvl set a limit on wich tests to perform during the
 * Padberg-Rinaldy shrinking step. for example, if set to
 * 1, only the first and second tests will be carried out.
 * @param G graph over wich we are working. 
 * @param cb call back structure to use (if set to NULL it is not used).
 * @return zero on success, non-zero otherwise. 
 *
 * This function takes as input a graph, and perform the minimum cut algorithm
 * as described in the paper "An Efficient 
 * Algorithm For The Minimum Capacity Cut Problem", Mathematical Programming
 * 47 (1990) pages 19-36. 
 *
 * Note that the graph should have all fields properly initialized.
 * */
int fp20_EGalgMC (fp20_EGalgMCgraph_t * const G,
						 fp20_EGalgMCcbk_t * const cb,
						 const unsigned int max_lvl);

/* ========================================================================= */
/** @} 
 * end fp20_eg_min_cut.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef fp20___EG_NUMUTIL_H__
#define fp20___EG_NUMUTIL_H__

/* ========================================================================= */
/** @defgroup EGlpNumUtil General Number Utilities
 * Here we put some utilities common for different number types but thaat we
 * want to implement as templates, like permutation sorting, inner product of
 * vectors, and so-on..
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2007-10-08
 *  					- Separate template file and independet file into eg_nummacros.h
 *  					- Move EGabs, EGswap, EGmin and EGmax to this file
 *  - 2005-10-31
 *  					- First implementation.
 * */
/** @{*/
/** @file
 * @brief This file provide the user interface and function definitions for
 * general number utilities.
 * */
/* ========================================================================= */
/** @brief compute the inner product of two arrays.
 * @param arr1 first array.
 * @param arr2 second array.
 * @param length number of entries to consider in both arrays, from zero to
 * length - 1.
 * @param rop where to store the result.
 * */
#define fp20_EGlpNumInnProd(__rop,__arr1,__arr2,__length) fp20___EGlpNumInnProd((&(__rop)),__arr1,__arr2,__length)
/* ========================================================================= */
/** @brief internal version, this is done to avoid using stdc99 and rely on
 * more basic stdc89 */
void fp20___EGlpNumInnProd(EGfp20_t*rop,EGfp20_t*const arr1,EGfp20_t*const arr2, const size_t length);
/* ========================================================================= */
/** @brief Sort (in increasing order) a sub-set of entries in an array using 
 * quicksort, by permutating the order of the elements in the subset rather 
 * than in the whole original array.
 * @param sz length of the permutation array.
 * @param perm array of indices of elements that we want to sort.
 * @param elem array (of length at least max(perm[k]:k=0,...,sz-1)) containing
 * the elements to be sorted.
 * @note The array of elements is not changed by this function.
 * @note This code is based in concorde's implementation of
 * permutation-quick-sort.
 * */
void fp20_EGutilPermSort (const size_t sz,
										 int *const perm,
										 const EGfp20_t * const elem);

/* ========================================================================= */
/** @brief Sort (in decreasing order) a sub-set of entries in an array using 
 * quicksort, by permutating the order of the elements in the subset rather 
 * than in the whole original array.
 * @param sz length of the permutation array.
 * @param perm array of indices of elements that we want to sort.
 * @param elem array (of length at least max(perm[k]:k=0,...,sz-1)) containing
 * the elements to be sorted.
 * @note The array of elements is not changed by this function.
 * @note This code is based in concorde's implementation of
 * permutation-quick-sort.
 * */
void fp20_EGutilPermSort2 (const size_t sz,
										 int*const perm,
										 const EGfp20_t*const elem);

/* ========================================================================= */
/** @}*/
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgDijkstra EGalgDijkstra
 * Dijkstra implementation with 2-heaps
 * */
/** @file
 * @ingroup EGalgDijkstra */
/** @addtogroup EGalgDijkstra */
/** @{ */
/** @example fp20_eg_dijkstra.ex.c */
/* ========================================================================= */
#ifndef fp20___EG_DIJKSTRA_H
#define fp20___EG_DIJKSTRA_H
/* ========================================================================= */
/** @brief Verbosity Level */
#define fp20_DJK_VRBLVL_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define fp20_DJK_DEBUG_ 100

/* ========================================================================= */
/** @brief implement dijkstra.
 * */
int fp20_EGalgDJK (
		int32_t const nnodes,
		int32_t const nedges,
		int32_t const*const ou_d,
		int32_t const*const ou_beg,
		int32_t const*const ou_e,
		EGfp20_t const*const weight,
		int32_t const s,
		int32_t const nt,
		int32_t const*const t,
		int32_t*const father,
		EGfp20_t*const dist
		);

/* ========================================================================= */
/** @brief read from a file in .x format (as in the concorde's .x files), the
 * format is as follows:
 * nnodes nedges
 * tail_1 head_1 weight_1
 * ...    ...    ....
 * tail_nnodes head_nnodes weight_nnodes
 * comments are allowed, if they start with % or #.
 * @param input file containing the data
 * @param n where to store the number of nodes
 * @param m where to store the number of edges
 * @param edges pointer to an array where to store the edges, note that memory
 * will be allocated in (*edges)
 * @param weight pointer to the array where we will store the weights, note
 * that this array will be allocated using fp20_EGlpNumAllocArray, and should be
 * deallocated using fp20_EGlpNumFreeArray.
 * @return zero on success, non-zero otherwise 
 * */
int fp20_EGguReadXgraph(
		EGioFile_t*const input,
		int32_t*const n,
		int32_t*const m,
		int32_t**const edges,
		EGfp20_t**const weight);
/* ========================================================================= */
/** @} 
 * end fp20_eg_dijkstra.h */
#endif

/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef int___EG_DMATRIX_H__
#define int___EG_DMATRIX_H__

/* ========================================================================= */
/** @defgroup EGdMatrix Dense Matrices
 * Here we define a common interface for dense matrices (i.e. a structure), and
 * some common operations over dense matrices. The definition uses EGlpNum as
 * reference number type, this allow for template initializations.
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2005-10-27
 *  					- First implementation.
 * */
/** @{*/
/** @file
 * @brief This file provide the user interface and function definitions for
 * Dense Matrices.
 * */
/** @example int_eg_dmatrix.ex.c */
/* ========================================================================= */
/** @brief structure to hold a dense matrix, we choose a row representation
 * of the matrix, and we allow row and column permutations. All actual values 
 * in the matrix are stored in #int_EGdMatrix_t::matval, and the rows in
 * #int_EGdMatrix_t::matrow. */
typedef struct int_EGdMatrix_t
{
	size_t col_sz;		/**< @brief Number of columns in the matrix. */
	size_t row_sz;		/**< @brief Number of rows in the matrix */
	int **matrow;
										/**< @brief Array of size #int_EGdMatrix_t::row_sz containing 
												 all rows of the matrix */
	int *matval;/**< @brief Values for all entries */
	int *col_ord;			/**< @brief Array of size at least #int_EGdMatrix_t::col_sz 
												 containing the order ammong all columns i.e. it is a 
												 permutation of {0,....,col_sz-1} which is how the 
												 matrix is treated internally */
	int *row_ord;			/**< @brief Array of size at least #int_EGdMatrix_t::row_sz 
												 containing the order ammong all rows, i.e. it is a 
												 permutation of {0,...,row_sz-1} which is how the 
												 matrix is treated internally */
}
int_EGdMatrix_t;

/* ========================================================================= */
/** @brief Initialize (as a dense matrix of dimension 0x0) an #int_EGdMatrix_t
 * structure.
 * @param __dmatrix dense matrix structure pointer.
 * */
#define int_EGdMatrixInit(__dmatrix) memset(__dmatrix,0,sizeof(int_EGdMatrix_t))

/* ========================================================================= */
/** @brief Clear a dense matrix structure, i.e. free all internally allocated
 * data of the structure. Note that no further use of the structure can be made
 * unless it is re-initialized and set to a suitable size.
 * @param __dmatrix dense matrix structure pointer.
 * */
#define int_EGdMatrixClear(__dmatrix) do{\
	int_EGdMatrix_t*const __EGdm = (__dmatrix);\
	int_EGlpNumFreeArray(__EGdm->matval);\
	EGfree(__EGdm->matrow);\
	int_EGlpNumFreeArray(__EGdm->col_ord);\
	int_EGlpNumFreeArray(__EGdm->row_ord);} while(0)

/* ========================================================================= */
/** @brief Set new dimensions for a dense matrix structure.
 * @param __dmatrix dense matrix structure pointer.
 * @param __nnewrows number of rows in the matrix.
 * @param __nnewcols number of columns in the matrix.
 * @note Take care that the values stored in the matrix are not initialized to
 * any particular number. Also the ordering (for both column and row) is reset
 * to the standard ordering 0,....,n.
 * */
#define int_EGdMatrixSetDimension(__dmatrix,__nnewrows,__nnewcols) do{\
	int_EGdMatrix_t*const __EGdm = (__dmatrix);\
	register int __EGdmi;\
	__EGdm->col_sz = (__nnewcols);\
	__EGdm->row_sz = (__nnewrows);\
	int_EGlpNumReallocArray(&(__EGdm->matval),__EGdm->col_sz * __EGdm->row_sz);\
	EGrealloc(__EGdm->matrow,__EGdm->row_sz * sizeof(int*));\
	int_EGlpNumReallocArray(&(__EGdm->col_ord),__EGdm->col_sz);\
	int_EGlpNumReallocArray(&(__EGdm->row_ord),__EGdm->row_sz);\
	__EGdmi = (int)(__EGdm->col_sz);\
	while(__EGdmi--) __EGdm->col_ord[__EGdmi] = __EGdmi;\
	__EGdmi = (int)(__EGdm->row_sz);\
	while(__EGdmi--) \
		__EGdm->matrow[__EGdmi] = __EGdm->matval + ((size_t)(__EGdmi) * __EGdm->col_sz);\
	__EGdmi = (int)(__EGdm->row_sz);\
	while(__EGdmi--) __EGdm->row_ord[__EGdmi] = __EGdmi;} while(0)

/* ========================================================================= */
/** @brief Display a given #int_EGdMatrix_t structure contents.
 * @param __dmatrix dense matrix structure pointer.
 * @param __nat_order if set to one, display the matrix using the natural 
 * internal order, i.e. we discard the order of columns and rows as defined in
 * #int_EGdMatrix_t::col_ord and #int_EGdMatrix_t::row_ord. Otherwise, use such orders.
 * @param __ofile pointer to a FILE structure where we want the output to be
 * printed.
 * */
#define int_EGdMatrixDisplay(__dmatrix,__nat_order,__ofile) do{\
	int_EGdMatrix_t*const __EGdm = (__dmatrix);\
	char* __EGdmstr = 0;\
	size_t __EGdmi, __EGdmj;\
	fprintf(__ofile,"Matrix %p\nDimensions: %zd rows, %zd columns\n", (void*)__EGdm, __EGdm->row_sz, __EGdm->col_sz);\
	if(__nat_order){\
		for(__EGdmi = 0 ; __EGdmi < __EGdm->row_sz ; __EGdmi++){\
			for(__EGdmj = 0 ; __EGdmj < __EGdm->col_sz ; __EGdmj++){\
				__EGdmstr = int_EGlpNumGetStr(__EGdm->matrow[__EGdmi][__EGdmj]);\
				fprintf(__ofile,"%10s ", __EGdmstr);\
				EGfree(__EGdmstr);\
			}\
			fprintf(__ofile,"\n");}\
	} else {\
		for(__EGdmi = 0 ; __EGdmi < __EGdm->row_sz ; __EGdmi++){\
			for(__EGdmj = 0 ; __EGdmj < __EGdm->col_sz ; __EGdmj++){\
				__EGdmstr = int_EGlpNumGetStr(__EGdm->matrow[__EGdm->row_ord[__EGdmi]][__EGdm->col_ord[__EGdmj]]);\
				fprintf(__ofile,"%10s ", __EGdmstr);\
				EGfree(__EGdmstr);\
			}\
			fprintf(__ofile,"\n");}\
	}} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set rows 
 * '__dest' to '__dest' + '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in row '__dest', and note that rows '__orig' and '__dest' should be different.
 * This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the row whose multiple will be added to the '__dest'
 * row.
 * @param '__dest' row to be replaced by '__dest' + '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' row.
 * @note The index of the row are taken as internal index, i.e. if we give row
 * 'k' we will use the row stored in #int_EGdMatrix_t::matrow[k], wich does not
 * mean that we will access the k-th row in the matrix (wich would need to use
 * as index the value #int_EGdMatrix_t::row_ord[k] instead). Note that we don't
 * test wether the given multiple is zero or not. we always perform the
 * operation.
 * */
#define int_EGdMatrixAddRowMultiple(__dmatrix,__dest,__orig,__num) do{\
	int_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (size_t)(__dest);\
	const size_t __EGori = (size_t)(__orig);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) \
		int_EGlpNumAddInnProdTo(__EGdm->matrow[__EGdest][__EGdmj],\
												__EGdm->matrow[__EGori][__EGdmj],__num);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set rows 
 * '__dest' to '__dest' - '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in row '__dest', and note that rows '__orig' and '__dest' should be different.
 * This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the row whose multiple will be added to the '__dest'
 * row.
 * @param '__dest' row to be replaced by '__dest' - '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' row.
 * @note The index of the row are taken as internal index, i.e. if we give row
 * 'k' we will use the row stored in #int_EGdMatrix_t::matrow[k], wich does not
 * mean that we will access the k-th row in the matrix (wich would need to use
 * as index the value #int_EGdMatrix_t::row_ord[k] instead). Note that we don't
 * test wether the given multiple is zero or not. we always perform the
 * operation.
 * */
#define int_EGdMatrixSubRowMultiple(__dmatrix,__dest,__orig,__num) do{\
	int_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (__dest);\
	const size_t __EGori = (__orig);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) \
		int_EGlpNumSubInnProdTo(__EGdm->matrow[__EGdest][__EGdmj],\
												__EGdm->matrow[__EGori][__EGdmj],__num);\
	} while(0)
/* ========================================================================= */
/** @brief Given a number and a row, multiply the complete row by the given
 * number. Note that the number MUST_NOT be stored in the row being multiplied,
 * this is because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param row_ind index of the row being multiplied, note that we will multiply
 * the row stored in #int_EGdMatrix_t::matrow[row_ind], wich is different to say
 * that we multiply the row in the row_ind-th position in the row ordering (to
 * do that, then row_ind should be #int_EGdMatrix_t::row_ord[k]).
 * @param multiple constant to be multiply to the row.
 * */
#define int_EGdMatrixMultiplyRow(__dmatrix,row_ind,multiple) do{\
	int_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdmi = (row_ind);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) int_EGlpNumMultTo(__EGdm->matrow[__EGdmi][__EGdmj],multiple);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set columns 
 * '__dest' to '__dest' + '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in column '__dest', and note that columns '__orig' and '__dest' should be 
 * different. This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the column whose multiple will be added to the '__dest'
 * column.
 * @param '__dest' column to be replaced by '__dest' + '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' column.
 * @note The index of the column are taken as internal index, i.e. if we give 
 * column 'k' we will use the column stored in #int_EGdMatrix_t::matrow[*][k], 
 * wich does not mean that we will access the k-th column in the matrix (wich
 * would need to use as index the value #int_EGdMatrix_t::row_ord[k] instead). 
 * Note that we don't test wether the given multiple is zero or not. we 
 * always perform the operation.
 * */
#define int_EGdMatrixAddColMultiple(__dmatrix,__dest,__orig,__num) do{\
	int_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (__dest);\
	const size_t __EGori = (__orig);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) \
		int_EGlpNumAddInnProdTo(__EGdm->matrow[__EGdmj][__EGdest],\
												__EGdm->matrow[__EGdmj][__EGori],__num);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set columns 
 * '__dest' to '__dest' - '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in column '__dest', and note that columns '__orig' and '__dest' should be 
 * different. This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the column whose multiple will be added to the '__dest'
 * column.
 * @param '__dest' column to be replaced by '__dest' - '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' column.
 * @note The index of the column are taken as internal index, i.e. if we give 
 * column 'k' we will use the column stored in #int_EGdMatrix_t::matrow[*][k], 
 * wich does not mean that we will access the k-th column in the matrix (wich 
 * would need to use as index the value #int_EGdMatrix_t::col_ord[k] instead). 
 * Note that we don't test wether the given multiple is zero or not. we 
 * always perform the operation.
 * */
#define int_EGdMatrixSubColMultiple(__dmatrix,__dest,__orig,__num) do{\
	int_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (size_t)(__dest);\
	const size_t __EGori = (size_t)(__orig);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) \
		int_EGlpNumSubInnProdTo(__EGdm->matrow[__EGdmj][__EGdest],\
												__EGdm->matrow[__EGdmj][__EGori],__num);\
	} while(0)
/* ========================================================================= */
/** @brief Given a number and a column, multiply the complete column by the 
 * given number. Note that the number MUST_NOT be stored in the column being 
 * multiplied, this is because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param __colind index of the column being multiplied, note that we will 
 * multiply the column stored in #int_EGdMatrix_t::matrow[*][__colind], wich is 
 * different to say that we multiply the column in the __colind-th position in
 * the column ordering (to do that, then __colind should be 
 * #int_EGdMatrix_t::col_ord[k]).
 * @param __mult constant to be multiply to the column.
 * */
#define int_EGdMatrixMultiplyCol(__dmatrix,__colind,__mult) do{\
	int_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdmi = (__colind);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) int_EGlpNumMultTo(__EGdm->matrow[__EGdmj][__EGdmi],__mult);\
	} while(0)


/* ========================================================================= */
/** @brief This function performs gaussian elimination to the given matrix,
 * depending on the given options it may do row/columns permutations allong the
 * way to improve numerical stabillity.
 * @param __dmatrix dense matrix structure pointer.
 * @param do_col_perm if set to one, the try columns permutation to improve
 * numericall stabillity, otherwise, not do column permutations at all.
 * @param do_row_perm if set to one, try row permutations to improve numericall
 * stabillity, otherwise, not do row permutations at all.
 * @param status pointer to where return an status, if the procedure finish all
 * the way (i.e. the matrix is full rank), then we return #EG_ALGSTAT_SUCCESS,
 * if the matrix is found to be partial rank, the status is
 * #EG_ALGSTAT_PARTIAL, otherwise, we return #EG_ALGSTAT_NUMERROR, wich means
 * that we stoped because a zero pivot was found (after checking for allowed
 * row/collumns permmutations).
 * @param rank where to return the (proven) rank of the matrix. This number is
 * accurate if the status is #EG_ALGSTAT_SUCCESS, or #EG_ALGSTAT_PARTIAL, but
 * is just a lower bound if the status is #EG_ALGSTAT_NUMERROR
 * @param zero_tol What is the threshold for a value to be considered zero.
 * @return if no error happen, we return zero, otherwise a non-zero valued is
 * returned. Note that the algorithm status is independent of the return value,
 * non zero values araise only if an error happen during execution, wich is
 * different to say that the algorithm didn't finish correctly. */
int int_EGdMatrixGaussianElimination (int_EGdMatrix_t * const __dmatrix,
																	const unsigned do_col_perm,
																	const unsigned do_row_perm,
																	unsigned *const rank,
																	const int zero_tol,
																	int *const status);

/* ========================================================================= */
/** @}*/
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef int___EG_DBASIS_REDUCTION__
#define int___EG_DBASIS_REDUCTION__
/* ========================================================================= */
/** @defgroup EGdBasisRed LLL Basis Reduction
 * Here we define a common interface for dense matrices (i.e. a structure), and
 * some common operations over dense matrices. The definition uses EGlpNum as
 * reference number type, this allow for template initializations.
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2005-10-28
 *  					- First implementation.
 * */
/**  @{ */
/** @file
 * @brief This file provide the user interface and function definitions for
 * the so-called LLL Basis Reduction Algorithm. This algorithm was first
 * presented in the paper "Factoring polynomials with rational coefficients",
 * Mathematische Annalen 261 (1981), p515-534. and has been extensivelly
 * studied elsewere. for more details just Google-it.
 * */
/** @example int_eg_dmatrix.ex.c */
/* ========================================================================= */
/** @brief verbosity level */
#define int_EG_DBSRED_VERBOSE 0

/* ========================================================================= */
/** @name Profiling structures and functions for the basis reduction algorithm.
 * */
/* @{ */
/* ========================================================================= */
/** @brief where to hold the profile information */
extern uintmax_t int_EGdBsRedStats[10];

/* ========================================================================= */
/** @brief where we store the number of calls to #int_EGdBsRed */
#define int_EG_BSRED_CALLS 0

/* ========================================================================= */
/** @brief where we store the total number of size reductions performed in 
 * #int_EGdBsRed */
#define int_EG_BSRED_SZRED 1

/* ========================================================================= */
/** @brief where we store the total number of interchanges performed in 
 * #int_EGdBsRed */
#define int_EG_BSRED_INTR 2

/* ========================================================================= */
/** @brief where we store the total number of innermost loops performed in 
 * #int_EGdBsRed */
#define int_EG_BSRED_ITT 3

/* ========================================================================= */
/** @brief Print into the given file stream, the current statistics related
 * to the #int_EGdBsRed algorithm. And reset all counters to zero.
 * @param __ofile where we want to print the profile information. */
#define int_EGdBsRedProfile(__ofile) do{\
	fprintf(__ofile,"LLL Basis Reduction Statistics:\n");\
	fprintf(__ofile,"\tNumber Calls    : %ju\n", int_EGdBsRedStats[int_EG_BSRED_CALLS]);\
	fprintf(__ofile,"\tLoops           : %ju\n", int_EGdBsRedStats[int_EG_BSRED_ITT]);\
	fprintf(__ofile,"\tSize Reductions : %ju\n", int_EGdBsRedStats[int_EG_BSRED_SZRED]);\
	fprintf(__ofile,"\tInterchanges    : %ju\n", int_EGdBsRedStats[int_EG_BSRED_INTR]);\
	memset(int_EGdBsRedStats,0,sizeof(int_EGdBsRedStats));} while(0)

/* @} */

/* ========================================================================= */
/** @brief Value used in condition two of the LLL algorithm, remember that this
 * number should be between \f$(1/4,1)\f$. By default we choose \f$\lambda =
 * \frac{2^{20}-1}{2^{20}} \approx .99999904632568359375 \f$. */
#define int_EG_DBSRED_ALPHA 0x7ffffp-20

/* ========================================================================= */
/** @brief structure to hold all necesary data to perform the LLL's basis
 * reduction algorithm. */
typedef struct int_EGdBsRed_t
{
	size_t dim;				/**< @brief Number of elements in the basis */
	size_t length;		/**< @brief Length of the vectors in the basis, note that
												 it should be that length >= dim */
	size_t basis_sz;	/**< @brief Actual length of the #int_EGdBsRed_t::basis 
												 array */
	int **basis;/**< @brief array of pointers to arrays containing the 
												 vector basis in extended (including zero coef) form. 
												 The vectors themselves are considered as allocated 
												 outside. everything else is considered as internally
												 allocated. */
	int_EGdMatrix_t GM;		/**< @brief Here we store and compute the Gram-Schmidt 
												 needed for the LLL basis reduction algorithm */
}
int_EGdBsRed_t;

/* ========================================================================= */
/** @brief Initialize an #int_EGdBsRed_t structure, as a basis with zero elements
 * of dimension zero.
 * @param __bsred pointer to an #int_EGdBsRed_t structure.
 * */
#define int_EGdBsRedInit(__bsred) do{\
	int_EGdBsRed_t*const __EGdbs = (__bsred);\
	memset(__EGdbs,0,sizeof(int_EGdBsRed_t));\
	int_EGdMatrixInit(&(__EGdbs->GM));} while(0)

/* ========================================================================= */
/** @brief Free any internally allocated memory in a #int_EGdBsRed_t structure.
 * @param __bsred pointer to an #int_EGdBsRed_t structure.
 * */
#define int_EGdBsRedClear(__bsred) do{\
	int_EGdBsRed_t*const __EGdbs = (__bsred);\
	if(__EGdbs->basis) EGfree(__EGdbs->basis);\
	int_EGdMatrixClear(&(__EGdbs->GM));} while(0)

/* ========================================================================= */
/** @brief reset an #int_EGdBsRed_t structure as a basis without elements (note
 * that we do not reset the length of the vectors, just the number of vectors 
 * in the basis).
 * @param __bsred pointer to an #int_EGdBsRed_t structure.
 * */
#define int_EGdBsRedReset(__bsred) ((__bsred)->dim = 0)

/* ========================================================================= */
/** @brief set the length of the vectors used in the basis for an #int_EGdBsRed_t
 * structure.
 * @param __bsred pointer to an #int_EGdBsRed_t structure.
 * @param __new_length length of the vectors in the basis.
 * */
#define int_EGdBsRedSetLength(__bsred,__new_length) ((__bsred)->length = (__new_length))

/* ========================================================================= */
/** @brief add a new vector to the basis.
 * @param __bsred pointer to an #int_EGdBsRed_t structure.
 * @param __new_elem new vector to add to the basis.
 * */
#define int_EGdBsRedAddElement(__bsred,__new_elem) do{\
	int_EGdBsRed_t*const __EGdbs = (__bsred);\
	if(__EGdbs->basis_sz <= __EGdbs->dim){\
		__EGdbs->basis_sz += 10U;\
		EGrealloc(__EGdbs->basis,sizeof(int*)*__EGdbs->basis_sz);}\
	__EGdbs->basis[__EGdbs->dim++] = (__new_elem);} while(0)

/* ========================================================================= */
/** @brief This function performs the so-called LLL basis reduction algorithm.
 * @param __bsred pointer to an #int_EGdBsRed_t structure.
 * @param status where we return the status of the algorithm, if the algorithm
 * finish with non-zero reduced elements, the status is #EG_ALGSTAT_SUCCESS. if
 * the algorithm finish with some zero reduced vector, the status is
 * #EG_ALGSTAT_PARTIAL. if the algorithm stop because of numerical problems,
 * the status is #EG_ALGSTAT_NUMERROR.
 * @param zero_tol threshold for a number to be considered as zero.
 * @param dim pointer to a number where we return the dimension of the basis
 * that the algorithm could prove before running in any numerical problem. If
 * the algorithm stop with status #EG_ALGSTAT_SUCCESS, then this number should
 * be equal to #int_EGdBsRed_t::dim. The vectors that we finish reducing are stored
 * in #int_EGdMatrix_t::row_ord[0], ... , #int_EGdMatrix_t::row_ord[dim], in the
 * #int_EGdBsRed_t::GM matrix.
 * @return zero if the algorithm finish, non-zero if an unforeseen error occure
 * during execution. 
 * @par Details:
 * The implementation that we use introduce (as an heuristic step) the sorting
 * of the original basis vectors in increasing order according to their norms,
 * this simple step reduced the total running time of the algorithm, but does
 * not improve the theoretical running time. A second detail is that we only
 * compute the Gram-Schmidth coefficients only once (at the beggining of the
 * program), and then, we only update the changed entries for both operations
 * \a size \a reduction and \a interchange. The advantage of the approach is
 * that we save most Gram-Schmidth computations and also all the recomputations
 * of the inner products of the elements currently in the basis. Again, this
 * are improvements form the practical point of view, but not in practice. The
 * dissadvantage of this approach is that we do accumulate rounding errors in
 * the Gram-Schmidth coefficients allong the way, but if all original vectors
 * coefficients where integer (and not too big), then the error should not grow
 * too much. Still this may happen if the input basis is ill conditioned.
 * */
int int_EGdBsRed (int_EGdBsRed_t * const __bsred,
							unsigned *const dim,
							const int zero_tol,
							int *const status);

/* ========================================================================= */
/**  @} */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGeHeap EGeHeap
 *
 * Here we define the basic interface for d-heaps as an embeded structure.
 * In this implementation the heap does not grow on the fly, meaning that it 
 * may fills-up during an add call, to avoid that, the user must call 
 * re-allocate when necesary. the heap start as a heap of size zero. 
 * This implementatioon is a minimum-heap implementatiton. Note also that the
 * internal connector array is shifted one position to the left. This is done 
 * so that the first element is in position 1, this also speed-up the 
 * computation of the parent and childrens of a given position.
 *
 * @version 0.0.1
 * @par History:
 * - 2010-09-05
 * 						- int_EGeHeapClear will free any internal memory (even if it was
 * 						asked for by the user).
 * - 2005-07-14
 * 						- Add int_EGeHeapEmpty to empty the heap (but keep its maximum
 * 							size)
 * 						- Add int_EGeHeapIsFull to test wether a heap is full or not.
 * - 2005-07-07
 * 						- First Implementation
 * @note 
 * This implementatiton is designed as a template using as base the types of
 * @ref EGlpNum
 * */
/** @file 
 * @ingroup EGeHeap */
/** @addtogroup EGeHeap */
/** @{ */
/** @example int_eg_eheap.ex.c
 * This is a simple example of the usage of heaps using @ref EGeHeap */
/* ========================================================================= */
#ifndef int___EG_EHEAP__
#define int___EG_EHEAP__
/* ========================================================================= */
/** @brief Debug level for the heap */
#ifndef int_EG_EHEAP_DEBUG
#define int_EG_EHEAP_DEBUG 1000
#endif

/* ========================================================================= */
/** @name Test macros, enabled only if debug level is high enough. */
/** @{ */
#if int_EG_EHEAP_DEBUG <= DEBUG
#define int_EGeHeapCHECK_CN(__hp2,__hcn2) EXIT(__hcn2->pos>=__hp2->sz,"Heap Connector possition %d out of range [0,%d]",__hcn2->pos,__hp2->sz)
#define int_EGeHeapCHECK_NF(__hp2) EXIT(__hp2->sz >= __hp2->max_sz,"Heap "#__hp2" Is full, can't add an element")
#else
#define int_EGeHeapCHECK_CN(__hp,__hcn) 
#define int_EGeHeapCHECK_NF(__hp) 
#endif
/** @} */
/* ========================================================================= */
/** @brief Structure to store the information relevant to an element in the
 * heap. */
typedef struct 
{
	int val;		/**< Value of this node in the heap */
	unsigned int pos;	/**< Position in the heap array for this node, if set to
												 #int_EG_EHEAP_POISON, then the connector is not in any 
												 heap.*/
}
int_EGeHeapCn_t;

/* ========================================================================= */
/** @brief Poison position for heap connector not in a heap. */
#define int_EG_EHEAP_POISON UINT_MAX

/* ========================================================================= */
/** @brief Initialize a heap conector structure. This function will allocate any
 * interal memory not allocated by the user, it should be called only once, or
 * after a clear function call.
 * @param __hcn conector to initialize.
 * */
#define int_EGeHeapCnInit(__hcn) ({int_EGlpNumInitVar((__hcn)->val);(__hcn)->pos = int_EG_EHEAP_POISON;})

/* ========================================================================= */
/** @brief Reset a heap conector to the same state as after an init call, this
 * function is provided only for completness.
 * @param __hcn conector to reset
 * */
#define int_EGeHeapCnReset(__hcn) ((__hcn)->pos = int_EG_EHEAP_POISON)

/* ========================================================================= */
/** @brief Free all internal memory used by this structured not allocated by the
 * user. This function should be called after an init call, and only once.
 * @param __hcn conector to clear.
 * */
#define int_EGeHeapCnClear(__hcn) int_EGlpNumClearVar((__hcn)->val)

/* ========================================================================= */
/** @brief Structure to hold a whole heap structure, this structure is designed
 * so that it can grow on the fly with a low cost */
typedef struct 
{
	int_EGeHeapCn_t **cn;
	unsigned int d;
	unsigned int sz;
	unsigned int max_sz;
}
int_EGeHeap_t;

/* ========================================================================= */
/** @brief Return one if the heap is full, zero otherwise.
 * @param __hp heat to check */
#define int_EGeHeapIsFull(__hp) ({int_EGeHeap_t*const __EGehp = (__hp); __EGehp->sz == __EGehp->max_sz;})

/* ========================================================================= */
/** @brief set the number of elements in hte heap to zero.
 * @param __hp heap to empty.
 * */
#define int_EGeHeapEmpty(__hp) ((__hp)->sz = 0)

/* ========================================================================= */
/** @brief Initialize a heap as an empty heap (with no space for conectors).
 * @param __hp heap to initialize.
 * */
#define int_EGeHeapInit(__hp) (*(__hp) = (int_EGeHeap_t){0,0,0,0})

/* ========================================================================= */
/** @brief Reset the given heap as an empty heap (just as returned by the init
 * call.
 * @param __hp heap to reset 
 * */
#define int_EGeHepReset(__hp) int_EGeHeapResize(__hp,0)

/* ========================================================================= */
/** @brief Clear a heap structure, and free any internal memory (not allocated
 * by the user).
 * @param __hp heap to clear.
 * */
#define int_EGeHeapClear(__hp) int_EGeHeapResize(__hp,0)

/* ========================================================================= */
/** @brief get the minimum value in the heap.
 * @param __hp heap where we are working.
 * @param number where to store the result
 * @return zero on success, non-zero otherwise.
 * */
#define int_EGeHeapGetMinVal(__hp,number) ({\
	int_EGeHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? (int_EGlpNumCopy(number,__EGehp->cn[0]->val),0):1;})

/* ========================================================================= */
/** @brief get the minimum conector in the heap, if the heap is empty, return
 * NULL.
 * @param __hp eap where we are working.
 * @return pointer to the minimum element in the heap.
 * */
#define int_EGeHeapGetMin(__hp) ({\
	int_EGeHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? __EGehp->cn[0] : 0;})

/* ========================================================================= */
/** @brief resize the heap cn array to the given size, if the new size is zero,
 * it is equivalent to free the internal memory, and left the heap as an empty
 * heap with zero space.
 * @param __hp heap where we are working.
 * @param new_sz new size for the  cn array .
 * */
#define int_EGeHeapResize(__hp,new_sz) ({\
	int_EGeHeap_t*const __EGehp = (__hp);\
	const size_t __EGehp_nsz = (size_t)(new_sz);\
	__EGehp->cn = EGrealloc((__EGehp->cn), __EGehp_nsz * sizeof(int_EGeHeapCn_t*));\
	__EGehp->max_sz = (unsigned int)(__EGehp_nsz);})

/* ========================================================================= */
/** @brief return the index of the father of the given index.
 * @param __d breadth of the heap.
 * @param __id position in the array to wich we want to compute it's father.
 * */
#define int_EGeHeapFatherId(__d,__id) ((__id)?(((__id)-1)/(__d)):0)

/* ========================================================================= */
/** @brief move an element in the heap up in the heap (position 0 is the top,
 * this kind of move is neded whenever we decrease the value in a heap element).
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * */
#define int_EGeHeapSiftUp(__hp,__hcn) ({\
	int_EGeHeap_t*const __EGehp = (__hp);\
	int_EGeHeapCn_t*const __EGecn = (__hcn);\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfpos = int_EGeHeapFatherId(__EGehp->d,__EGcpos);\
	int_EGeHeapCn_t*__EGfcn = __EGehp->cn[__EGfpos];\
	int_EGeHeapCHECK_CN(__EHehp,__EGecn);\
	while(__EGcpos && \
				int_EGlpNumIsLess(__EGecn->val,__EGfcn->val))\
	{\
		__EGfcn->pos = __EGcpos;\
		__EGehp->cn[__EGcpos] = __EGfcn;\
		__EGcpos = __EGfpos;\
		__EGfpos = int_EGeHeapFatherId(__EGehp->d,__EGcpos);\
		__EGfcn = __EGehp->cn[__EGfpos];\
	}\
	__EGecn->pos = __EGcpos;\
	__EGehp->cn[__EGcpos] = __EGecn;\
	0;})

/* ========================================================================= */
/** @brief Add an element to the heap
 * @param __hp heap where to add the element.
 * @param __hcn element to be added.
 * @return zero on success, non-zero otherwise.
 * */
#define int_EGeHeapAdd(__hp,__hcn) ({\
	int_EGeHeap_t*const __EGlhp = (__hp);\
	int_EGeHeapCn_t*const __EGlcn = (__hcn);\
	int_EGeHeapCHECK_NF(__EGlhp);\
	__EGlcn->pos = __EGlhp->sz, \
	__EGlhp->cn[__EGlhp->sz] = __EGlcn;\
	__EGlhp->sz +=1, \
	int_EGeHeapSiftUp(__EGlhp,__EGlcn), 0;})

/* ========================================================================= */
/** @brief Give the first child for a given position.
 * @param __id position that we want to get the first child.
 * @param __d breath of the heap. */
#define int_EGeHeapFirstChildId(__d,__id) ((__d)*(__id)+1)

/* ========================================================================= */
/** @brief Move an element down in the heap (position 0 is the
 * top), this kind of operation is needed whenever we increase the value in a
 * heap element.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define int_EGeHeapSiftDown(__hp,__hcn) ({\
	int_EGeHeap_t*const __EGehp = (__hp);\
	int_EGeHeapCn_t*const __EGecn = (__hcn);\
	const unsigned int __EGhsz = __EGehp->sz;\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfchd = int_EGeHeapFirstChildId(__EGehp->d,__EGcpos);\
	unsigned int __EGlchd = __EGfchd + __EGehp->d;\
	int_EGeHeapCn_t*__EGcchd = 0;\
	register unsigned int __EGehi = 0;\
	int_EGeHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGfchd < __EGhsz)\
	{\
		/* detect the minimum child */\
		__EGcchd = __EGehp->cn[__EGfchd];\
		for(__EGehi = __EGlchd > __EGhsz ? __EGhsz-1 : __EGlchd-1 ;\
			__EGehi > __EGfchd ; __EGehi--)\
			if(int_EGlpNumIsLess(__EGehp->cn[__EGehi]->val,__EGcchd->val))\
				__EGcchd = __EGehp->cn[__EGehi];\
		/* if the minimum child is less than the current position, move the minimum\
		 * child to the position of the current element */\
		if(int_EGlpNumIsLess(__EGcchd->val,__EGecn->val))\
		{\
			__EGfchd = __EGcchd->pos;\
			__EGcchd->pos = __EGcpos;\
			__EGehp->cn[__EGcpos] = __EGcchd;\
			__EGecn->pos = __EGcpos = __EGfchd;\
			__EGehp->cn[__EGcpos] = __EGecn;\
			__EGfchd = int_EGeHeapFirstChildId(__EGehp->d,__EGcpos);\
			__EGlchd = __EGfchd + __EGehp->d;\
		}\
		/* else we exit the main loop */\
		else __EGfchd = UINT_MAX;\
	}\
	0;})

/* ========================================================================= */
/** @brief Change the value of an element in the heap.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap that we are going to change it's value.
 * @param __new_val new value for the element.
 * @return zero on success, non-zero otherwise.
 * */
#define int_EGeHeapChangeVal(__hp,__hcn,__new_val) ({\
	(int_EGlpNumIsLess(__new_val,(__hcn)->val)) ? (int_EGlpNumCopy((__hcn)->val,__new_val),int_EGeHeapSiftUp(__hp,__hcn)) : (int_EGlpNumCopy((__hcn)->val,__new_val),int_EGeHeapSiftDown(__hp,__hcn));})

/* ========================================================================= */
/** @brief Eliminate an element from the heap, note that the position stored in
 * the eliminated element is reset to zero.
 * @param __hp heap where we are working.
 * @param __hcn element to eliminate from the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define int_EGeHeapDel(__hp,__hcn) ({\
	int_EGeHeap_t*const __EGlhp = (__hp);\
	int_EGeHeapCn_t*const __EGlhpcn = (__hcn);\
	unsigned int const __EGlcn = __EGlhpcn->pos;\
	unsigned int const __EGlhsz = __EGlhp->sz - 1;\
	__EGlhpcn->pos = int_EG_EHEAP_POISON;\
	__EGlhp->sz = __EGlhsz;\
	if(__EGlhsz && __EGlhsz != __EGlcn){\
		__EGlhp->cn[__EGlcn] = __EGlhp->cn[__EGlhp->sz];\
		__EGlhp->cn[__EGlcn]->pos = __EGlcn;\
		int_EGeHeapSiftDown(__EGlhp,__EGlhp->cn[__EGlcn]);}\
	__EGlhp->cn[__EGlhp->sz] = 0;})

/* ========================================================================= */
/** @brief Check the integrity of the given heap.
 * @param __hp heap to check.
 * @return zero on success, non-zero otherwise.
 * */
#if int_EG_EHEAP_DEBUG <= DEBUG
#define int_EGeHeapCheck(__hp) ({\
	int_EGeHeap_t*const __EGehp = (__hp);\
	register unsigned int __EGehi = __EGehp->sz;\
	if(__EGehi)\
		while(--__EGehi)\
			if(__EGehp->cn[__EGehi]->pos != __EGehi || int_EGlpNumIsLess( __EGehp->cn[\
				 __EGehi]->val,__EGehp->cn[int_EGeHeapFatherId(__EGehp->d,__EGehi)]->val))\
			{\
				MESSAGE(int_EG_EHEAP_DEBUG,"Element %u is wrong, pos %u val [%lf,%lf]"\
							 ,__EGehi, __EGehp->cn[__EGehi]->pos, \
							 int_EGlpNumToLf(__EGehp->cn[__EGehi]->val), \
							 int_EGlpNumToLf(__EGehp->cn[int_EGeHeapFatherId(__EGehp->d,__EGehi)]->val));\
				break;\
			}\
	__EGehi;})
#else
#define int_EGeHeapCheck(__hp) 0
#endif

/* ========================================================================= */
/** @brief set the breath of the heap, this function must be called only when
 * the heap is empty.
 * @param __hp heap to set breath.
 * @param __width new with for the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define int_EGeHeapChangeD(__hp,__width) ({\
	int_EGeHeap_t*const __EGehp = (__hp);\
	EXIT((__width)<2,"Width should be at least 2 for heaps");\
	__EGehp->sz ? 1 : (__EGehp->d = (__width), 0);})

/* ========================================================================= */
/** @} */
/* end of int_eg_eheap.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGeKHeap EGeKHeap
 *
 * Here we define the basic interface for d-heaps with an array of values with
 * the lexicographic order for vectors as an embeded structure.
 * In this implementation the heap does not grow on the fly, meaning that it 
 * may fill-up during an add call, to avoid that, the user must call 
 * re-allocate when necesary. the heap start as a heap of size zero. 
 * This implementatioon is a minimum-heap implementatiton. Note also that the
 * internal connector array is shifted one position to the left. This is done 
 * so that the first element is in position 1, this also speed-up the 
 * computation of the parent and childrens of a given position.
 *
 * @version 0.0.1
 * @par History:
 * - 2010-09-05
 * 						- Change implementation of int_EGeKHeapClear to free all internal
 * 						memory, including the one asked for the user during a
 * 						int_EGeKHeapResize call.
 * - 2008-07-30
 * 						- First implementation
 * @note 
 * This implementatiton is designed as a template using as base the types of
 * @ref EGlpNum
 * */
/** @file 
 * @ingroup EGeKHeap */
/** @addtogroup EGeKHeap */
/** @{ */
/** @example int_eg_ekheap.ex.c
 * This is a simple example of the usage of heaps using @ref EGeKHeap */
/* ========================================================================= */
#ifndef int___EG_EKHEAP__
#define int___EG_EKHEAP__
/* ========================================================================= */
/** @brief Debug level for the heap */
#ifndef int_EG_EKHEAP_DEBUG
#define int_EG_EKHEAP_DEBUG 100
#endif

/* ========================================================================= */
/** @name Test macros, enabled only if debug level is high enough. */
/** @{ */
#if int_EG_EKHEAP_DEBUG <= DEBUG
#define int_EGeKHeapCHECK_CN(__hp2,__hcn2) EXIT(__hcn2->pos>=__hp2->sz,"Heap Connector possition %d out of range [0,%d]",__hcn2->pos,__hp2->sz)
#define int_EGeKHeapCHECK_NF(__hp2) EXIT(__hp2->sz >= __hp2->max_sz,"Heap "#__hp2" Is full, can't add an element")
#else
#define int_EGeKHeapCHECK_CN(__hp,__hcn) 
#define int_EGeKHeapCHECK_NF(__hp) 
#endif
/** @} */
/* ========================================================================= */
/** @brief number of maximum entries in the vector values */
#ifndef int_EG_EKHEAP_ENTRY
#define int_EG_EKHEAP_ENTRY 3
#endif
/* ========================================================================= */
/** @brief Structure to store the information relevant to an element in the
 * heap. */
typedef struct
{
	int val[int_EG_EKHEAP_ENTRY];/**< Value of this node in the heap */
	unsigned int pos;	/**< Position in the heap array for this node, if set to
												 #int_EG_EKHEAP_POISON, then the connector is not in any 
												 heap.*/
}
int_EGeKHeapCn_t;

/* ========================================================================= */
/** @brief Poison position for heap connector not in a heap. */
#define int_EG_EKHEAP_POISON UINT_MAX

/* ========================================================================= */
/** @brief Initialize a heap conector structure. This function will allocate any
 * interal memory not allocated by the user, it should be called only once, or
 * after a clear function call.
 * @param __hcn conector to initialize.
 * */
#define int_EGeKHeapCnInit(__hcn) do{\
	int_EGeKHeapCn_t*const __EKHcn = (__hcn);\
	int __EKHi = int_EG_EKHEAP_ENTRY;\
	memset(__EKHcn,0,sizeof(int_EGeKHeapCn_t));\
	for( ; __EKHi-- ; ){int_EGlpNumInitVar(__EKHcn->val[__EKHi]);}\
	__EKHcn->pos = int_EG_EKHEAP_POISON;}while(0)

/* ========================================================================= */
/** @brief Reset a heap conector to the same state as after an init call, this
 * function is provided only for completness.
 * @param __hcn conector to reset
 * */
#define int_EGeKHeapCnReset(__hcn) ((__hcn)->pos = int_EG_EKHEAP_POISON)

/* ========================================================================= */
/** @brief Free all internal memory used by this structured not allocated by the
 * user. This function should be called after an init call, and only once.
 * @param __hcn conector to clear.
 * */
#define int_EGeKHeapCnClear(__hcn) do{\
	int_EGeKHeapCn_t*const __EKHcn = (__hcn);\
	int __EKHi = int_EG_EKHEAP_ENTRY;\
	for( ; __EKHi-- ; ){int_EGlpNumClearVar(__EKHcn->val[__EKHi]);}}while(0)

/* ========================================================================= */
/** @brief Structure to hold a whole heap structure, this structure is designed
 * so that it can grow on the fly with a low cost */
typedef struct
{
	int_EGeKHeapCn_t **cn;
	unsigned int d;
	unsigned int sz;
	unsigned int max_sz;
}
int_EGeKHeap_t;

/* ========================================================================= */
/** @brief Return one if the heap is full, zero otherwise.
 * @param __hp heat to check */
#define int_EGeKHeapIsFull(__hp) ({int_EGeKHeap_t*const __EGekhp = (__hp); __EGekhp->sz == __EGekhp->max_sz;})

/* ========================================================================= */
/** @brief set the number of elements in hte heap to zero.
 * @param __hp heap to empty.
 * */
#define int_EGeKHeapEmpty(__hp) ((__hp)->sz = 0)

/* ========================================================================= */
/** @brief Initialize a heap as an empty heap (with no space for conectors).
 * @param __hp heap to initialize.
 * */
#define int_EGeKHeapInit(__hp) (*(__hp) = (int_EGeKHeap_t){0,0,0,0})

/* ========================================================================= */
/** @brief Reset the given heap as an empty heap (just as returned by the init
 * call.
 * @param __hp heap to reset 
 * */
#define int_EGeKHepReset(__hp) int_EGeKHeapResize(__hp,0)

/* ========================================================================= */
/** @brief Clear a heap structure, and free any internal memory (not allocated
 * by the user).
 * @param __hp heap to clear.
 * */
#define int_EGeKHeapClear(__hp) int_EGeKHeapResize(__hp,0)

/* ========================================================================= */
/** @brief get the minimum value in the heap, note that since we are dealing
 * with a vector of values sorted lexicographically, the value is the value in
 * the first coordinate, other values can be accesses through
 * int_EGeKHeapGetMinKVal function.
 * @param __hp heap where we are working.
 * @param __number where to store the result
 * @return zero on success, non-zero otherwise.
 * */
#define int_EGeKHeapGetMinVal(__hp,__number) ({\
	int_EGeKHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? (int_EGlpNumCopy(__number,__EGehp->cn[0]->val[0]),0):1;})

/* ========================================================================= */
/** @brief get the k-th value of the first element in the heap.
 * @param __hp heap where we are working.
 * @param __number where to store the result.
 * @param __k which value to get (between 0 and int_EG_EKHEAP_ENTRY.
 * @return zero on success, non-zero otherwise.
 * */
#define int_EGeKHeapGetMinKVal(__hp,__k,__number) ({\
	int_EGeKHeap_t*const __EGehp = (__hp);\
	const int __EGki = (__k);\
	EXITL(int_EG_EKHEAP_DEBUG,(__EGki >= int_EG_EKHEAP_ENTRY) || (__EGki <0),\
				"K=%d out of range in int_EGeKHeapGetMinKVal", __EGki);\
	__EGehp->sz ? (int_EGlpNumCopy(__number,__EGehp->cn[0]->val[__EGki]),0):1;})

/* ========================================================================= */
/** @brief get the minimum conector in the heap, if the heap is empty, return
 * NULL.
 * @param __hp eap where we are working.
 * @return pointer to the minimum element in the heap.
 * */
#define int_EGeKHeapGetMin(__hp) ({\
	int_EGeKHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? __EGehp->cn[0] : 0;})

/* ========================================================================= */
/** @brief resize the heap cn array to the given size, if the new size is zero,
 * it is equivalent to free the internal memory, and left the heap as an empty
 * heap with zero space.
 * @param __hp heap where we are working.
 * @param __new_sz new size for the  cn array .
 * */
#define int_EGeKHeapResize(__hp,__new_sz) ({\
	int_EGeKHeap_t*const __EGehp = (__hp);\
	const size_t __EGehp_nsz = (size_t)(__new_sz);\
	__EGehp->cn = EGrealloc((__EGehp->cn), __EGehp_nsz * sizeof(int_EGeKHeapCn_t*));\
	__EGehp->max_sz = (unsigned int)(__EGehp_nsz);})

/* ========================================================================= */
/** @brief return the index of the father of the given index.
 * @param __d breadth of the heap.
 * @param __id position in the array to wich we want to compute it's father.
 * */
#define int_EGeKHeapFatherId(__d,__id) ((__id)?(((__id)-1)/(__d)):0)

/* ========================================================================= */
/** @brief given two heap connectors, return one if the first is less than the
 * second (in  lexicographic order).
 * @param __hcn1 first vector array.
 * @param __hcn2 second vector array.
 * @return one if __hcn1 <_LEX __hcn2 */
#define int_EGeKHeapIsLess(__hcn1,__hcn2) ({\
	int*const __EGEKH1 = (__hcn1);\
	int*const __EGEKH2 = (__hcn2);\
	int __EGEKHj = 0, __EGEKHrval = 0;\
	for( ; __EGEKHj < int_EG_EKHEAP_ENTRY ; __EGEKHj++)\
	{\
		if(int_EGlpNumIsLess(__EGEKH1[__EGEKHj], __EGEKH2[__EGEKHj])){\
			__EGEKHrval = 1; break;}\
		else if (int_EGlpNumIsNeq(__EGEKH1[__EGEKHj], __EGEKH2[__EGEKHj],int_epsLpNum)){\
			__EGEKHrval = 0; break;}\
	}\
	__EGEKHrval;})

/* ========================================================================= */
/** @brief copy two vector of values (only  int_EG_EKHEAP_ENTRY positions) from the
 * rource to the destination.
 * @param src int_source array.
 * @param dst destination array.
 * */
void int_EGeKHeapCopyVal(int*const dst, const int*const src);

/* ========================================================================= */
/** @brief move an element in the heap up in the heap (position 0 is the top,
 * this kind of move is neded whenever we decrease the value in a heap element).
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define int_EGeKHeapSiftUp(__hp,__hcn) ({\
	int_EGeKHeap_t*const __EGehp = (__hp);\
	int_EGeKHeapCn_t*const __EGecn = (__hcn);\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfpos = int_EGeKHeapFatherId(__EGehp->d,__EGcpos);\
	int_EGeKHeapCn_t*__EGfcn = __EGehp->cn[__EGfpos];\
	int_EGeKHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGcpos && \
				int_EGeKHeapIsLess(__EGecn->val,__EGfcn->val))\
	{\
		__EGfcn->pos = __EGcpos;\
		__EGehp->cn[__EGcpos] = __EGfcn;\
		__EGcpos = __EGfpos;\
		__EGfpos = int_EGeKHeapFatherId(__EGehp->d,__EGcpos);\
		__EGfcn = __EGehp->cn[__EGfpos];\
	}\
	__EGecn->pos = __EGcpos;\
	__EGehp->cn[__EGcpos] = __EGecn;\
	0;})

/* ========================================================================= */
/** @brief Add an element to the heap
 * @param __hp heap where to add the element.
 * @param __hcn element to be added.
 * @return zero on success, non-zero otherwise.
 * */
#define int_EGeKHeapAdd(__hp,__hcn) ({\
	int_EGeKHeap_t*const __EGlhp = (__hp);\
	int_EGeKHeapCn_t*const __EGlcn = (__hcn);\
	int_EGeKHeapCHECK_NF(__EGlhp);\
	__EGlcn->pos = __EGlhp->sz, \
	__EGlhp->cn[__EGlhp->sz] = __EGlcn, \
	__EGlhp->sz +=1, \
	int_EGeKHeapSiftUp(__EGlhp,__EGlcn), 0;})

/* ========================================================================= */
/** @brief Give the first child for a given position.
 * @param __id position that we want to get the first child.
 * @param __d breath of the heap. */
#define int_EGeKHeapFirstChildId(__d,__id) ((__d)*(__id)+1)

/* ========================================================================= */
/** @brief Move an element down in the heap (position 0 is the
 * top), this kind of operation is needed whenever we increase the value in a
 * heap element.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define int_EGeKHeapSiftDown(__hp,__hcn) ({\
	int_EGeKHeap_t*const __EGehp = (__hp);\
	int_EGeKHeapCn_t*const __EGecn = (__hcn);\
	const unsigned int __EGhsz = __EGehp->sz;\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfchd = int_EGeKHeapFirstChildId(__EGehp->d,__EGcpos);\
	unsigned int __EGlchd = __EGfchd + __EGehp->d;\
	int_EGeKHeapCn_t*__EGcchd = 0;\
	register unsigned int __EGehi = 0;\
	int_EGeKHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGfchd < __EGhsz)\
	{\
		/* detect the minimum child */\
		__EGcchd = __EGehp->cn[__EGfchd];\
		for(__EGehi = __EGlchd > __EGhsz ? __EGhsz-1 : __EGlchd-1 ;\
			__EGehi > __EGfchd ; __EGehi--)\
			if(int_EGeKHeapIsLess(__EGehp->cn[__EGehi]->val,__EGcchd->val))\
				__EGcchd = __EGehp->cn[__EGehi];\
		/* if the minimum child is less than the current position, move the minimum\
		 * child to the position of the current element */\
		if(int_EGeKHeapIsLess(__EGcchd->val,__EGecn->val))\
		{\
			__EGfchd = __EGcchd->pos;\
			__EGcchd->pos = __EGcpos;\
			__EGehp->cn[__EGcpos] = __EGcchd;\
			__EGecn->pos = __EGcpos = __EGfchd;\
			__EGehp->cn[__EGcpos] = __EGecn;\
			__EGfchd = int_EGeKHeapFirstChildId(__EGehp->d,__EGcpos);\
			__EGlchd = __EGfchd + __EGehp->d;\
		}\
		/* else we exit the main loop */\
		else __EGfchd = UINT_MAX;\
	}\
	0;})

/* ========================================================================= */
/** @brief Change the value of an element in the heap.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap that we are going to change it's value.
 * @param __new_val new value for the element (note this is an array of size at
 * least int_EG_EKHEAP_ENTRY.
 * @return zero on success, non-zero otherwise.
 * */
#define int_EGeKHeapChangeVal(__hp,__hcn,__new_val) ({\
	int_EGeKHeapCn_t*const __EGEKHcn = (__hcn);\
	(int_EGeKHeapIsLess(__new_val,(__EGEKHcn)->val)) ? (int_EGeKHeapCopyVal((__EGEKHcn)->val,__new_val),int_EGeKHeapSiftUp(__hp,__EGEKHcn)) : (int_EGeKHeapCopyVal((__EGEKHcn)->val,__new_val),int_EGeKHeapSiftDown(__hp,__EGEKHcn));})

/* ========================================================================= */
/** @brief Eliminate an element from the heap, note that the position stored in
 * the eliminated element is reset to zero.
 * @param __hp heap where we are working.
 * @param __hcn element to eliminate from the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define int_EGeKHeapDel(__hp,__hcn) ({\
	int_EGeKHeap_t*const __EGlhp = (__hp);\
	int_EGeKHeapCn_t*const __EGlhpcn = (__hcn);\
	unsigned int const __EGlcn = __EGlhpcn->pos;\
	unsigned int const __EGlhsz = __EGlhp->sz - 1;\
	__EGlhpcn->pos = int_EG_EKHEAP_POISON;\
	__EGlhp->sz = __EGlhsz;\
	if(__EGlhsz && __EGlhsz != __EGlcn){\
		__EGlhp->cn[__EGlcn] = __EGlhp->cn[__EGlhp->sz];\
		__EGlhp->cn[__EGlcn]->pos = __EGlcn;\
		int_EGeKHeapSiftDown(__EGlhp,__EGlhp->cn[__EGlcn]);}\
	__EGlhp->cn[__EGlhp->sz] = 0;})

/* ========================================================================= */
/** @brief Check the integrity of the given heap.
 * @param __hp heap to check.
 * @return zero on success, non-zero otherwise.
 * */
#if int_EG_EKHEAP_DEBUG <= DEBUG
#define int_EGeKHeapCheck(__hp) ({\
	int_EGeKHeap_t*const __EGehp = (__hp);\
	register unsigned int __EGehi = __EGehp->sz;\
	if(__EGehi)\
		while(--__EGehi)\
			if(__EGehp->cn[__EGehi]->pos != __EGehi || \
				int_EGeKHeapIsLess( __EGehp->cn[__EGehi]->val,\
												__EGehp->cn[int_EGeKHeapFatherId(__EGehp->d,__EGehi)]->val))\
			{\
				MESSAGE(int_EG_EKHEAP_DEBUG,"Element %u is wrong, pos %u val [%lf,%lf]"\
							 ,__EGehi, __EGehp->cn[__EGehi]->pos, \
							 int_EGlpNumToLf(__EGehp->cn[__EGehi]->val[0]), \
							 int_EGlpNumToLf(__EGehp->cn[int_EGeKHeapFatherId(__EGehp->d,__EGehi)]->val[0]));\
				break;\
			}\
	__EGehi;})
#else
#define int_EGeKHeapCheck(__hp) 0
#endif

/* ========================================================================= */
/** @brief set the breath of the heap, this function must be called only when
 * the heap is empty.
 * @param __hp heap to set breath.
 * @param __width new with for the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define int_EGeKHeapChangeD(__hp,__width) ({\
	int_EGeKHeap_t*const __EGehp = (__hp);\
	EXIT((__width)<2,"Width should be at least 2 for heaps");\
	__EGehp->sz ? 1 : (__EGehp->d = (__width), 0);})

/* ========================================================================= */
/** @} */
/* end of int_eg_ekheap.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGsrkGraph EGsrkGraph
 * This is a group of functions, macros and types designed to work with
 * graphs that are shrinkable, meaning that we can take two nodes in the
 * (current) graph, and shrink them into a single node, and at the same time
 * collapse all edges that become loops and if two edges are parallel, keep
 * just one (but keep a reference to the collapsed edge). At the same time the
 * shrunken nodes keep a list to the nodes 'embeded' or 'shrunken' into the
 * given node. More details in the structure definition and in the example.
 * Note that this implementation only support undirected graphs with actual
 * weights on the edges, the weights must be of type int, and their
 * values are updated during the shrinking procedure, so if anyone want to
 * have the original values omewere else, they will have to keep an extra copy
 * outside. Most of the ideas used in this implementation come from CONCORDE.
 * 
 * @version 0.0.1
 * @par History:
 * - 2005-06-01
 * 						- First Implementation.
 * */
/** @file
 * @ingroup EGsrkGraph */
/** @addtogroup EGsrkGraph */
/** @{ */
/** @example int_eg_shrink_graph.ex.c */
/* ========================================================================= */

#ifndef int__EGshrinkGraph_h__
#define int__EGshrinkGraph_h__
#ifndef int_EG_SRK_DEBUG
/* ========================================================================= */
/** @brief debuigging level, the lower the more debugging is carried out */
#define int_EG_SRK_DEBUG 100
#endif

/* ========================================================================= */
/** @brief Edge structure for shrinkable graphs */
typedef struct int_EGsrkEdge_t
{
	EGeUgraphEdge_t edge;	/**< Actual edge structure for the graph */
	EGeList_t members;		/**< list of other edges shrunken within this edge */
	unsigned int mmb_sz;	/**< length of the members list (without including the 
														 edge itsself */
	int weight;			/**< Weight for the edge */
}
int_EGsrkEdge_t;

/* ========================================================================= */
/** @brief Node structure for shrinkable graphs */
typedef struct int_EGsrkNode_t
{
	EGeUgraphNode_t node;	/**< actual node structure for the graph */
	EGeList_t members;		/**< list of other nodes shrunken with this node */
	unsigned int mmb_sz;	/**< length of the members list (without including the
														 node itself */
	EGes_t parent;				/**< If this node is the representant for its class, 
														 then this is a 'parent' node, otherwise, is a 
														 shrunken node */
	int weight;			/**< Weight of the @f$\delta(n)@f$ edges for this node
														 (in the shrunken graph), this should be 
														 initialized by the user. */
	int_EGsrkEdge_t *hit;			/**< used for internal purposes, in particular, while 
														 merging two adjacency lists, this field is used 
														 to store the first edge touching this node, and 
														 then used to retrieve that information. When we 
														 call #int_EGsrkIdentifyNodes this field is assumed 
														 to be NULL */
}
int_EGsrkNode_t;

/* ========================================================================= */
/** @brief Graph structure for shrinkable graphs */
typedef struct int_EGsrkGraph_t
{
	EGeUgraph_t G;					/**< Actual graph structure. */
	unsigned n_onodes;			/**< Number of original nodes */
	unsigned n_oedges;			/**< Number of original edges */
}
int_EGsrkGraph_t;

/* ========================================================================= */
/** @brief Initialize an edge structure.
 * @param e_edge */
#define int_EGsrkEdgeInit(e_edge) ({\
	int_EGsrkEdge_t*const _EGsrkE = (e_edge);\
	EGeUgraphEdgeInit(&(_EGsrkE->edge));\
	EGeListInit(&(_EGsrkE->members));\
	_EGsrkE->mmb_sz = 0;\
	int_EGlpNumInitVar(_EGsrkE->weight);\
	int_EGlpNumZero(_EGsrkE->weight);})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of an edge
 * structure.
 * @param e_edge */
#define int_EGsrkEdgeClear(e_edge) ({\
	EGeUgraphEdgeClear(&((e_edge)->edge));\
	int_EGlpNumClearVar((e_edge)->weight);})

/* ========================================================================= */
/** @brief Initialize a graph structure 
 * @param graph graph to be initialized */
#define int_EGsrkGraphInit(graph) ({\
	int_EGsrkGraph_t*const _EGsrkG = (graph);\
	EGeUgraphInit(&(_EGsrkG->G));\
	_EGsrkG->n_onodes = _EGsrkG->n_oedges = 0;})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a graph
 * structure.
 * @param graph */
#define int_EGsrkGraphClear(graph) EGeUgraphClear(&((graph)->G))

/* ========================================================================= */
/** @brief Initialize a node structure.
 * @param e_node node to be initialized */
#define int_EGsrkNodeInit(e_node) ({\
	int_EGsrkNode_t*const _EGsrkN = (e_node);\
	EGeUgraphNodeInit(&(_EGsrkN->node));\
	EGeListInit(&(_EGsrkN->members));\
	_EGsrkN->mmb_sz = 0;\
	_EGsrkN->hit = 0;\
	EGesInit(&(_EGsrkN->parent));\
	int_EGlpNumInitVar(_EGsrkN->weight);\
	int_EGlpNumZero(_EGsrkN->weight);})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a node
 * structure.
 * @param e_node */
#define int_EGsrkNodeClear(e_node) ({\
	EGeUgraphNodeClear(&((e_node)->node));\
	int_EGlpNumClearVar((e_node)->weight);})

/* ========================================================================= */
/** @brief Add a #int_EGsrkNode_t node to a #int_EGsrkGraph_t graph.
 * @param graph graph were to add the node.
 * @param N node to add to the graph.
 * @return zero on success, non-zero otherwise.
 * */
#define int_EGsrkAddNode(graph,N) EGeUgraphAddNode(&((graph)->G),&((N)->node))

/* ========================================================================= */
/** @brief Add a #int_EGsrkEdge_t edge to a #int_EGsrkGraph_t graph.
 * @param lG graph were to add the edge.
 * @param head_pt head node of the edge.
 * @param tail_pt tail node of the edge.
 * @param E edge to be added with end-points head_pt and tail_pt.
 * Note that this function will update the accumulated weight of both
 * endpoints of the newly added edge according to the value stored in the
 * #int_EGsrkEdge_t::weight field.
 * */
#define int_EGsrkAddEdge(lG,head_pt,tail_pt,E) ({\
	int_EGsrkNode_t*const _EGsrkH = (head_pt);\
	int_EGsrkNode_t*const _EGsrkT = (tail_pt);\
	int_EGsrkEdge_t*const _EGsrkE = (E);\
	int_EGlpNumAddTo(_EGsrkH->weight,_EGsrkE->weight);\
	int_EGlpNumAddTo(_EGsrkT->weight,_EGsrkE->weight);\
	EGeUgraphAddEdge(&((lG)->G),&(_EGsrkH->node),&(_EGsrkT->node),&(_EGsrkE->edge));})

/* ========================================================================= */
/** @brief Given two nodes in the current shrunken graph, shrunk them into one 
 * node.
 * @param G pointer to the graph where we are working
 * @param base first node.
 * @param srkN second node.
 * @return pointer to the new representing node.
 * @note We assume that the field int_EGsrkNode_t::hit is identically NULL for all
 * nodes currently in the shrunken graph (including base and srkN). 
 * @note We allways assume that N1 will be the representing node.
 * @note Take note that this structure can't get back the pointer to the srkN
 * node, the user should take care of that if needed.
 * */
int_EGsrkNode_t *int_EGsrkIdentifyNodes (int_EGsrkGraph_t * const G,
																 int_EGsrkNode_t * const base,
																 int_EGsrkNode_t * const srkN);

/* ========================================================================= */
/** @} 
 * end of int_eg_shrink_graph.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgPushRelabel EGalgPushRelabel
 *
 * Here we implement the push-relabel algorithm as defined in the book "Network 
 * Flows" by Magnanti et. all, in chapter 6,7 and 8. Using the variant
 * "Highest-label preflow-push algorithm" (described on page 230) wich choose
 * the active node from wich to push from as the one with highest distance
 * label. This variant has running time @f$ \mathcal{O}(n^2\sqrt{m}) @f$ where
 * @a n is the number of nodes in the graph, and @a m the number of edges in it.
 * Note that the call to #int_EGalgPRminSTcut produces a maximum @b pre_flow, to 
 * obtain a flow you should call the #int_EGalgPRmaxSTflow that takes the graph 
 * produced by #int_EGalgPRminSTcut and convert the preflow into a real flow. We
 * also choose to use to register the number of nodes with distance labels
 * @f$k,\quad\forall k=1,\ldots,n@f$ where @a n is the number of nodes in the
 * network. This is done because whenever the number of nodes with distance
 * labels @a k is zero, then all nodes with distance labels above @a k can be
 * set to @a n (and thus be added to the partially computed cut-set). This is an
 * (inportant) empirical speed-up, but does not affect the worst case complexity
 * analysis.
 * @version 1.0.0
 * @par History:
 * - 2010-05-07
 * 						- Add implementation using eg_adgraph.h
 * - 2005-06-01
 * 						- Add globla relabeling heuristic.
 * - 2005-05-30
 * 						- Final test results on the TSP x-files, all should be right now.
 * - 2005-05-26
 * 						- First Implementation.
 * @note This algorithm is implemented the embedded structures approach. I will
 * give further details on what this implies.
 *
 * @note It is important to note that this algorithm (as implemented here) 
 * @b WILL @b FAIL if an edge has infinite capacities. To handle that case
 * either we must re-program it, or you can put capacities suficiently large on
 * them (for example 2 times the sum of all bounded capacities) for this
 * algorithm to work.
 *
 * @note This implementation does use global relabeling, namelly, the
 * strategy when once in a while (for example every @a n or @a m relabeling
 * operations) we recompute
 * the exact distance labels. The use of this heuristic (together with the gap
 * heuristic) have been reported to be the most successfull in practice (see "On
 * Implementing Push-Relabel Method For The Maximum FLow Problem" from Boris V.
 * Cherkassy and Andrew V. Goldberg.) and also in the test that we have
 * performed on the fractional solutions of TSP's instances from the TSPLIB set
 * of problems using CONCORDE.
 * */
/** @file 
 * @ingroup EGalgPushRelabel */
/** @addtogroup EGalgPushRelabel */
/** @{ */
/** @example int_eg_push_relabel.ex.c
 * This is a complete example for the min-cut max-flow problem using the
 * push/relabel implementation offered in EGalgPR. */
#ifndef int___EG_PUSH_RELABEL_H__
#define int___EG_PUSH_RELABEL_H__
/* ========================================================================= */

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define int___PR_DEBUGL__ 100

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define int___PR_TEST_VERBOSE__ 100

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define int___PR_VERBOSE__ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define int___PR_PROFILE__ 100

/* ========================================================================= */
/** @brief If profiling is enable (i.e. #int___PR_PROFILE__ <= DEBUG), print 
 * some profiling information of the min s-t cut used up to now, and reset 
 * all internal counters to zero, if profiling is not enabled, nothing 
 * happen. */
/** @{ */
void int_EGalgPRprofile(void);
/** @} */
/* ========================================================================= */
/** @brief If set to non-zero, use the global relabeling heuristic (to be called
 * every @a n number of relabel operations performed. if set to zero, it won't
 * use this heuristic. Note thought that it has been shown that this is a very
 * efficient heuristic to reduce the total running time, specially in the
 * #int_EGalgPRminSTcut function call. */
#define int_EG_PR_RELABEL 1

/* ========================================================================= */
/** @brief If #int_EG_PR_RELABEL is set to one, then this initeger controls how
 * often we perform the global relabeling heuristic (in multiples of number of
 * nodes), the default value is 1. */
#define int_EG_PR_RELABEL_FREC 1U

/* ========================================================================= */
/** @brief Node structure neede to run Push-Relabel algorithm on a network.
 * @note Notice that the directed graph part is embeded in this structure as
 * well. Note  that we could define internally space for  LVL_list, 
 * but for the sake of speed we include them in the node structure. */
typedef struct int_EGalgPRnode_t
{
	EGeDgraphNode_t v;		/**< Actual node structure to work with (EGeDgraph) */
	EGeList_t LVL_list;		/**< Used to store the BFS list used for the first 
														 computations of the exact label distances, and 
														 then to store this node in it's current level list 
														 (this is used to implement the Highest-Label 
														 variant of the Preflow-Push algorithm) */
	EGeList_t T_cut;			/**< Used to speed-up the 'hole' heuristic, it is seted
														 once we enter the algorithm, so their value is 
														 non-important outside the function (but it's 
														 contents will be lost once we enter 
														 #int_EGalgPRminSTcut). */
	unsigned int d;				/**< Exact label distance for this node. Note that 
														 nodes with distance lables @f$ \geq n @f$ (where 
														 @a n is the number of nodes in the graph) define 
														 the minimum @f$ s-t@f$ cut that we are looking 
														 for. */
	int e;					/**< Exess flow in the node. Note that in particular 
														 the excess on node @a t (once #int_EGalgPRminSTcut 
														 finish) correspond to the minimum cut value. */
}
int_EGalgPRnode_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an int_EGalgPRnode_t structure */
#define int_EGalgPRnodeInit(node_pt) ({\
	int_EGalgPRnode_t*const __EGalgPR_in = (node_pt);\
	int_EGlpNumInitVar(__EGalgPR_in->e);\
	EGeDgraphNodeInit(&(__EGalgPR_in->v));})

/* ========================================================================= */
/** @brief Reset the given node pointer (as if it were new).
 * @param node_pt pointer to the node to reset.
 * 
 * This function set the node as an empty node not linked with any graph.
 * */
#define int_EGalgPRnodeReset(node_pt) EGeDgraphNodeReset(&((node_pt)->v))

/* ========================================================================= */
/** @brief clear a pointer to an int_EGalgPRnode_t structure, and let it ready to be
 * freed if necesary. */
#define int_EGalgPRnodeClear(node_pt) ({\
	int_EGlpNumClearVar((node_pt)->e);\
	EGeDgraphNodeClear(&((node_pt)->v));})

/* ========================================================================= */
/** @brief capacitated edge structure with forward/backward information. */
typedef struct int_EGalgPRse_t
{
	EGeDgraphEdge_t e;	/**< actual edge information. */
	int r;				/**< residual capacity of the edge. */
	int u;				/**< maximum capacity on the edge. */
	unsigned char type;	/**< type of edge (0 for forward and 1 for backward */
}
int_EGalgPRse_t;

/* ========================================================================= */
/** @brief Edge Structure needed to run Push-Relabel algorithm on a network.
 * @note Notice that the this edge actually has actually two capacited edge
  substructures, one for forward edges and one for backward edge, it is assumed
 * that fw.type == 0 and bw.type == 1. This is needed because the algorithm 
 * asumes that both
 * edges exists (althought one may have zero capacity). Moreover, while
 * computing the residual capacities we need to access both edges e_ij and e_ji
 * at the same time, thus our choice to represent both edges in just one
 * structure. We also assume that the lower bound on the flow of all edges is
 * zero. Note that we don't need to keep explicitly the flow on the edges,
 * because given the residual capacity and the capacity on the edge we have that
 * @f$ x_{ij} - x_{ji} = u_{ij} - r_{ij} @f$ and thus we can set @f$ x_{ij} =
 * (u_{ij}-r_{ij})_+ @f$ and @f$ x_{ji} = (r_{ij}-u_{ij})_+ @f$.
 * if we have computed the maximal flow. */
typedef struct int_EGalgPRedge_t
{
	int_EGalgPRse_t fw;		/**< forward edge, we assum that fw.type = 0 */
	int_EGalgPRse_t bw;		/**< backward edge, we assume that bw.type = 1 */
}
int_EGalgPRedge_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an int_EGalgPRedge_t structure */
#define int_EGalgPRedgeInit(edge_pt) ({\
	int_EGalgPRedge_t*const __EGalgPR_ie = (edge_pt);\
	int_EGlpNumInitVar(__EGalgPR_ie->fw.r);\
	int_EGlpNumInitVar(__EGalgPR_ie->fw.u);\
	int_EGlpNumInitVar(__EGalgPR_ie->bw.r);\
	int_EGlpNumInitVar(__EGalgPR_ie->bw.u);\
	EGeDgraphEdgeInit(&(__EGalgPR_ie->fw.e));\
	EGeDgraphEdgeInit(&(__EGalgPR_ie->bw.e));\
	__EGalgPR_ie->bw.type = 1;\
	__EGalgPR_ie->fw.type = 0;})

/* ========================================================================= */
/** @brief Reset the given edge pointer (as if it were new).
 * @param edge_pt pointer to the node to reset.
 * 
 * This function set the edge as an empty edge not linked with any graph.
 * */
#define int_EGalgPRedgeReset(edge_pt) ({\
	int_EGalgPRedge_t*const __EGalgPR_ie = (edge_pt);\
	EGeDgraphEdgeReset(&(__EGalgPR_ie->fw.e));\
	EGeDgraphEdgeReset(&(__EGalgPR_ie->bw.e));\
	__EGalgPR_ie->bw.type = 1;\
	__EGalgPR_ie->fw.type = 0;})


/* ========================================================================= */
/** @brief clear a pointer to an int_EGalgPRedge_t structure, and let it ready to be
 * freed if necesary. */
#define int_EGalgPRedgeClear(edge_pt) ({\
	int_EGlpNumClearVar((edge_pt)->fw.r);\
	int_EGlpNumClearVar((edge_pt)->fw.u);\
	int_EGlpNumClearVar((edge_pt)->bw.r);\
	int_EGlpNumClearVar((edge_pt)->bw.u);\
	EGeDgraphEdgeClear(&((edge_pt)->fw.e));\
	EGeDgraphEdgeClear(&((edge_pt)->bw.e));})

/* ========================================================================= */
/** @brief Graph structure needed to run Push-Relabel algorithm (with highest
 * label node selection rule). */
typedef struct int_EGalgPRgraph_t
{
	EGeDgraph_t G;				/**< EGeDgraph structure holding the graph 
														 information. */
}
int_EGalgPRgraph_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an int_EGalgPRgraph_t structure */
#define int_EGalgPRgraphInit(graph_pt) EGeDgraphInit(&((graph_pt)->G))

/* ========================================================================= */
/** @brief Reset the given graph pointer (as if it were new).
 * @param graph_pt pointer to the node to reset.
 * 
 * This function set the graph as an empty graph.
 * */
#define int_EGalgPRgraphReset(graph_pt) EGeDgraphReset(&((graph_pt)->G))

/* ========================================================================= */
/** @brief clear a pointer to an int_EGalgPRgraph_t structure, and let it ready 
 * to be freed if necesary. */
#define int_EGalgPRgraphClear(graph_pt) EGeDgraphClear(&((graph_pt)->G))

/* ========================================================================= */
/** @brief Compute a minimum @f$s-t@f$ cut.
 * @param s pointer to the int_source node.
 * @param t pointer to the int_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the int_EGalgPRgraph_t* in wich we will work.
 * @return zero on success, non-zero otherwise.
 * @par Description:
 * When this funcion finish (successfully) all nodes with field
 * #int_EGalgPRnode_t::d bigger than or equal to @a n (the number of nodes in the
 * graph) bellong to the @a s cut, while nodes with value strictly less than @a
 * n will bellong to the @a t cut. The residual capacities imply a maximum
 * pre-flow in the network, to get an acutal maximum flow you should run 
 * #int_EGalgPRmaxSTflow function with imput the output graph of this function 
 * (for an example look at the file int_eg_push_relabel.ex.c ).
 * @note This implementation uses the @a gap and @a global @a relabeling
 * heuristics to speed-up the computations.
 * */
int int_EGalgPRminSTcut (int_EGalgPRgraph_t * const G,
										 int_EGalgPRnode_t * const s,
										 int_EGalgPRnode_t * const t);

/* ========================================================================= */
/** @brief Compute a maximum @f$s-t@f$ flow from the ouput produced by
 * EGalgPRminCur.
 * @param s pointer to the int_EGalgPRnode_t* int_source node in the network.
 * @param t pointer to the int_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the int_EGalgPRgraph_t* in wich we will work.
 * @return zero on success, non-zero otherwise.
 * @par Description:
 * We assume that our input graph is the (unaltered) result of a 
 * call to #int_EGalgPRminSTcut. Also, note that while computing the actual 
 * max @a s-@a t flow, we don't need to look for @a gap in the array of 
 * distances.
 * Also note that once you call this function, the information in
 * #int_EGalgPRnode_t::d don't correspond any more to the cut as defined in
 * #int_EGalgPRminSTcut.
 * */
int int_EGalgPRmaxSTflow (int_EGalgPRgraph_t * const G,
											int_EGalgPRnode_t * const s,
											int_EGalgPRnode_t * const t);

/* ========================================================================= */
/** @brief Check if the given input graph (with it's residual capacities)
 * represent an optimal solution to the maximum @f$ s-t @f$ flow / minimum
 * capacity @f$ s-t @f$ cut.
 * @param s pointer to the int_EGalgPRnode_t* int_source node in the network.
 * @param t pointer to the int_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the int_EGalgPRgraph_t* in wich we will work.
 * @param error worst error while checking for optimality conditions.
 * @return zero if all discrepancies are under the #int_epsLpNum threshold, 
 * otherwise, return the number of conditions that don't hold within that
 * threshold, and report in error the worst error found in any condition.
 * @note The input for this function should be the graph as returned by
 * #int_EGalgPRmaxSTflow .
 * */
int int_EGalgPRoptimalityTest (int_EGalgPRgraph_t * const G,
													 int_EGalgPRnode_t * const s,
													 int_EGalgPRnode_t * const t,
													 int * error);

/* ========================================================================= */
/* @} */
/* end of int_eg_push_relabel.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgMinCut EGalgMinCut
 *
 * Here we implement the min-cut algorithm based on the srinking
 * pre-processing of Padberg And Rinaldi in the paper "An Efficient 
 * Algorithm For The Minimum Capacity Cut Problem", Mathematical Programming
 * 47 (1990) pages 19-36. But using as minimum s-t cut code the Push-Relabel
 * max flow algorithm as implemented in the @ref EGalgPushRelabel module. This 
 * implies that we only support positive edge-weights.
 *
 * This implementation allows uses of diferent numbers as supported by
 * @ref EGlpNum module. And follows the philosophy of embeded structures as in
 * @ref EGalgPushRelabel module. Also, much of the approach used in this 
 * implementation come from CONCORDE's implementation.
 *
 * It is usually the case that the Minimum Cut Problem is just a sub-problem
 * of some larger problem, is for that reason that we implement (just as in
 * CONCORDE) a callback function that is called whenever an improving solution
 * is found, so that the user can do something with the given node-cutset and
 * value. for more details see the definition of #int_EGalgMCcbk_t .
 *
 * @note 
 * If run with types like EGfp20_t, if the arithmetic produces an overflow,
 * then we are in big trouble, note that the numbers involved in the algorithm
 * may range up to \f$\sum(w_e:e\in E(G))\f$.
 *
 * @version 0.0.1
 * @par History:
 * - 2005-08-19
 * 						- While computing a minimum S-T cut, choose S randomly. and T
 * 							as a node at maximum distance (number of edges) from S.
 * 						- Fix small problem with shrinking level 4
 * - 2005-06-20
 * 						- First Implementation.
 * */
/** @file
 * @ingroup EGalgMinCut */
/** @addtogroup EGalgMinCut */
/** @{ */
/** @example int_eg_min_cut.ex.c */
/* ========================================================================= */
#ifndef int__EG_MIN_CUT_H
#define int__EG_MIN_CUT_H
/* ========================================================================= */
/** @brief Verbosity Level */
#define int___MC_VRBLVL_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define int___MC_DEBUG_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define int___MC_PROFILE_ 0

/* ========================================================================= */
/** If profiling is enable (i.e. #int___MC_PROFILE_ <= DEBUG), print 
 * some profiling information of the min cut used up to now, and reset 
 * all internal counters to zero, if profiling is not enabled, nothing 
 * happen. */
/** @{ */
void int_EGalgMCprofile(void);
/** @} */

/* ========================================================================= */
/** @brief Call-back function, it receives as input the weight of the cut, the
 * size of the newly found cut, an array containing the cut (of length at
 * least the number of elements in the cut) as integers (as defined by the 
 * #int_EGalgMCnode_t::id field), and a pointer to some internal
 * data (as stored in #int_EGalgMCcbk_t::param). The function should return zero
 * on success, and non-zero if an error ocours, this error will be propagated
 * through the calling functions. */
typedef int (*int_EGalgMCdo_f) (int,
														const unsigned int,
														const unsigned int *const,
														void *);

/* ========================================================================= */
/** @brief Call-back structure for use when an improving minimum cut is found.
 * */
typedef struct int_EGalgMCcbk_t
{
	int cutoff;	/**< maximum value for the newly found minimum cut, for 
												 the function to be called. */
	void *param;			/**< external parameter needed by the function */
	int_EGalgMCdo_f do_fn;/**< actual function to be called if the cut-off condition 
												 holds */
}
int_EGalgMCcbk_t;

/* ========================================================================= */
/** @brief Initialize a call-back structure.
 * @param cb call-back to be initialized. */
#define int_EGalgMCcbkInit(cb) ({\
	int_EGalgMCcbk_t*const _EGalgMCcb = (cb);\
	int_EGlpNumInitVar(_EGalgMCcb->cutoff);\
	_EGalgMCcb->param = 0;\
	_EGalgMCcb->do_fn = 0;})

/* ========================================================================= */
/** @brief Free all internal memory asociated with this structure (not
 * allocated by the user).
 * @param cb call-back strucure to be cleared */
#define int_EGalgMCcbkClear(cb) int_EGlpNumClearVar((cb)->cutoff)

/* ========================================================================= */
/** @brief Node structure for Minimum Cut */
typedef struct int_EGalgMCnode_t
{
	int_EGsrkNode_t node;		/**< Actual shrinkable node */
	unsigned int id;		/**< External Identifier for the node */
	EGeList_t lvl_cn;		/**< Connector for the level list */
	unsigned int int_lvl;		/**< Current node level test to be performed */
	unsigned int new_id;/**< internal data, it's values can be discarded */
	int_EGsrkEdge_t *hit;		/**< Used to speed-up the Padberg-Rinaldi tests. */
}
int_EGalgMCnode_t;

/* ========================================================================= */
/** @brief Initialize a node structure for use.
 * @param N node to be initialized */
#define int_EGalgMCnodeInit(N) ({\
	int_EGalgMCnode_t*const _EGalgMCn = (N);\
	int_EGsrkNodeInit(&(_EGalgMCn->node));\
	_EGalgMCn->lvl_cn = (EGeList_t){0,0};\
	_EGalgMCn->int_lvl = 0;\
	_EGalgMCn->id = UINT_MAX;\
	_EGalgMCn->new_id = UINT_MAX;\
	_EGalgMCn->hit = 0;})

/* ========================================================================= */
/** @brief Clear any internal memory (not allocated by the user) used by this
 * structure.
 * @param N node to be cleared */
#define int_EGalgMCnodeClear(N) int_EGsrkNodeClear(&((N)->node))

/* ========================================================================= */
/** @brief Edge structure for the Minimum Cut */
typedef struct int_EGalgMCedge_t
{
	int_EGsrkEdge_t edge;	/**< Actual shrinkable edge */
	unsigned int id;	/**< External Identifier for the edge */
}
int_EGalgMCedge_t;

/* ========================================================================= */
/** @brief Initialize an edge structure for use.
 * @param E edge to be initialized */
#define int_EGalgMCedgeInit(E) ({\
	int_EGalgMCedge_t*const _EGalgMCe = (E);\
	int_EGsrkEdgeInit(&(_EGalgMCe->edge));\
	_EGalgMCe->id = UINT_MAX;})

/* ========================================================================= */
/** @brief Clear any internal memory (not allocated by the user) used by this
 * structure.
 * @param E node to be cleared */
#define int_EGalgMCedgeClear(E) int_EGsrkEdgeClear(&((E)->edge))

/* ========================================================================= */
/** @brief Graph Structure for Minimum Cut.
 *
 * Note that this structure also holds some parameters as the epsilon to use
  in the comparisons, the current best cut found (or bound), and the current
 * cut found so-far. As well as an array containing all edges and nodes in
 * thee graph (remember that when we Identify two nodes, we loose any
 * reference to the shrinked node in the graph structure as discussed in
 * #int_EGsrkIdentifyNodes ) 
 * */
typedef struct int_EGalgMCgraph_t
{
	int_EGsrkGraph_t G;						/**< Actual shrinking graph used */
	int epsilon;				/**< error tolerance used for equality testing */
	int cut_val;				/**< if #int_EGalgMCgraph_t::cut_sz is not zero, then 
																 this is the value of the (currenlty) best 
																 minimum cut found so far. otherwise is a bound 
																 on the value of the minimum cut (note that this
																 value should be set before actually computing 
																 the minimum cut, and can be set to the value 
																 of @f$\delta(v)@f$ for some node @a v in the 
																 graph. */
	unsigned int cut_sz;			/**< number of nodes in the current best cut, if 
																 set to zero, then no cut has been found 
																 (so far) */
	EGeList_t lvl_list[5];		/**< List of nodes in different levels of tests */
	unsigned int *cut;				/**< Array  storing the current cut, the size of 
																 this array should be at least 
																 #int_EGsrkGraph_t::n_onodes */
	int_EGalgMCnode_t *all_nodes;	/**< Array containing all nodes of the graph. */
	int_EGalgMCedge_t *all_edges;	/**< Array containing all edges of the graph. */
}
int_EGalgMCgraph_t;

/* ========================================================================= */
/** @brief Initialize a graph structure for use.
 * @param Graph graph to be initialized */
#define int_EGalgMCgraphInit(Graph) ({\
	int_EGalgMCgraph_t*const _EGalgMCg = (Graph);\
	int_EGsrkGraphInit(&(_EGalgMCg->G));\
	int_EGlpNumInitVar(_EGalgMCg->epsilon);\
	int_EGlpNumZero(_EGalgMCg->epsilon);\
	int_EGlpNumInitVar(_EGalgMCg->cut_val);\
	int_EGlpNumZero(_EGalgMCg->cut_val);\
	_EGalgMCg->cut_sz = 0;\
	EGeListInit(_EGalgMCg->lvl_list);\
	EGeListInit(_EGalgMCg->lvl_list+1);\
	EGeListInit(_EGalgMCg->lvl_list+2);\
	EGeListInit(_EGalgMCg->lvl_list+3);\
	EGeListInit(_EGalgMCg->lvl_list+4);\
	_EGalgMCg->cut = 0;\
	_EGalgMCg->all_nodes = 0;\
	_EGalgMCg->all_edges = 0;})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a graph
 * structure.
 * @param Graph graph to be cleared. */
#define int_EGalgMCgraphClear(Graph) ({\
	int_EGsrkGraphClear(&((Graph)->G));\
	int_EGlpNumClearVar((Graph)->epsilon);\
	int_EGlpNumClearVar((Graph)->cut_val);})

/* ========================================================================= */
/** @brief Shrink two nodes in the graph, and update internal structures.
 * @param Graph current graph.
 * @param N node to keep in graph.
 * @param M node to shrink within N. */
#define int_EGalgMCidentifyNodes(Graph,N,M) ({\
	int_EGalgMCgraph_t*const _EGalgMCg = (Graph);\
	int_EGalgMCnode_t*const _EGalgMCn = (N), *const _EGalgMCm = (M);\
	MESSAGE(int___MC_DEBUG_,"Shrinking nodes with weight %lf %lf", \
					int_EGlpNumToLf(_EGalgMCn->node.weight), \
					int_EGlpNumToLf(_EGalgMCm->node.weight));\
	int_EGsrkIdentifyNodes(&(_EGalgMCg->G), &(_EGalgMCn->node), &(_EGalgMCm->node));\
	if(_EGalgMCn->int_lvl < 5)\
	{\
		EGeListDel(&(_EGalgMCm->lvl_cn));\
		EGeListMoveAfter(&(_EGalgMCn->lvl_cn), _EGalgMCg->lvl_list);\
	}\
	else EGeListAddAfter(&(_EGalgMCn->lvl_cn), _EGalgMCg->lvl_list);\
	_EGalgMCn->int_lvl = 0;})

/* ========================================================================= */
/** @brief Identify all Padberg and Rinaldy edges. i.e. shrink all edges that
 * satisfy the conditions in their paper. we choose to make tests over pair of
 * nodes linked by an edge. 
 * @param max_lvl set a limit on wich tests to perform. for example, if set to
 * 1, only the first and second tests will be carried out.
 * @param G graph over wich we are working. 
 * @param cb call back structure to use (if set to NULL it is not used).
 * @return zero on success, non-zero otherwise. 
 *
 * Note that while doing this identification process, we update the values of
 * #int_EGalgMCgraph_t::cut, #int_EGalgMCgraph_t::cut_sz and #int_EGalgMCgraph_t::cut_val,
 * as well as performing the actual shrinking procedure.
 *
 * The original theorem (for local conditions on shrinking) is the following:
 * Let @f$ Z @f$ be a proper subset of @f$ V @f$ (the set of all nodes in the
 * graph), @f$ |Z|\geq2 @f$, and let 
 * @f[ P(Z) = \bigcup\left\{ N(u)\cap N(v):u\neq v, u,v\in Z \right\} @f]
 * where @f$ N(u) @f$ if the set of neighbours of @f$ u @f$. If there exists
 * @f$ Y\subseteq P(Z) @f$ such that for every nonempty proper subset @f$ W
 * @f$ of @f$ Z @f$ and for every @f$ T\subseteq Y @f$ either:
 * -# @f$ w(\delta(W))/2 \leq w(W:(Y-T)+(Z-W)) @f$ or
 * -# @f$ w(\delta(Z-W))/2 \leq w(Z-W:T+W) @f$.
 * Then there exists a minimum cut @f$(X:V-X)@f$ such that either @f$
 * Z\subseteq X @f$ or @f$ X\subseteq Z @f$.
 *
 * And the original theorem (in fact is the corollary 3.5 in the paper) 
 * regarding global conditions for shrinking is the following:
 * Let @f$ u\neq v\in V @f$, and let @f$ q @f$ be an upper bound on the
 * minimum cut value, and @f$ lb_{uv} @f$ be a lower bound in the value of a
 * minimum @f$ u-v @f$ cut, then if @f$ lb_{uv}\geq q @f$ the set 
 * @f$ \{u,v\} @f$ is shrinkable.
 * 
 * The actual tests that we perform (for every edge) are the following:
 * -# If @f$ w(\delta(u)) < @f$ #int_EGalgMCgraph_t::cut_val, update the minimum
 * cut value and set.
 * -# If @f$ w_{uv} \geq \min\{w(\delta(u)),w(\delta(v))\}/2 @f$ then we can 
 * safely shrink edge @f$ uv @f$.
 * -# If we have a triangle @f$ uv,\quad vw,\quad wu  @f$, with 
 * @f$ w_{uv} + w_{vw} \geq w(\delta(v))/2 @f$ and  
 * @f$ w_{uw} + w_{vw} \geq w(\delta(w))/2 @f$ then we can safely shrink edge
 * @f$ wv @f$.
 * -# Compute lower bound on the cut that separates the endpoints of the
 * current edge as :
 * @f[ lb_{uv}=w_{uv}+\sum\limits_{w\in N(u)\cap N(v)}\min\{w_{uw},w_{vw}\} @f]
 * If  @f$ lb_{uv} \geq  @f$ #int_EGalgMCgraph_t::cut_val , then we can shrink the edge  @f$ uv @f$.
 * -# Consider the edge @f$ uv @f$ and two common neighbours @f$ x,y @f$. If  
 * @f$ w_{ux} + w_{uy} + w_{uv} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{vx} + w_{vy} + w_{vu} \geq w(\delta(v))/2 @f$ and at least one of 
 * @f$ w_{uv} + w_{uy} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{uv} + w_{vx} \geq w(\delta(v))/2 @f$ and at least one of 
 * @f$ w_{uv} + w_{ux} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{uv} + w_{vy} \geq w(\delta(v))/2 @f$ then we can safely shrink edge
 * @f$ uv @f$.
 *
 * We make thiese tests in order, i.e. first we perform all level 1 tests,
 * then level2, and so on, and whenever two nodes are Identify (shrinked) we
 * set the level of the node to 1 (i.e. in the next test we will test the
 * first condition). This is done using an array of (5) lists, where all nodes
 * are distributed. Originally all nodes should be in the first lists (i.e.
 * all nodes should be tested to improve the current best cut by themselves).
 * */
int int_EGalgMCidentifyPRedges (int_EGalgMCgraph_t * const G,
														int_EGalgMCcbk_t * const cb,
														const unsigned int max_lvl);

/* ========================================================================= */
/** @brief Compute a minimum cut on the given graph. 
 * @param max_lvl set a limit on wich tests to perform during the
 * Padberg-Rinaldy shrinking step. for example, if set to
 * 1, only the first and second tests will be carried out.
 * @param G graph over wich we are working. 
 * @param cb call back structure to use (if set to NULL it is not used).
 * @return zero on success, non-zero otherwise. 
 *
 * This function takes as input a graph, and perform the minimum cut algorithm
 * as described in the paper "An Efficient 
 * Algorithm For The Minimum Capacity Cut Problem", Mathematical Programming
 * 47 (1990) pages 19-36. 
 *
 * Note that the graph should have all fields properly initialized.
 * */
int int_EGalgMC (int_EGalgMCgraph_t * const G,
						 int_EGalgMCcbk_t * const cb,
						 const unsigned int max_lvl);

/* ========================================================================= */
/** @} 
 * end int_eg_min_cut.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef int___EG_NUMUTIL_H__
#define int___EG_NUMUTIL_H__

/* ========================================================================= */
/** @defgroup EGlpNumUtil General Number Utilities
 * Here we put some utilities common for different number types but thaat we
 * want to implement as templates, like permutation sorting, inner product of
 * vectors, and so-on..
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2007-10-08
 *  					- Separate template file and independet file into eg_nummacros.h
 *  					- Move EGabs, EGswap, EGmin and EGmax to this file
 *  - 2005-10-31
 *  					- First implementation.
 * */
/** @{*/
/** @file
 * @brief This file provide the user interface and function definitions for
 * general number utilities.
 * */
/* ========================================================================= */
/** @brief compute the inner product of two arrays.
 * @param arr1 first array.
 * @param arr2 second array.
 * @param length number of entries to consider in both arrays, from zero to
 * length - 1.
 * @param rop where to store the result.
 * */
#define int_EGlpNumInnProd(__rop,__arr1,__arr2,__length) int___EGlpNumInnProd((&(__rop)),__arr1,__arr2,__length)
/* ========================================================================= */
/** @brief internal version, this is done to avoid using stdc99 and rely on
 * more basic stdc89 */
void int___EGlpNumInnProd(int*rop,int*const arr1,int*const arr2, const size_t length);
/* ========================================================================= */
/** @brief Sort (in increasing order) a sub-set of entries in an array using 
 * quicksort, by permutating the order of the elements in the subset rather 
 * than in the whole original array.
 * @param sz length of the permutation array.
 * @param perm array of indices of elements that we want to sort.
 * @param elem array (of length at least max(perm[k]:k=0,...,sz-1)) containing
 * the elements to be sorted.
 * @note The array of elements is not changed by this function.
 * @note This code is based in concorde's implementation of
 * permutation-quick-sort.
 * */
void int_EGutilPermSort (const size_t sz,
										 int *const perm,
										 const int * const elem);

/* ========================================================================= */
/** @brief Sort (in decreasing order) a sub-set of entries in an array using 
 * quicksort, by permutating the order of the elements in the subset rather 
 * than in the whole original array.
 * @param sz length of the permutation array.
 * @param perm array of indices of elements that we want to sort.
 * @param elem array (of length at least max(perm[k]:k=0,...,sz-1)) containing
 * the elements to be sorted.
 * @note The array of elements is not changed by this function.
 * @note This code is based in concorde's implementation of
 * permutation-quick-sort.
 * */
void int_EGutilPermSort2 (const size_t sz,
										 int*const perm,
										 const int*const elem);

/* ========================================================================= */
/** @}*/
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgDijkstra EGalgDijkstra
 * Dijkstra implementation with 2-heaps
 * */
/** @file
 * @ingroup EGalgDijkstra */
/** @addtogroup EGalgDijkstra */
/** @{ */
/** @example int_eg_dijkstra.ex.c */
/* ========================================================================= */
#ifndef int___EG_DIJKSTRA_H
#define int___EG_DIJKSTRA_H
/* ========================================================================= */
/** @brief Verbosity Level */
#define int_DJK_VRBLVL_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define int_DJK_DEBUG_ 100

/* ========================================================================= */
/** @brief implement dijkstra.
 * */
int int_EGalgDJK (
		int32_t const nnodes,
		int32_t const nedges,
		int32_t const*const ou_d,
		int32_t const*const ou_beg,
		int32_t const*const ou_e,
		int const*const weight,
		int32_t const s,
		int32_t const nt,
		int32_t const*const t,
		int32_t*const father,
		int*const dist
		);

/* ========================================================================= */
/** @brief read from a file in .x format (as in the concorde's .x files), the
 * format is as follows:
 * nnodes nedges
 * tail_1 head_1 weight_1
 * ...    ...    ....
 * tail_nnodes head_nnodes weight_nnodes
 * comments are allowed, if they start with % or #.
 * @param input file containing the data
 * @param n where to store the number of nodes
 * @param m where to store the number of edges
 * @param edges pointer to an array where to store the edges, note that memory
 * will be allocated in (*edges)
 * @param weight pointer to the array where we will store the weights, note
 * that this array will be allocated using int_EGlpNumAllocArray, and should be
 * deallocated using int_EGlpNumFreeArray.
 * @return zero on success, non-zero otherwise 
 * */
int int_EGguReadXgraph(
		EGioFile_t*const input,
		int32_t*const n,
		int32_t*const m,
		int32_t**const edges,
		int**const weight);
/* ========================================================================= */
/** @} 
 * end int_eg_dijkstra.h */
#endif

/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef int32___EG_DMATRIX_H__
#define int32___EG_DMATRIX_H__

/* ========================================================================= */
/** @defgroup EGdMatrix Dense Matrices
 * Here we define a common interface for dense matrices (i.e. a structure), and
 * some common operations over dense matrices. The definition uses EGlpNum as
 * reference number type, this allow for template initializations.
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2005-10-27
 *  					- First implementation.
 * */
/** @{*/
/** @file
 * @brief This file provide the user interface and function definitions for
 * Dense Matrices.
 * */
/** @example int32_eg_dmatrix.ex.c */
/* ========================================================================= */
/** @brief structure to hold a dense matrix, we choose a row representation
 * of the matrix, and we allow row and column permutations. All actual values 
 * in the matrix are stored in #int32_EGdMatrix_t::matval, and the rows in
 * #int32_EGdMatrix_t::matrow. */
typedef struct int32_EGdMatrix_t
{
	size_t col_sz;		/**< @brief Number of columns in the matrix. */
	size_t row_sz;		/**< @brief Number of rows in the matrix */
	int32_t **matrow;
										/**< @brief Array of size #int32_EGdMatrix_t::row_sz containing 
												 all rows of the matrix */
	int32_t *matval;/**< @brief Values for all entries */
	int *col_ord;			/**< @brief Array of size at least #int32_EGdMatrix_t::col_sz 
												 containing the order ammong all columns i.e. it is a 
												 permutation of {0,....,col_sz-1} which is how the 
												 matrix is treated internally */
	int *row_ord;			/**< @brief Array of size at least #int32_EGdMatrix_t::row_sz 
												 containing the order ammong all rows, i.e. it is a 
												 permutation of {0,...,row_sz-1} which is how the 
												 matrix is treated internally */
}
int32_EGdMatrix_t;

/* ========================================================================= */
/** @brief Initialize (as a dense matrix of dimension 0x0) an #int32_EGdMatrix_t
 * structure.
 * @param __dmatrix dense matrix structure pointer.
 * */
#define int32_EGdMatrixInit(__dmatrix) memset(__dmatrix,0,sizeof(int32_EGdMatrix_t))

/* ========================================================================= */
/** @brief Clear a dense matrix structure, i.e. free all internally allocated
 * data of the structure. Note that no further use of the structure can be made
 * unless it is re-initialized and set to a suitable size.
 * @param __dmatrix dense matrix structure pointer.
 * */
#define int32_EGdMatrixClear(__dmatrix) do{\
	int32_EGdMatrix_t*const __EGdm = (__dmatrix);\
	int32_EGlpNumFreeArray(__EGdm->matval);\
	EGfree(__EGdm->matrow);\
	int_EGlpNumFreeArray(__EGdm->col_ord);\
	int_EGlpNumFreeArray(__EGdm->row_ord);} while(0)

/* ========================================================================= */
/** @brief Set new dimensions for a dense matrix structure.
 * @param __dmatrix dense matrix structure pointer.
 * @param __nnewrows number of rows in the matrix.
 * @param __nnewcols number of columns in the matrix.
 * @note Take care that the values stored in the matrix are not initialized to
 * any particular number. Also the ordering (for both column and row) is reset
 * to the standard ordering 0,....,n.
 * */
#define int32_EGdMatrixSetDimension(__dmatrix,__nnewrows,__nnewcols) do{\
	int32_EGdMatrix_t*const __EGdm = (__dmatrix);\
	register int __EGdmi;\
	__EGdm->col_sz = (__nnewcols);\
	__EGdm->row_sz = (__nnewrows);\
	int32_EGlpNumReallocArray(&(__EGdm->matval),__EGdm->col_sz * __EGdm->row_sz);\
	EGrealloc(__EGdm->matrow,__EGdm->row_sz * sizeof(int32_t*));\
	int_EGlpNumReallocArray(&(__EGdm->col_ord),__EGdm->col_sz);\
	int_EGlpNumReallocArray(&(__EGdm->row_ord),__EGdm->row_sz);\
	__EGdmi = (int)(__EGdm->col_sz);\
	while(__EGdmi--) __EGdm->col_ord[__EGdmi] = __EGdmi;\
	__EGdmi = (int)(__EGdm->row_sz);\
	while(__EGdmi--) \
		__EGdm->matrow[__EGdmi] = __EGdm->matval + ((size_t)(__EGdmi) * __EGdm->col_sz);\
	__EGdmi = (int)(__EGdm->row_sz);\
	while(__EGdmi--) __EGdm->row_ord[__EGdmi] = __EGdmi;} while(0)

/* ========================================================================= */
/** @brief Display a given #int32_EGdMatrix_t structure contents.
 * @param __dmatrix dense matrix structure pointer.
 * @param __nat_order if set to one, display the matrix using the natural 
 * internal order, i.e. we discard the order of columns and rows as defined in
 * #int32_EGdMatrix_t::col_ord and #int32_EGdMatrix_t::row_ord. Otherwise, use such orders.
 * @param __ofile pointer to a FILE structure where we want the output to be
 * printed.
 * */
#define int32_EGdMatrixDisplay(__dmatrix,__nat_order,__ofile) do{\
	int32_EGdMatrix_t*const __EGdm = (__dmatrix);\
	char* __EGdmstr = 0;\
	size_t __EGdmi, __EGdmj;\
	fprintf(__ofile,"Matrix %p\nDimensions: %zd rows, %zd columns\n", (void*)__EGdm, __EGdm->row_sz, __EGdm->col_sz);\
	if(__nat_order){\
		for(__EGdmi = 0 ; __EGdmi < __EGdm->row_sz ; __EGdmi++){\
			for(__EGdmj = 0 ; __EGdmj < __EGdm->col_sz ; __EGdmj++){\
				__EGdmstr = int32_EGlpNumGetStr(__EGdm->matrow[__EGdmi][__EGdmj]);\
				fprintf(__ofile,"%10s ", __EGdmstr);\
				EGfree(__EGdmstr);\
			}\
			fprintf(__ofile,"\n");}\
	} else {\
		for(__EGdmi = 0 ; __EGdmi < __EGdm->row_sz ; __EGdmi++){\
			for(__EGdmj = 0 ; __EGdmj < __EGdm->col_sz ; __EGdmj++){\
				__EGdmstr = int32_EGlpNumGetStr(__EGdm->matrow[__EGdm->row_ord[__EGdmi]][__EGdm->col_ord[__EGdmj]]);\
				fprintf(__ofile,"%10s ", __EGdmstr);\
				EGfree(__EGdmstr);\
			}\
			fprintf(__ofile,"\n");}\
	}} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set rows 
 * '__dest' to '__dest' + '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in row '__dest', and note that rows '__orig' and '__dest' should be different.
 * This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the row whose multiple will be added to the '__dest'
 * row.
 * @param '__dest' row to be replaced by '__dest' + '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' row.
 * @note The index of the row are taken as internal index, i.e. if we give row
 * 'k' we will use the row stored in #int32_EGdMatrix_t::matrow[k], wich does not
 * mean that we will access the k-th row in the matrix (wich would need to use
 * as index the value #int32_EGdMatrix_t::row_ord[k] instead). Note that we don't
 * test wether the given multiple is zero or not. we always perform the
 * operation.
 * */
#define int32_EGdMatrixAddRowMultiple(__dmatrix,__dest,__orig,__num) do{\
	int32_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (size_t)(__dest);\
	const size_t __EGori = (size_t)(__orig);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) \
		int32_EGlpNumAddInnProdTo(__EGdm->matrow[__EGdest][__EGdmj],\
												__EGdm->matrow[__EGori][__EGdmj],__num);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set rows 
 * '__dest' to '__dest' - '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in row '__dest', and note that rows '__orig' and '__dest' should be different.
 * This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the row whose multiple will be added to the '__dest'
 * row.
 * @param '__dest' row to be replaced by '__dest' - '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' row.
 * @note The index of the row are taken as internal index, i.e. if we give row
 * 'k' we will use the row stored in #int32_EGdMatrix_t::matrow[k], wich does not
 * mean that we will access the k-th row in the matrix (wich would need to use
 * as index the value #int32_EGdMatrix_t::row_ord[k] instead). Note that we don't
 * test wether the given multiple is zero or not. we always perform the
 * operation.
 * */
#define int32_EGdMatrixSubRowMultiple(__dmatrix,__dest,__orig,__num) do{\
	int32_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (__dest);\
	const size_t __EGori = (__orig);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) \
		int32_EGlpNumSubInnProdTo(__EGdm->matrow[__EGdest][__EGdmj],\
												__EGdm->matrow[__EGori][__EGdmj],__num);\
	} while(0)
/* ========================================================================= */
/** @brief Given a number and a row, multiply the complete row by the given
 * number. Note that the number MUST_NOT be stored in the row being multiplied,
 * this is because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param row_ind index of the row being multiplied, note that we will multiply
 * the row stored in #int32_EGdMatrix_t::matrow[row_ind], wich is different to say
 * that we multiply the row in the row_ind-th position in the row ordering (to
 * do that, then row_ind should be #int32_EGdMatrix_t::row_ord[k]).
 * @param multiple constant to be multiply to the row.
 * */
#define int32_EGdMatrixMultiplyRow(__dmatrix,row_ind,multiple) do{\
	int32_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdmi = (row_ind);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) int32_EGlpNumMultTo(__EGdm->matrow[__EGdmi][__EGdmj],multiple);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set columns 
 * '__dest' to '__dest' + '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in column '__dest', and note that columns '__orig' and '__dest' should be 
 * different. This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the column whose multiple will be added to the '__dest'
 * column.
 * @param '__dest' column to be replaced by '__dest' + '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' column.
 * @note The index of the column are taken as internal index, i.e. if we give 
 * column 'k' we will use the column stored in #int32_EGdMatrix_t::matrow[*][k], 
 * wich does not mean that we will access the k-th column in the matrix (wich
 * would need to use as index the value #int32_EGdMatrix_t::row_ord[k] instead). 
 * Note that we don't test wether the given multiple is zero or not. we 
 * always perform the operation.
 * */
#define int32_EGdMatrixAddColMultiple(__dmatrix,__dest,__orig,__num) do{\
	int32_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (__dest);\
	const size_t __EGori = (__orig);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) \
		int32_EGlpNumAddInnProdTo(__EGdm->matrow[__EGdmj][__EGdest],\
												__EGdm->matrow[__EGdmj][__EGori],__num);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set columns 
 * '__dest' to '__dest' - '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in column '__dest', and note that columns '__orig' and '__dest' should be 
 * different. This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the column whose multiple will be added to the '__dest'
 * column.
 * @param '__dest' column to be replaced by '__dest' - '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' column.
 * @note The index of the column are taken as internal index, i.e. if we give 
 * column 'k' we will use the column stored in #int32_EGdMatrix_t::matrow[*][k], 
 * wich does not mean that we will access the k-th column in the matrix (wich 
 * would need to use as index the value #int32_EGdMatrix_t::col_ord[k] instead). 
 * Note that we don't test wether the given multiple is zero or not. we 
 * always perform the operation.
 * */
#define int32_EGdMatrixSubColMultiple(__dmatrix,__dest,__orig,__num) do{\
	int32_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (size_t)(__dest);\
	const size_t __EGori = (size_t)(__orig);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) \
		int32_EGlpNumSubInnProdTo(__EGdm->matrow[__EGdmj][__EGdest],\
												__EGdm->matrow[__EGdmj][__EGori],__num);\
	} while(0)
/* ========================================================================= */
/** @brief Given a number and a column, multiply the complete column by the 
 * given number. Note that the number MUST_NOT be stored in the column being 
 * multiplied, this is because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param __colind index of the column being multiplied, note that we will 
 * multiply the column stored in #int32_EGdMatrix_t::matrow[*][__colind], wich is 
 * different to say that we multiply the column in the __colind-th position in
 * the column ordering (to do that, then __colind should be 
 * #int32_EGdMatrix_t::col_ord[k]).
 * @param __mult constant to be multiply to the column.
 * */
#define int32_EGdMatrixMultiplyCol(__dmatrix,__colind,__mult) do{\
	int32_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdmi = (__colind);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) int32_EGlpNumMultTo(__EGdm->matrow[__EGdmj][__EGdmi],__mult);\
	} while(0)


/* ========================================================================= */
/** @brief This function performs gaussian elimination to the given matrix,
 * depending on the given options it may do row/columns permutations allong the
 * way to improve numerical stabillity.
 * @param __dmatrix dense matrix structure pointer.
 * @param do_col_perm if set to one, the try columns permutation to improve
 * numericall stabillity, otherwise, not do column permutations at all.
 * @param do_row_perm if set to one, try row permutations to improve numericall
 * stabillity, otherwise, not do row permutations at all.
 * @param status pointer to where return an status, if the procedure finish all
 * the way (i.e. the matrix is full rank), then we return #EG_ALGSTAT_SUCCESS,
 * if the matrix is found to be partial rank, the status is
 * #EG_ALGSTAT_PARTIAL, otherwise, we return #EG_ALGSTAT_NUMERROR, wich means
 * that we stoped because a zero pivot was found (after checking for allowed
 * row/collumns permmutations).
 * @param rank where to return the (proven) rank of the matrix. This number is
 * accurate if the status is #EG_ALGSTAT_SUCCESS, or #EG_ALGSTAT_PARTIAL, but
 * is just a lower bound if the status is #EG_ALGSTAT_NUMERROR
 * @param zero_tol What is the threshold for a value to be considered zero.
 * @return if no error happen, we return zero, otherwise a non-zero valued is
 * returned. Note that the algorithm status is independent of the return value,
 * non zero values araise only if an error happen during execution, wich is
 * different to say that the algorithm didn't finish correctly. */
int int32_EGdMatrixGaussianElimination (int32_EGdMatrix_t * const __dmatrix,
																	const unsigned do_col_perm,
																	const unsigned do_row_perm,
																	unsigned *const rank,
																	const int32_t zero_tol,
																	int *const status);

/* ========================================================================= */
/** @}*/
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef int32___EG_DBASIS_REDUCTION__
#define int32___EG_DBASIS_REDUCTION__
/* ========================================================================= */
/** @defgroup EGdBasisRed LLL Basis Reduction
 * Here we define a common interface for dense matrices (i.e. a structure), and
 * some common operations over dense matrices. The definition uses EGlpNum as
 * reference number type, this allow for template initializations.
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2005-10-28
 *  					- First implementation.
 * */
/**  @{ */
/** @file
 * @brief This file provide the user interface and function definitions for
 * the so-called LLL Basis Reduction Algorithm. This algorithm was first
 * presented in the paper "Factoring polynomials with rational coefficients",
 * Mathematische Annalen 261 (1981), p515-534. and has been extensivelly
 * studied elsewere. for more details just Google-it.
 * */
/** @example int32_eg_dmatrix.ex.c */
/* ========================================================================= */
/** @brief verbosity level */
#define int32_EG_DBSRED_VERBOSE 0

/* ========================================================================= */
/** @name Profiling structures and functions for the basis reduction algorithm.
 * */
/* @{ */
/* ========================================================================= */
/** @brief where to hold the profile information */
extern uintmax_t int32_EGdBsRedStats[10];

/* ========================================================================= */
/** @brief where we store the number of calls to #int32_EGdBsRed */
#define int32_EG_BSRED_CALLS 0

/* ========================================================================= */
/** @brief where we store the total number of size reductions performed in 
 * #int32_EGdBsRed */
#define int32_EG_BSRED_SZRED 1

/* ========================================================================= */
/** @brief where we store the total number of interchanges performed in 
 * #int32_EGdBsRed */
#define int32_EG_BSRED_INTR 2

/* ========================================================================= */
/** @brief where we store the total number of innermost loops performed in 
 * #int32_EGdBsRed */
#define int32_EG_BSRED_ITT 3

/* ========================================================================= */
/** @brief Print into the given file stream, the current statistics related
 * to the #int32_EGdBsRed algorithm. And reset all counters to zero.
 * @param __ofile where we want to print the profile information. */
#define int32_EGdBsRedProfile(__ofile) do{\
	fprintf(__ofile,"LLL Basis Reduction Statistics:\n");\
	fprintf(__ofile,"\tNumber Calls    : %ju\n", int32_EGdBsRedStats[int32_EG_BSRED_CALLS]);\
	fprintf(__ofile,"\tLoops           : %ju\n", int32_EGdBsRedStats[int32_EG_BSRED_ITT]);\
	fprintf(__ofile,"\tSize Reductions : %ju\n", int32_EGdBsRedStats[int32_EG_BSRED_SZRED]);\
	fprintf(__ofile,"\tInterchanges    : %ju\n", int32_EGdBsRedStats[int32_EG_BSRED_INTR]);\
	memset(int32_EGdBsRedStats,0,sizeof(int32_EGdBsRedStats));} while(0)

/* @} */

/* ========================================================================= */
/** @brief Value used in condition two of the LLL algorithm, remember that this
 * number should be between \f$(1/4,1)\f$. By default we choose \f$\lambda =
 * \frac{2^{20}-1}{2^{20}} \approx .99999904632568359375 \f$. */
#define int32_EG_DBSRED_ALPHA 0x7ffffp-20

/* ========================================================================= */
/** @brief structure to hold all necesary data to perform the LLL's basis
 * reduction algorithm. */
typedef struct int32_EGdBsRed_t
{
	size_t dim;				/**< @brief Number of elements in the basis */
	size_t length;		/**< @brief Length of the vectors in the basis, note that
												 it should be that length >= dim */
	size_t basis_sz;	/**< @brief Actual length of the #int32_EGdBsRed_t::basis 
												 array */
	int32_t **basis;/**< @brief array of pointers to arrays containing the 
												 vector basis in extended (including zero coef) form. 
												 The vectors themselves are considered as allocated 
												 outside. everything else is considered as internally
												 allocated. */
	int32_EGdMatrix_t GM;		/**< @brief Here we store and compute the Gram-Schmidt 
												 needed for the LLL basis reduction algorithm */
}
int32_EGdBsRed_t;

/* ========================================================================= */
/** @brief Initialize an #int32_EGdBsRed_t structure, as a basis with zero elements
 * of dimension zero.
 * @param __bsred pointer to an #int32_EGdBsRed_t structure.
 * */
#define int32_EGdBsRedInit(__bsred) do{\
	int32_EGdBsRed_t*const __EGdbs = (__bsred);\
	memset(__EGdbs,0,sizeof(int32_EGdBsRed_t));\
	int32_EGdMatrixInit(&(__EGdbs->GM));} while(0)

/* ========================================================================= */
/** @brief Free any internally allocated memory in a #int32_EGdBsRed_t structure.
 * @param __bsred pointer to an #int32_EGdBsRed_t structure.
 * */
#define int32_EGdBsRedClear(__bsred) do{\
	int32_EGdBsRed_t*const __EGdbs = (__bsred);\
	if(__EGdbs->basis) EGfree(__EGdbs->basis);\
	int32_EGdMatrixClear(&(__EGdbs->GM));} while(0)

/* ========================================================================= */
/** @brief reset an #int32_EGdBsRed_t structure as a basis without elements (note
 * that we do not reset the length of the vectors, just the number of vectors 
 * in the basis).
 * @param __bsred pointer to an #int32_EGdBsRed_t structure.
 * */
#define int32_EGdBsRedReset(__bsred) ((__bsred)->dim = 0)

/* ========================================================================= */
/** @brief set the length of the vectors used in the basis for an #int32_EGdBsRed_t
 * structure.
 * @param __bsred pointer to an #int32_EGdBsRed_t structure.
 * @param __new_length length of the vectors in the basis.
 * */
#define int32_EGdBsRedSetLength(__bsred,__new_length) ((__bsred)->length = (__new_length))

/* ========================================================================= */
/** @brief add a new vector to the basis.
 * @param __bsred pointer to an #int32_EGdBsRed_t structure.
 * @param __new_elem new vector to add to the basis.
 * */
#define int32_EGdBsRedAddElement(__bsred,__new_elem) do{\
	int32_EGdBsRed_t*const __EGdbs = (__bsred);\
	if(__EGdbs->basis_sz <= __EGdbs->dim){\
		__EGdbs->basis_sz += 10U;\
		EGrealloc(__EGdbs->basis,sizeof(int32_t*)*__EGdbs->basis_sz);}\
	__EGdbs->basis[__EGdbs->dim++] = (__new_elem);} while(0)

/* ========================================================================= */
/** @brief This function performs the so-called LLL basis reduction algorithm.
 * @param __bsred pointer to an #int32_EGdBsRed_t structure.
 * @param status where we return the status of the algorithm, if the algorithm
 * finish with non-zero reduced elements, the status is #EG_ALGSTAT_SUCCESS. if
 * the algorithm finish with some zero reduced vector, the status is
 * #EG_ALGSTAT_PARTIAL. if the algorithm stop because of numerical problems,
 * the status is #EG_ALGSTAT_NUMERROR.
 * @param zero_tol threshold for a number to be considered as zero.
 * @param dim pointer to a number where we return the dimension of the basis
 * that the algorithm could prove before running in any numerical problem. If
 * the algorithm stop with status #EG_ALGSTAT_SUCCESS, then this number should
 * be equal to #int32_EGdBsRed_t::dim. The vectors that we finish reducing are stored
 * in #int32_EGdMatrix_t::row_ord[0], ... , #int32_EGdMatrix_t::row_ord[dim], in the
 * #int32_EGdBsRed_t::GM matrix.
 * @return zero if the algorithm finish, non-zero if an unforeseen error occure
 * during execution. 
 * @par Details:
 * The implementation that we use introduce (as an heuristic step) the sorting
 * of the original basis vectors in increasing order according to their norms,
 * this simple step reduced the total running time of the algorithm, but does
 * not improve the theoretical running time. A second detail is that we only
 * compute the Gram-Schmidth coefficients only once (at the beggining of the
 * program), and then, we only update the changed entries for both operations
 * \a size \a reduction and \a interchange. The advantage of the approach is
 * that we save most Gram-Schmidth computations and also all the recomputations
 * of the inner products of the elements currently in the basis. Again, this
 * are improvements form the practical point of view, but not in practice. The
 * dissadvantage of this approach is that we do accumulate rounding errors in
 * the Gram-Schmidth coefficients allong the way, but if all original vectors
 * coefficients where integer (and not too big), then the error should not grow
 * too much. Still this may happen if the input basis is ill conditioned.
 * */
int int32_EGdBsRed (int32_EGdBsRed_t * const __bsred,
							unsigned *const dim,
							const int32_t zero_tol,
							int *const status);

/* ========================================================================= */
/**  @} */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGeHeap EGeHeap
 *
 * Here we define the basic interface for d-heaps as an embeded structure.
 * In this implementation the heap does not grow on the fly, meaning that it 
 * may fills-up during an add call, to avoid that, the user must call 
 * re-allocate when necesary. the heap start as a heap of size zero. 
 * This implementatioon is a minimum-heap implementatiton. Note also that the
 * internal connector array is shifted one position to the left. This is done 
 * so that the first element is in position 1, this also speed-up the 
 * computation of the parent and childrens of a given position.
 *
 * @version 0.0.1
 * @par History:
 * - 2010-09-05
 * 						- int32_EGeHeapClear will free any internal memory (even if it was
 * 						asked for by the user).
 * - 2005-07-14
 * 						- Add int32_EGeHeapEmpty to empty the heap (but keep its maximum
 * 							size)
 * 						- Add int32_EGeHeapIsFull to test wether a heap is full or not.
 * - 2005-07-07
 * 						- First Implementation
 * @note 
 * This implementatiton is designed as a template using as base the types of
 * @ref EGlpNum
 * */
/** @file 
 * @ingroup EGeHeap */
/** @addtogroup EGeHeap */
/** @{ */
/** @example int32_eg_eheap.ex.c
 * This is a simple example of the usage of heaps using @ref EGeHeap */
/* ========================================================================= */
#ifndef int32___EG_EHEAP__
#define int32___EG_EHEAP__
/* ========================================================================= */
/** @brief Debug level for the heap */
#ifndef int32_EG_EHEAP_DEBUG
#define int32_EG_EHEAP_DEBUG 1000
#endif

/* ========================================================================= */
/** @name Test macros, enabled only if debug level is high enough. */
/** @{ */
#if int32_EG_EHEAP_DEBUG <= DEBUG
#define int32_EGeHeapCHECK_CN(__hp2,__hcn2) EXIT(__hcn2->pos>=__hp2->sz,"Heap Connector possition %d out of range [0,%d]",__hcn2->pos,__hp2->sz)
#define int32_EGeHeapCHECK_NF(__hp2) EXIT(__hp2->sz >= __hp2->max_sz,"Heap "#__hp2" Is full, can't add an element")
#else
#define int32_EGeHeapCHECK_CN(__hp,__hcn) 
#define int32_EGeHeapCHECK_NF(__hp) 
#endif
/** @} */
/* ========================================================================= */
/** @brief Structure to store the information relevant to an element in the
 * heap. */
typedef struct 
{
	int32_t val;		/**< Value of this node in the heap */
	unsigned int pos;	/**< Position in the heap array for this node, if set to
												 #int32_EG_EHEAP_POISON, then the connector is not in any 
												 heap.*/
}
int32_EGeHeapCn_t;

/* ========================================================================= */
/** @brief Poison position for heap connector not in a heap. */
#define int32_EG_EHEAP_POISON UINT_MAX

/* ========================================================================= */
/** @brief Initialize a heap conector structure. This function will allocate any
 * interal memory not allocated by the user, it should be called only once, or
 * after a clear function call.
 * @param __hcn conector to initialize.
 * */
#define int32_EGeHeapCnInit(__hcn) ({int32_EGlpNumInitVar((__hcn)->val);(__hcn)->pos = int32_EG_EHEAP_POISON;})

/* ========================================================================= */
/** @brief Reset a heap conector to the same state as after an init call, this
 * function is provided only for completness.
 * @param __hcn conector to reset
 * */
#define int32_EGeHeapCnReset(__hcn) ((__hcn)->pos = int32_EG_EHEAP_POISON)

/* ========================================================================= */
/** @brief Free all internal memory used by this structured not allocated by the
 * user. This function should be called after an init call, and only once.
 * @param __hcn conector to clear.
 * */
#define int32_EGeHeapCnClear(__hcn) int32_EGlpNumClearVar((__hcn)->val)

/* ========================================================================= */
/** @brief Structure to hold a whole heap structure, this structure is designed
 * so that it can grow on the fly with a low cost */
typedef struct 
{
	int32_EGeHeapCn_t **cn;
	unsigned int d;
	unsigned int sz;
	unsigned int max_sz;
}
int32_EGeHeap_t;

/* ========================================================================= */
/** @brief Return one if the heap is full, zero otherwise.
 * @param __hp heat to check */
#define int32_EGeHeapIsFull(__hp) ({int32_EGeHeap_t*const __EGehp = (__hp); __EGehp->sz == __EGehp->max_sz;})

/* ========================================================================= */
/** @brief set the number of elements in hte heap to zero.
 * @param __hp heap to empty.
 * */
#define int32_EGeHeapEmpty(__hp) ((__hp)->sz = 0)

/* ========================================================================= */
/** @brief Initialize a heap as an empty heap (with no space for conectors).
 * @param __hp heap to initialize.
 * */
#define int32_EGeHeapInit(__hp) (*(__hp) = (int32_EGeHeap_t){0,0,0,0})

/* ========================================================================= */
/** @brief Reset the given heap as an empty heap (just as returned by the init
 * call.
 * @param __hp heap to reset 
 * */
#define int32_EGeHepReset(__hp) int32_EGeHeapResize(__hp,0)

/* ========================================================================= */
/** @brief Clear a heap structure, and free any internal memory (not allocated
 * by the user).
 * @param __hp heap to clear.
 * */
#define int32_EGeHeapClear(__hp) int32_EGeHeapResize(__hp,0)

/* ========================================================================= */
/** @brief get the minimum value in the heap.
 * @param __hp heap where we are working.
 * @param number where to store the result
 * @return zero on success, non-zero otherwise.
 * */
#define int32_EGeHeapGetMinVal(__hp,number) ({\
	int32_EGeHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? (int32_EGlpNumCopy(number,__EGehp->cn[0]->val),0):1;})

/* ========================================================================= */
/** @brief get the minimum conector in the heap, if the heap is empty, return
 * NULL.
 * @param __hp eap where we are working.
 * @return pointer to the minimum element in the heap.
 * */
#define int32_EGeHeapGetMin(__hp) ({\
	int32_EGeHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? __EGehp->cn[0] : 0;})

/* ========================================================================= */
/** @brief resize the heap cn array to the given size, if the new size is zero,
 * it is equivalent to free the internal memory, and left the heap as an empty
 * heap with zero space.
 * @param __hp heap where we are working.
 * @param new_sz new size for the  cn array .
 * */
#define int32_EGeHeapResize(__hp,new_sz) ({\
	int32_EGeHeap_t*const __EGehp = (__hp);\
	const size_t __EGehp_nsz = (size_t)(new_sz);\
	__EGehp->cn = EGrealloc((__EGehp->cn), __EGehp_nsz * sizeof(int32_EGeHeapCn_t*));\
	__EGehp->max_sz = (unsigned int)(__EGehp_nsz);})

/* ========================================================================= */
/** @brief return the index of the father of the given index.
 * @param __d breadth of the heap.
 * @param __id position in the array to wich we want to compute it's father.
 * */
#define int32_EGeHeapFatherId(__d,__id) ((__id)?(((__id)-1)/(__d)):0)

/* ========================================================================= */
/** @brief move an element in the heap up in the heap (position 0 is the top,
 * this kind of move is neded whenever we decrease the value in a heap element).
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * */
#define int32_EGeHeapSiftUp(__hp,__hcn) ({\
	int32_EGeHeap_t*const __EGehp = (__hp);\
	int32_EGeHeapCn_t*const __EGecn = (__hcn);\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfpos = int32_EGeHeapFatherId(__EGehp->d,__EGcpos);\
	int32_EGeHeapCn_t*__EGfcn = __EGehp->cn[__EGfpos];\
	int32_EGeHeapCHECK_CN(__EHehp,__EGecn);\
	while(__EGcpos && \
				int32_EGlpNumIsLess(__EGecn->val,__EGfcn->val))\
	{\
		__EGfcn->pos = __EGcpos;\
		__EGehp->cn[__EGcpos] = __EGfcn;\
		__EGcpos = __EGfpos;\
		__EGfpos = int32_EGeHeapFatherId(__EGehp->d,__EGcpos);\
		__EGfcn = __EGehp->cn[__EGfpos];\
	}\
	__EGecn->pos = __EGcpos;\
	__EGehp->cn[__EGcpos] = __EGecn;\
	0;})

/* ========================================================================= */
/** @brief Add an element to the heap
 * @param __hp heap where to add the element.
 * @param __hcn element to be added.
 * @return zero on success, non-zero otherwise.
 * */
#define int32_EGeHeapAdd(__hp,__hcn) ({\
	int32_EGeHeap_t*const __EGlhp = (__hp);\
	int32_EGeHeapCn_t*const __EGlcn = (__hcn);\
	int32_EGeHeapCHECK_NF(__EGlhp);\
	__EGlcn->pos = __EGlhp->sz, \
	__EGlhp->cn[__EGlhp->sz] = __EGlcn;\
	__EGlhp->sz +=1, \
	int32_EGeHeapSiftUp(__EGlhp,__EGlcn), 0;})

/* ========================================================================= */
/** @brief Give the first child for a given position.
 * @param __id position that we want to get the first child.
 * @param __d breath of the heap. */
#define int32_EGeHeapFirstChildId(__d,__id) ((__d)*(__id)+1)

/* ========================================================================= */
/** @brief Move an element down in the heap (position 0 is the
 * top), this kind of operation is needed whenever we increase the value in a
 * heap element.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define int32_EGeHeapSiftDown(__hp,__hcn) ({\
	int32_EGeHeap_t*const __EGehp = (__hp);\
	int32_EGeHeapCn_t*const __EGecn = (__hcn);\
	const unsigned int __EGhsz = __EGehp->sz;\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfchd = int32_EGeHeapFirstChildId(__EGehp->d,__EGcpos);\
	unsigned int __EGlchd = __EGfchd + __EGehp->d;\
	int32_EGeHeapCn_t*__EGcchd = 0;\
	register unsigned int __EGehi = 0;\
	int32_EGeHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGfchd < __EGhsz)\
	{\
		/* detect the minimum child */\
		__EGcchd = __EGehp->cn[__EGfchd];\
		for(__EGehi = __EGlchd > __EGhsz ? __EGhsz-1 : __EGlchd-1 ;\
			__EGehi > __EGfchd ; __EGehi--)\
			if(int32_EGlpNumIsLess(__EGehp->cn[__EGehi]->val,__EGcchd->val))\
				__EGcchd = __EGehp->cn[__EGehi];\
		/* if the minimum child is less than the current position, move the minimum\
		 * child to the position of the current element */\
		if(int32_EGlpNumIsLess(__EGcchd->val,__EGecn->val))\
		{\
			__EGfchd = __EGcchd->pos;\
			__EGcchd->pos = __EGcpos;\
			__EGehp->cn[__EGcpos] = __EGcchd;\
			__EGecn->pos = __EGcpos = __EGfchd;\
			__EGehp->cn[__EGcpos] = __EGecn;\
			__EGfchd = int32_EGeHeapFirstChildId(__EGehp->d,__EGcpos);\
			__EGlchd = __EGfchd + __EGehp->d;\
		}\
		/* else we exit the main loop */\
		else __EGfchd = UINT_MAX;\
	}\
	0;})

/* ========================================================================= */
/** @brief Change the value of an element in the heap.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap that we are going to change it's value.
 * @param __new_val new value for the element.
 * @return zero on success, non-zero otherwise.
 * */
#define int32_EGeHeapChangeVal(__hp,__hcn,__new_val) ({\
	(int32_EGlpNumIsLess(__new_val,(__hcn)->val)) ? (int32_EGlpNumCopy((__hcn)->val,__new_val),int32_EGeHeapSiftUp(__hp,__hcn)) : (int32_EGlpNumCopy((__hcn)->val,__new_val),int32_EGeHeapSiftDown(__hp,__hcn));})

/* ========================================================================= */
/** @brief Eliminate an element from the heap, note that the position stored in
 * the eliminated element is reset to zero.
 * @param __hp heap where we are working.
 * @param __hcn element to eliminate from the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define int32_EGeHeapDel(__hp,__hcn) ({\
	int32_EGeHeap_t*const __EGlhp = (__hp);\
	int32_EGeHeapCn_t*const __EGlhpcn = (__hcn);\
	unsigned int const __EGlcn = __EGlhpcn->pos;\
	unsigned int const __EGlhsz = __EGlhp->sz - 1;\
	__EGlhpcn->pos = int32_EG_EHEAP_POISON;\
	__EGlhp->sz = __EGlhsz;\
	if(__EGlhsz && __EGlhsz != __EGlcn){\
		__EGlhp->cn[__EGlcn] = __EGlhp->cn[__EGlhp->sz];\
		__EGlhp->cn[__EGlcn]->pos = __EGlcn;\
		int32_EGeHeapSiftDown(__EGlhp,__EGlhp->cn[__EGlcn]);}\
	__EGlhp->cn[__EGlhp->sz] = 0;})

/* ========================================================================= */
/** @brief Check the integrity of the given heap.
 * @param __hp heap to check.
 * @return zero on success, non-zero otherwise.
 * */
#if int32_EG_EHEAP_DEBUG <= DEBUG
#define int32_EGeHeapCheck(__hp) ({\
	int32_EGeHeap_t*const __EGehp = (__hp);\
	register unsigned int __EGehi = __EGehp->sz;\
	if(__EGehi)\
		while(--__EGehi)\
			if(__EGehp->cn[__EGehi]->pos != __EGehi || int32_EGlpNumIsLess( __EGehp->cn[\
				 __EGehi]->val,__EGehp->cn[int32_EGeHeapFatherId(__EGehp->d,__EGehi)]->val))\
			{\
				MESSAGE(int32_EG_EHEAP_DEBUG,"Element %u is wrong, pos %u val [%lf,%lf]"\
							 ,__EGehi, __EGehp->cn[__EGehi]->pos, \
							 int32_EGlpNumToLf(__EGehp->cn[__EGehi]->val), \
							 int32_EGlpNumToLf(__EGehp->cn[int32_EGeHeapFatherId(__EGehp->d,__EGehi)]->val));\
				break;\
			}\
	__EGehi;})
#else
#define int32_EGeHeapCheck(__hp) 0
#endif

/* ========================================================================= */
/** @brief set the breath of the heap, this function must be called only when
 * the heap is empty.
 * @param __hp heap to set breath.
 * @param __width new with for the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define int32_EGeHeapChangeD(__hp,__width) ({\
	int32_EGeHeap_t*const __EGehp = (__hp);\
	EXIT((__width)<2,"Width should be at least 2 for heaps");\
	__EGehp->sz ? 1 : (__EGehp->d = (__width), 0);})

/* ========================================================================= */
/** @} */
/* end of int32_eg_eheap.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGeKHeap EGeKHeap
 *
 * Here we define the basic interface for d-heaps with an array of values with
 * the lexicographic order for vectors as an embeded structure.
 * In this implementation the heap does not grow on the fly, meaning that it 
 * may fill-up during an add call, to avoid that, the user must call 
 * re-allocate when necesary. the heap start as a heap of size zero. 
 * This implementatioon is a minimum-heap implementatiton. Note also that the
 * internal connector array is shifted one position to the left. This is done 
 * so that the first element is in position 1, this also speed-up the 
 * computation of the parent and childrens of a given position.
 *
 * @version 0.0.1
 * @par History:
 * - 2010-09-05
 * 						- Change implementation of int32_EGeKHeapClear to free all internal
 * 						memory, including the one asked for the user during a
 * 						int32_EGeKHeapResize call.
 * - 2008-07-30
 * 						- First implementation
 * @note 
 * This implementatiton is designed as a template using as base the types of
 * @ref EGlpNum
 * */
/** @file 
 * @ingroup EGeKHeap */
/** @addtogroup EGeKHeap */
/** @{ */
/** @example int32_eg_ekheap.ex.c
 * This is a simple example of the usage of heaps using @ref EGeKHeap */
/* ========================================================================= */
#ifndef int32___EG_EKHEAP__
#define int32___EG_EKHEAP__
/* ========================================================================= */
/** @brief Debug level for the heap */
#ifndef int32_EG_EKHEAP_DEBUG
#define int32_EG_EKHEAP_DEBUG 100
#endif

/* ========================================================================= */
/** @name Test macros, enabled only if debug level is high enough. */
/** @{ */
#if int32_EG_EKHEAP_DEBUG <= DEBUG
#define int32_EGeKHeapCHECK_CN(__hp2,__hcn2) EXIT(__hcn2->pos>=__hp2->sz,"Heap Connector possition %d out of range [0,%d]",__hcn2->pos,__hp2->sz)
#define int32_EGeKHeapCHECK_NF(__hp2) EXIT(__hp2->sz >= __hp2->max_sz,"Heap "#__hp2" Is full, can't add an element")
#else
#define int32_EGeKHeapCHECK_CN(__hp,__hcn) 
#define int32_EGeKHeapCHECK_NF(__hp) 
#endif
/** @} */
/* ========================================================================= */
/** @brief number of maximum entries in the vector values */
#ifndef int32_EG_EKHEAP_ENTRY
#define int32_EG_EKHEAP_ENTRY 3
#endif
/* ========================================================================= */
/** @brief Structure to store the information relevant to an element in the
 * heap. */
typedef struct
{
	int32_t val[int32_EG_EKHEAP_ENTRY];/**< Value of this node in the heap */
	unsigned int pos;	/**< Position in the heap array for this node, if set to
												 #int32_EG_EKHEAP_POISON, then the connector is not in any 
												 heap.*/
}
int32_EGeKHeapCn_t;

/* ========================================================================= */
/** @brief Poison position for heap connector not in a heap. */
#define int32_EG_EKHEAP_POISON UINT_MAX

/* ========================================================================= */
/** @brief Initialize a heap conector structure. This function will allocate any
 * interal memory not allocated by the user, it should be called only once, or
 * after a clear function call.
 * @param __hcn conector to initialize.
 * */
#define int32_EGeKHeapCnInit(__hcn) do{\
	int32_EGeKHeapCn_t*const __EKHcn = (__hcn);\
	int __EKHi = int32_EG_EKHEAP_ENTRY;\
	memset(__EKHcn,0,sizeof(int32_EGeKHeapCn_t));\
	for( ; __EKHi-- ; ){int32_EGlpNumInitVar(__EKHcn->val[__EKHi]);}\
	__EKHcn->pos = int32_EG_EKHEAP_POISON;}while(0)

/* ========================================================================= */
/** @brief Reset a heap conector to the same state as after an init call, this
 * function is provided only for completness.
 * @param __hcn conector to reset
 * */
#define int32_EGeKHeapCnReset(__hcn) ((__hcn)->pos = int32_EG_EKHEAP_POISON)

/* ========================================================================= */
/** @brief Free all internal memory used by this structured not allocated by the
 * user. This function should be called after an init call, and only once.
 * @param __hcn conector to clear.
 * */
#define int32_EGeKHeapCnClear(__hcn) do{\
	int32_EGeKHeapCn_t*const __EKHcn = (__hcn);\
	int __EKHi = int32_EG_EKHEAP_ENTRY;\
	for( ; __EKHi-- ; ){int32_EGlpNumClearVar(__EKHcn->val[__EKHi]);}}while(0)

/* ========================================================================= */
/** @brief Structure to hold a whole heap structure, this structure is designed
 * so that it can grow on the fly with a low cost */
typedef struct
{
	int32_EGeKHeapCn_t **cn;
	unsigned int d;
	unsigned int sz;
	unsigned int max_sz;
}
int32_EGeKHeap_t;

/* ========================================================================= */
/** @brief Return one if the heap is full, zero otherwise.
 * @param __hp heat to check */
#define int32_EGeKHeapIsFull(__hp) ({int32_EGeKHeap_t*const __EGekhp = (__hp); __EGekhp->sz == __EGekhp->max_sz;})

/* ========================================================================= */
/** @brief set the number of elements in hte heap to zero.
 * @param __hp heap to empty.
 * */
#define int32_EGeKHeapEmpty(__hp) ((__hp)->sz = 0)

/* ========================================================================= */
/** @brief Initialize a heap as an empty heap (with no space for conectors).
 * @param __hp heap to initialize.
 * */
#define int32_EGeKHeapInit(__hp) (*(__hp) = (int32_EGeKHeap_t){0,0,0,0})

/* ========================================================================= */
/** @brief Reset the given heap as an empty heap (just as returned by the init
 * call.
 * @param __hp heap to reset 
 * */
#define int32_EGeKHepReset(__hp) int32_EGeKHeapResize(__hp,0)

/* ========================================================================= */
/** @brief Clear a heap structure, and free any internal memory (not allocated
 * by the user).
 * @param __hp heap to clear.
 * */
#define int32_EGeKHeapClear(__hp) int32_EGeKHeapResize(__hp,0)

/* ========================================================================= */
/** @brief get the minimum value in the heap, note that since we are dealing
 * with a vector of values sorted lexicographically, the value is the value in
 * the first coordinate, other values can be accesses through
 * int32_EGeKHeapGetMinKVal function.
 * @param __hp heap where we are working.
 * @param __number where to store the result
 * @return zero on success, non-zero otherwise.
 * */
#define int32_EGeKHeapGetMinVal(__hp,__number) ({\
	int32_EGeKHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? (int32_EGlpNumCopy(__number,__EGehp->cn[0]->val[0]),0):1;})

/* ========================================================================= */
/** @brief get the k-th value of the first element in the heap.
 * @param __hp heap where we are working.
 * @param __number where to store the result.
 * @param __k which value to get (between 0 and int32_EG_EKHEAP_ENTRY.
 * @return zero on success, non-zero otherwise.
 * */
#define int32_EGeKHeapGetMinKVal(__hp,__k,__number) ({\
	int32_EGeKHeap_t*const __EGehp = (__hp);\
	const int __EGki = (__k);\
	EXITL(int32_EG_EKHEAP_DEBUG,(__EGki >= int32_EG_EKHEAP_ENTRY) || (__EGki <0),\
				"K=%d out of range in int32_EGeKHeapGetMinKVal", __EGki);\
	__EGehp->sz ? (int32_EGlpNumCopy(__number,__EGehp->cn[0]->val[__EGki]),0):1;})

/* ========================================================================= */
/** @brief get the minimum conector in the heap, if the heap is empty, return
 * NULL.
 * @param __hp eap where we are working.
 * @return pointer to the minimum element in the heap.
 * */
#define int32_EGeKHeapGetMin(__hp) ({\
	int32_EGeKHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? __EGehp->cn[0] : 0;})

/* ========================================================================= */
/** @brief resize the heap cn array to the given size, if the new size is zero,
 * it is equivalent to free the internal memory, and left the heap as an empty
 * heap with zero space.
 * @param __hp heap where we are working.
 * @param __new_sz new size for the  cn array .
 * */
#define int32_EGeKHeapResize(__hp,__new_sz) ({\
	int32_EGeKHeap_t*const __EGehp = (__hp);\
	const size_t __EGehp_nsz = (size_t)(__new_sz);\
	__EGehp->cn = EGrealloc((__EGehp->cn), __EGehp_nsz * sizeof(int32_EGeKHeapCn_t*));\
	__EGehp->max_sz = (unsigned int)(__EGehp_nsz);})

/* ========================================================================= */
/** @brief return the index of the father of the given index.
 * @param __d breadth of the heap.
 * @param __id position in the array to wich we want to compute it's father.
 * */
#define int32_EGeKHeapFatherId(__d,__id) ((__id)?(((__id)-1)/(__d)):0)

/* ========================================================================= */
/** @brief given two heap connectors, return one if the first is less than the
 * second (in  lexicographic order).
 * @param __hcn1 first vector array.
 * @param __hcn2 second vector array.
 * @return one if __hcn1 <_LEX __hcn2 */
#define int32_EGeKHeapIsLess(__hcn1,__hcn2) ({\
	int32_t*const __EGEKH1 = (__hcn1);\
	int32_t*const __EGEKH2 = (__hcn2);\
	int __EGEKHj = 0, __EGEKHrval = 0;\
	for( ; __EGEKHj < int32_EG_EKHEAP_ENTRY ; __EGEKHj++)\
	{\
		if(int32_EGlpNumIsLess(__EGEKH1[__EGEKHj], __EGEKH2[__EGEKHj])){\
			__EGEKHrval = 1; break;}\
		else if (int32_EGlpNumIsNeq(__EGEKH1[__EGEKHj], __EGEKH2[__EGEKHj],int32_epsLpNum)){\
			__EGEKHrval = 0; break;}\
	}\
	__EGEKHrval;})

/* ========================================================================= */
/** @brief copy two vector of values (only  int32_EG_EKHEAP_ENTRY positions) from the
 * rource to the destination.
 * @param src int32_source array.
 * @param dst destination array.
 * */
void int32_EGeKHeapCopyVal(int32_t*const dst, const int32_t*const src);

/* ========================================================================= */
/** @brief move an element in the heap up in the heap (position 0 is the top,
 * this kind of move is neded whenever we decrease the value in a heap element).
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define int32_EGeKHeapSiftUp(__hp,__hcn) ({\
	int32_EGeKHeap_t*const __EGehp = (__hp);\
	int32_EGeKHeapCn_t*const __EGecn = (__hcn);\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfpos = int32_EGeKHeapFatherId(__EGehp->d,__EGcpos);\
	int32_EGeKHeapCn_t*__EGfcn = __EGehp->cn[__EGfpos];\
	int32_EGeKHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGcpos && \
				int32_EGeKHeapIsLess(__EGecn->val,__EGfcn->val))\
	{\
		__EGfcn->pos = __EGcpos;\
		__EGehp->cn[__EGcpos] = __EGfcn;\
		__EGcpos = __EGfpos;\
		__EGfpos = int32_EGeKHeapFatherId(__EGehp->d,__EGcpos);\
		__EGfcn = __EGehp->cn[__EGfpos];\
	}\
	__EGecn->pos = __EGcpos;\
	__EGehp->cn[__EGcpos] = __EGecn;\
	0;})

/* ========================================================================= */
/** @brief Add an element to the heap
 * @param __hp heap where to add the element.
 * @param __hcn element to be added.
 * @return zero on success, non-zero otherwise.
 * */
#define int32_EGeKHeapAdd(__hp,__hcn) ({\
	int32_EGeKHeap_t*const __EGlhp = (__hp);\
	int32_EGeKHeapCn_t*const __EGlcn = (__hcn);\
	int32_EGeKHeapCHECK_NF(__EGlhp);\
	__EGlcn->pos = __EGlhp->sz, \
	__EGlhp->cn[__EGlhp->sz] = __EGlcn, \
	__EGlhp->sz +=1, \
	int32_EGeKHeapSiftUp(__EGlhp,__EGlcn), 0;})

/* ========================================================================= */
/** @brief Give the first child for a given position.
 * @param __id position that we want to get the first child.
 * @param __d breath of the heap. */
#define int32_EGeKHeapFirstChildId(__d,__id) ((__d)*(__id)+1)

/* ========================================================================= */
/** @brief Move an element down in the heap (position 0 is the
 * top), this kind of operation is needed whenever we increase the value in a
 * heap element.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define int32_EGeKHeapSiftDown(__hp,__hcn) ({\
	int32_EGeKHeap_t*const __EGehp = (__hp);\
	int32_EGeKHeapCn_t*const __EGecn = (__hcn);\
	const unsigned int __EGhsz = __EGehp->sz;\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfchd = int32_EGeKHeapFirstChildId(__EGehp->d,__EGcpos);\
	unsigned int __EGlchd = __EGfchd + __EGehp->d;\
	int32_EGeKHeapCn_t*__EGcchd = 0;\
	register unsigned int __EGehi = 0;\
	int32_EGeKHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGfchd < __EGhsz)\
	{\
		/* detect the minimum child */\
		__EGcchd = __EGehp->cn[__EGfchd];\
		for(__EGehi = __EGlchd > __EGhsz ? __EGhsz-1 : __EGlchd-1 ;\
			__EGehi > __EGfchd ; __EGehi--)\
			if(int32_EGeKHeapIsLess(__EGehp->cn[__EGehi]->val,__EGcchd->val))\
				__EGcchd = __EGehp->cn[__EGehi];\
		/* if the minimum child is less than the current position, move the minimum\
		 * child to the position of the current element */\
		if(int32_EGeKHeapIsLess(__EGcchd->val,__EGecn->val))\
		{\
			__EGfchd = __EGcchd->pos;\
			__EGcchd->pos = __EGcpos;\
			__EGehp->cn[__EGcpos] = __EGcchd;\
			__EGecn->pos = __EGcpos = __EGfchd;\
			__EGehp->cn[__EGcpos] = __EGecn;\
			__EGfchd = int32_EGeKHeapFirstChildId(__EGehp->d,__EGcpos);\
			__EGlchd = __EGfchd + __EGehp->d;\
		}\
		/* else we exit the main loop */\
		else __EGfchd = UINT_MAX;\
	}\
	0;})

/* ========================================================================= */
/** @brief Change the value of an element in the heap.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap that we are going to change it's value.
 * @param __new_val new value for the element (note this is an array of size at
 * least int32_EG_EKHEAP_ENTRY.
 * @return zero on success, non-zero otherwise.
 * */
#define int32_EGeKHeapChangeVal(__hp,__hcn,__new_val) ({\
	int32_EGeKHeapCn_t*const __EGEKHcn = (__hcn);\
	(int32_EGeKHeapIsLess(__new_val,(__EGEKHcn)->val)) ? (int32_EGeKHeapCopyVal((__EGEKHcn)->val,__new_val),int32_EGeKHeapSiftUp(__hp,__EGEKHcn)) : (int32_EGeKHeapCopyVal((__EGEKHcn)->val,__new_val),int32_EGeKHeapSiftDown(__hp,__EGEKHcn));})

/* ========================================================================= */
/** @brief Eliminate an element from the heap, note that the position stored in
 * the eliminated element is reset to zero.
 * @param __hp heap where we are working.
 * @param __hcn element to eliminate from the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define int32_EGeKHeapDel(__hp,__hcn) ({\
	int32_EGeKHeap_t*const __EGlhp = (__hp);\
	int32_EGeKHeapCn_t*const __EGlhpcn = (__hcn);\
	unsigned int const __EGlcn = __EGlhpcn->pos;\
	unsigned int const __EGlhsz = __EGlhp->sz - 1;\
	__EGlhpcn->pos = int32_EG_EKHEAP_POISON;\
	__EGlhp->sz = __EGlhsz;\
	if(__EGlhsz && __EGlhsz != __EGlcn){\
		__EGlhp->cn[__EGlcn] = __EGlhp->cn[__EGlhp->sz];\
		__EGlhp->cn[__EGlcn]->pos = __EGlcn;\
		int32_EGeKHeapSiftDown(__EGlhp,__EGlhp->cn[__EGlcn]);}\
	__EGlhp->cn[__EGlhp->sz] = 0;})

/* ========================================================================= */
/** @brief Check the integrity of the given heap.
 * @param __hp heap to check.
 * @return zero on success, non-zero otherwise.
 * */
#if int32_EG_EKHEAP_DEBUG <= DEBUG
#define int32_EGeKHeapCheck(__hp) ({\
	int32_EGeKHeap_t*const __EGehp = (__hp);\
	register unsigned int __EGehi = __EGehp->sz;\
	if(__EGehi)\
		while(--__EGehi)\
			if(__EGehp->cn[__EGehi]->pos != __EGehi || \
				int32_EGeKHeapIsLess( __EGehp->cn[__EGehi]->val,\
												__EGehp->cn[int32_EGeKHeapFatherId(__EGehp->d,__EGehi)]->val))\
			{\
				MESSAGE(int32_EG_EKHEAP_DEBUG,"Element %u is wrong, pos %u val [%lf,%lf]"\
							 ,__EGehi, __EGehp->cn[__EGehi]->pos, \
							 int32_EGlpNumToLf(__EGehp->cn[__EGehi]->val[0]), \
							 int32_EGlpNumToLf(__EGehp->cn[int32_EGeKHeapFatherId(__EGehp->d,__EGehi)]->val[0]));\
				break;\
			}\
	__EGehi;})
#else
#define int32_EGeKHeapCheck(__hp) 0
#endif

/* ========================================================================= */
/** @brief set the breath of the heap, this function must be called only when
 * the heap is empty.
 * @param __hp heap to set breath.
 * @param __width new with for the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define int32_EGeKHeapChangeD(__hp,__width) ({\
	int32_EGeKHeap_t*const __EGehp = (__hp);\
	EXIT((__width)<2,"Width should be at least 2 for heaps");\
	__EGehp->sz ? 1 : (__EGehp->d = (__width), 0);})

/* ========================================================================= */
/** @} */
/* end of int32_eg_ekheap.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGsrkGraph EGsrkGraph
 * This is a group of functions, macros and types designed to work with
 * graphs that are shrinkable, meaning that we can take two nodes in the
 * (current) graph, and shrink them into a single node, and at the same time
 * collapse all edges that become loops and if two edges are parallel, keep
 * just one (but keep a reference to the collapsed edge). At the same time the
 * shrunken nodes keep a list to the nodes 'embeded' or 'shrunken' into the
 * given node. More details in the structure definition and in the example.
 * Note that this implementation only support undirected graphs with actual
 * weights on the edges, the weights must be of type int32_t, and their
 * values are updated during the shrinking procedure, so if anyone want to
 * have the original values omewere else, they will have to keep an extra copy
 * outside. Most of the ideas used in this implementation come from CONCORDE.
 * 
 * @version 0.0.1
 * @par History:
 * - 2005-06-01
 * 						- First Implementation.
 * */
/** @file
 * @ingroup EGsrkGraph */
/** @addtogroup EGsrkGraph */
/** @{ */
/** @example int32_eg_shrink_graph.ex.c */
/* ========================================================================= */

#ifndef int32__EGshrinkGraph_h__
#define int32__EGshrinkGraph_h__
#ifndef int32_EG_SRK_DEBUG
/* ========================================================================= */
/** @brief debuigging level, the lower the more debugging is carried out */
#define int32_EG_SRK_DEBUG 100
#endif

/* ========================================================================= */
/** @brief Edge structure for shrinkable graphs */
typedef struct int32_EGsrkEdge_t
{
	EGeUgraphEdge_t edge;	/**< Actual edge structure for the graph */
	EGeList_t members;		/**< list of other edges shrunken within this edge */
	unsigned int mmb_sz;	/**< length of the members list (without including the 
														 edge itsself */
	int32_t weight;			/**< Weight for the edge */
}
int32_EGsrkEdge_t;

/* ========================================================================= */
/** @brief Node structure for shrinkable graphs */
typedef struct int32_EGsrkNode_t
{
	EGeUgraphNode_t node;	/**< actual node structure for the graph */
	EGeList_t members;		/**< list of other nodes shrunken with this node */
	unsigned int mmb_sz;	/**< length of the members list (without including the
														 node itself */
	EGes_t parent;				/**< If this node is the representant for its class, 
														 then this is a 'parent' node, otherwise, is a 
														 shrunken node */
	int32_t weight;			/**< Weight of the @f$\delta(n)@f$ edges for this node
														 (in the shrunken graph), this should be 
														 initialized by the user. */
	int32_EGsrkEdge_t *hit;			/**< used for internal purposes, in particular, while 
														 merging two adjacency lists, this field is used 
														 to store the first edge touching this node, and 
														 then used to retrieve that information. When we 
														 call #int32_EGsrkIdentifyNodes this field is assumed 
														 to be NULL */
}
int32_EGsrkNode_t;

/* ========================================================================= */
/** @brief Graph structure for shrinkable graphs */
typedef struct int32_EGsrkGraph_t
{
	EGeUgraph_t G;					/**< Actual graph structure. */
	unsigned n_onodes;			/**< Number of original nodes */
	unsigned n_oedges;			/**< Number of original edges */
}
int32_EGsrkGraph_t;

/* ========================================================================= */
/** @brief Initialize an edge structure.
 * @param e_edge */
#define int32_EGsrkEdgeInit(e_edge) ({\
	int32_EGsrkEdge_t*const _EGsrkE = (e_edge);\
	EGeUgraphEdgeInit(&(_EGsrkE->edge));\
	EGeListInit(&(_EGsrkE->members));\
	_EGsrkE->mmb_sz = 0;\
	int32_EGlpNumInitVar(_EGsrkE->weight);\
	int32_EGlpNumZero(_EGsrkE->weight);})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of an edge
 * structure.
 * @param e_edge */
#define int32_EGsrkEdgeClear(e_edge) ({\
	EGeUgraphEdgeClear(&((e_edge)->edge));\
	int32_EGlpNumClearVar((e_edge)->weight);})

/* ========================================================================= */
/** @brief Initialize a graph structure 
 * @param graph graph to be initialized */
#define int32_EGsrkGraphInit(graph) ({\
	int32_EGsrkGraph_t*const _EGsrkG = (graph);\
	EGeUgraphInit(&(_EGsrkG->G));\
	_EGsrkG->n_onodes = _EGsrkG->n_oedges = 0;})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a graph
 * structure.
 * @param graph */
#define int32_EGsrkGraphClear(graph) EGeUgraphClear(&((graph)->G))

/* ========================================================================= */
/** @brief Initialize a node structure.
 * @param e_node node to be initialized */
#define int32_EGsrkNodeInit(e_node) ({\
	int32_EGsrkNode_t*const _EGsrkN = (e_node);\
	EGeUgraphNodeInit(&(_EGsrkN->node));\
	EGeListInit(&(_EGsrkN->members));\
	_EGsrkN->mmb_sz = 0;\
	_EGsrkN->hit = 0;\
	EGesInit(&(_EGsrkN->parent));\
	int32_EGlpNumInitVar(_EGsrkN->weight);\
	int32_EGlpNumZero(_EGsrkN->weight);})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a node
 * structure.
 * @param e_node */
#define int32_EGsrkNodeClear(e_node) ({\
	EGeUgraphNodeClear(&((e_node)->node));\
	int32_EGlpNumClearVar((e_node)->weight);})

/* ========================================================================= */
/** @brief Add a #int32_EGsrkNode_t node to a #int32_EGsrkGraph_t graph.
 * @param graph graph were to add the node.
 * @param N node to add to the graph.
 * @return zero on success, non-zero otherwise.
 * */
#define int32_EGsrkAddNode(graph,N) EGeUgraphAddNode(&((graph)->G),&((N)->node))

/* ========================================================================= */
/** @brief Add a #int32_EGsrkEdge_t edge to a #int32_EGsrkGraph_t graph.
 * @param lG graph were to add the edge.
 * @param head_pt head node of the edge.
 * @param tail_pt tail node of the edge.
 * @param E edge to be added with end-points head_pt and tail_pt.
 * Note that this function will update the accumulated weight of both
 * endpoints of the newly added edge according to the value stored in the
 * #int32_EGsrkEdge_t::weight field.
 * */
#define int32_EGsrkAddEdge(lG,head_pt,tail_pt,E) ({\
	int32_EGsrkNode_t*const _EGsrkH = (head_pt);\
	int32_EGsrkNode_t*const _EGsrkT = (tail_pt);\
	int32_EGsrkEdge_t*const _EGsrkE = (E);\
	int32_EGlpNumAddTo(_EGsrkH->weight,_EGsrkE->weight);\
	int32_EGlpNumAddTo(_EGsrkT->weight,_EGsrkE->weight);\
	EGeUgraphAddEdge(&((lG)->G),&(_EGsrkH->node),&(_EGsrkT->node),&(_EGsrkE->edge));})

/* ========================================================================= */
/** @brief Given two nodes in the current shrunken graph, shrunk them into one 
 * node.
 * @param G pointer to the graph where we are working
 * @param base first node.
 * @param srkN second node.
 * @return pointer to the new representing node.
 * @note We assume that the field int32_EGsrkNode_t::hit is identically NULL for all
 * nodes currently in the shrunken graph (including base and srkN). 
 * @note We allways assume that N1 will be the representing node.
 * @note Take note that this structure can't get back the pointer to the srkN
 * node, the user should take care of that if needed.
 * */
int32_EGsrkNode_t *int32_EGsrkIdentifyNodes (int32_EGsrkGraph_t * const G,
																 int32_EGsrkNode_t * const base,
																 int32_EGsrkNode_t * const srkN);

/* ========================================================================= */
/** @} 
 * end of int32_eg_shrink_graph.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgPushRelabel EGalgPushRelabel
 *
 * Here we implement the push-relabel algorithm as defined in the book "Network 
 * Flows" by Magnanti et. all, in chapter 6,7 and 8. Using the variant
 * "Highest-label preflow-push algorithm" (described on page 230) wich choose
 * the active node from wich to push from as the one with highest distance
 * label. This variant has running time @f$ \mathcal{O}(n^2\sqrt{m}) @f$ where
 * @a n is the number of nodes in the graph, and @a m the number of edges in it.
 * Note that the call to #int32_EGalgPRminSTcut produces a maximum @b pre_flow, to 
 * obtain a flow you should call the #int32_EGalgPRmaxSTflow that takes the graph 
 * produced by #int32_EGalgPRminSTcut and convert the preflow into a real flow. We
 * also choose to use to register the number of nodes with distance labels
 * @f$k,\quad\forall k=1,\ldots,n@f$ where @a n is the number of nodes in the
 * network. This is done because whenever the number of nodes with distance
 * labels @a k is zero, then all nodes with distance labels above @a k can be
 * set to @a n (and thus be added to the partially computed cut-set). This is an
 * (inportant) empirical speed-up, but does not affect the worst case complexity
 * analysis.
 * @version 1.0.0
 * @par History:
 * - 2010-05-07
 * 						- Add implementation using eg_adgraph.h
 * - 2005-06-01
 * 						- Add globla relabeling heuristic.
 * - 2005-05-30
 * 						- Final test results on the TSP x-files, all should be right now.
 * - 2005-05-26
 * 						- First Implementation.
 * @note This algorithm is implemented the embedded structures approach. I will
 * give further details on what this implies.
 *
 * @note It is important to note that this algorithm (as implemented here) 
 * @b WILL @b FAIL if an edge has infinite capacities. To handle that case
 * either we must re-program it, or you can put capacities suficiently large on
 * them (for example 2 times the sum of all bounded capacities) for this
 * algorithm to work.
 *
 * @note This implementation does use global relabeling, namelly, the
 * strategy when once in a while (for example every @a n or @a m relabeling
 * operations) we recompute
 * the exact distance labels. The use of this heuristic (together with the gap
 * heuristic) have been reported to be the most successfull in practice (see "On
 * Implementing Push-Relabel Method For The Maximum FLow Problem" from Boris V.
 * Cherkassy and Andrew V. Goldberg.) and also in the test that we have
 * performed on the fractional solutions of TSP's instances from the TSPLIB set
 * of problems using CONCORDE.
 * */
/** @file 
 * @ingroup EGalgPushRelabel */
/** @addtogroup EGalgPushRelabel */
/** @{ */
/** @example int32_eg_push_relabel.ex.c
 * This is a complete example for the min-cut max-flow problem using the
 * push/relabel implementation offered in EGalgPR. */
#ifndef int32___EG_PUSH_RELABEL_H__
#define int32___EG_PUSH_RELABEL_H__
/* ========================================================================= */

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define int32___PR_DEBUGL__ 100

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define int32___PR_TEST_VERBOSE__ 100

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define int32___PR_VERBOSE__ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define int32___PR_PROFILE__ 100

/* ========================================================================= */
/** @brief If profiling is enable (i.e. #int32___PR_PROFILE__ <= DEBUG), print 
 * some profiling information of the min s-t cut used up to now, and reset 
 * all internal counters to zero, if profiling is not enabled, nothing 
 * happen. */
/** @{ */
void int32_EGalgPRprofile(void);
/** @} */
/* ========================================================================= */
/** @brief If set to non-zero, use the global relabeling heuristic (to be called
 * every @a n number of relabel operations performed. if set to zero, it won't
 * use this heuristic. Note thought that it has been shown that this is a very
 * efficient heuristic to reduce the total running time, specially in the
 * #int32_EGalgPRminSTcut function call. */
#define int32_EG_PR_RELABEL 1

/* ========================================================================= */
/** @brief If #int32_EG_PR_RELABEL is set to one, then this initeger controls how
 * often we perform the global relabeling heuristic (in multiples of number of
 * nodes), the default value is 1. */
#define int32_EG_PR_RELABEL_FREC 1U

/* ========================================================================= */
/** @brief Node structure neede to run Push-Relabel algorithm on a network.
 * @note Notice that the directed graph part is embeded in this structure as
 * well. Note  that we could define internally space for  LVL_list, 
 * but for the sake of speed we include them in the node structure. */
typedef struct int32_EGalgPRnode_t
{
	EGeDgraphNode_t v;		/**< Actual node structure to work with (EGeDgraph) */
	EGeList_t LVL_list;		/**< Used to store the BFS list used for the first 
														 computations of the exact label distances, and 
														 then to store this node in it's current level list 
														 (this is used to implement the Highest-Label 
														 variant of the Preflow-Push algorithm) */
	EGeList_t T_cut;			/**< Used to speed-up the 'hole' heuristic, it is seted
														 once we enter the algorithm, so their value is 
														 non-important outside the function (but it's 
														 contents will be lost once we enter 
														 #int32_EGalgPRminSTcut). */
	unsigned int d;				/**< Exact label distance for this node. Note that 
														 nodes with distance lables @f$ \geq n @f$ (where 
														 @a n is the number of nodes in the graph) define 
														 the minimum @f$ s-t@f$ cut that we are looking 
														 for. */
	int32_t e;					/**< Exess flow in the node. Note that in particular 
														 the excess on node @a t (once #int32_EGalgPRminSTcut 
														 finish) correspond to the minimum cut value. */
}
int32_EGalgPRnode_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an int32_EGalgPRnode_t structure */
#define int32_EGalgPRnodeInit(node_pt) ({\
	int32_EGalgPRnode_t*const __EGalgPR_in = (node_pt);\
	int32_EGlpNumInitVar(__EGalgPR_in->e);\
	EGeDgraphNodeInit(&(__EGalgPR_in->v));})

/* ========================================================================= */
/** @brief Reset the given node pointer (as if it were new).
 * @param node_pt pointer to the node to reset.
 * 
 * This function set the node as an empty node not linked with any graph.
 * */
#define int32_EGalgPRnodeReset(node_pt) EGeDgraphNodeReset(&((node_pt)->v))

/* ========================================================================= */
/** @brief clear a pointer to an int32_EGalgPRnode_t structure, and let it ready to be
 * freed if necesary. */
#define int32_EGalgPRnodeClear(node_pt) ({\
	int32_EGlpNumClearVar((node_pt)->e);\
	EGeDgraphNodeClear(&((node_pt)->v));})

/* ========================================================================= */
/** @brief capacitated edge structure with forward/backward information. */
typedef struct int32_EGalgPRse_t
{
	EGeDgraphEdge_t e;	/**< actual edge information. */
	int32_t r;				/**< residual capacity of the edge. */
	int32_t u;				/**< maximum capacity on the edge. */
	unsigned char type;	/**< type of edge (0 for forward and 1 for backward */
}
int32_EGalgPRse_t;

/* ========================================================================= */
/** @brief Edge Structure needed to run Push-Relabel algorithm on a network.
 * @note Notice that the this edge actually has actually two capacited edge
  substructures, one for forward edges and one for backward edge, it is assumed
 * that fw.type == 0 and bw.type == 1. This is needed because the algorithm 
 * asumes that both
 * edges exists (althought one may have zero capacity). Moreover, while
 * computing the residual capacities we need to access both edges e_ij and e_ji
 * at the same time, thus our choice to represent both edges in just one
 * structure. We also assume that the lower bound on the flow of all edges is
 * zero. Note that we don't need to keep explicitly the flow on the edges,
 * because given the residual capacity and the capacity on the edge we have that
 * @f$ x_{ij} - x_{ji} = u_{ij} - r_{ij} @f$ and thus we can set @f$ x_{ij} =
 * (u_{ij}-r_{ij})_+ @f$ and @f$ x_{ji} = (r_{ij}-u_{ij})_+ @f$.
 * if we have computed the maximal flow. */
typedef struct int32_EGalgPRedge_t
{
	int32_EGalgPRse_t fw;		/**< forward edge, we assum that fw.type = 0 */
	int32_EGalgPRse_t bw;		/**< backward edge, we assume that bw.type = 1 */
}
int32_EGalgPRedge_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an int32_EGalgPRedge_t structure */
#define int32_EGalgPRedgeInit(edge_pt) ({\
	int32_EGalgPRedge_t*const __EGalgPR_ie = (edge_pt);\
	int32_EGlpNumInitVar(__EGalgPR_ie->fw.r);\
	int32_EGlpNumInitVar(__EGalgPR_ie->fw.u);\
	int32_EGlpNumInitVar(__EGalgPR_ie->bw.r);\
	int32_EGlpNumInitVar(__EGalgPR_ie->bw.u);\
	EGeDgraphEdgeInit(&(__EGalgPR_ie->fw.e));\
	EGeDgraphEdgeInit(&(__EGalgPR_ie->bw.e));\
	__EGalgPR_ie->bw.type = 1;\
	__EGalgPR_ie->fw.type = 0;})

/* ========================================================================= */
/** @brief Reset the given edge pointer (as if it were new).
 * @param edge_pt pointer to the node to reset.
 * 
 * This function set the edge as an empty edge not linked with any graph.
 * */
#define int32_EGalgPRedgeReset(edge_pt) ({\
	int32_EGalgPRedge_t*const __EGalgPR_ie = (edge_pt);\
	EGeDgraphEdgeReset(&(__EGalgPR_ie->fw.e));\
	EGeDgraphEdgeReset(&(__EGalgPR_ie->bw.e));\
	__EGalgPR_ie->bw.type = 1;\
	__EGalgPR_ie->fw.type = 0;})


/* ========================================================================= */
/** @brief clear a pointer to an int32_EGalgPRedge_t structure, and let it ready to be
 * freed if necesary. */
#define int32_EGalgPRedgeClear(edge_pt) ({\
	int32_EGlpNumClearVar((edge_pt)->fw.r);\
	int32_EGlpNumClearVar((edge_pt)->fw.u);\
	int32_EGlpNumClearVar((edge_pt)->bw.r);\
	int32_EGlpNumClearVar((edge_pt)->bw.u);\
	EGeDgraphEdgeClear(&((edge_pt)->fw.e));\
	EGeDgraphEdgeClear(&((edge_pt)->bw.e));})

/* ========================================================================= */
/** @brief Graph structure needed to run Push-Relabel algorithm (with highest
 * label node selection rule). */
typedef struct int32_EGalgPRgraph_t
{
	EGeDgraph_t G;				/**< EGeDgraph structure holding the graph 
														 information. */
}
int32_EGalgPRgraph_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an int32_EGalgPRgraph_t structure */
#define int32_EGalgPRgraphInit(graph_pt) EGeDgraphInit(&((graph_pt)->G))

/* ========================================================================= */
/** @brief Reset the given graph pointer (as if it were new).
 * @param graph_pt pointer to the node to reset.
 * 
 * This function set the graph as an empty graph.
 * */
#define int32_EGalgPRgraphReset(graph_pt) EGeDgraphReset(&((graph_pt)->G))

/* ========================================================================= */
/** @brief clear a pointer to an int32_EGalgPRgraph_t structure, and let it ready 
 * to be freed if necesary. */
#define int32_EGalgPRgraphClear(graph_pt) EGeDgraphClear(&((graph_pt)->G))

/* ========================================================================= */
/** @brief Compute a minimum @f$s-t@f$ cut.
 * @param s pointer to the int32_source node.
 * @param t pointer to the int32_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the int32_EGalgPRgraph_t* in wich we will work.
 * @return zero on success, non-zero otherwise.
 * @par Description:
 * When this funcion finish (successfully) all nodes with field
 * #int32_EGalgPRnode_t::d bigger than or equal to @a n (the number of nodes in the
 * graph) bellong to the @a s cut, while nodes with value strictly less than @a
 * n will bellong to the @a t cut. The residual capacities imply a maximum
 * pre-flow in the network, to get an acutal maximum flow you should run 
 * #int32_EGalgPRmaxSTflow function with imput the output graph of this function 
 * (for an example look at the file int32_eg_push_relabel.ex.c ).
 * @note This implementation uses the @a gap and @a global @a relabeling
 * heuristics to speed-up the computations.
 * */
int int32_EGalgPRminSTcut (int32_EGalgPRgraph_t * const G,
										 int32_EGalgPRnode_t * const s,
										 int32_EGalgPRnode_t * const t);

/* ========================================================================= */
/** @brief Compute a maximum @f$s-t@f$ flow from the ouput produced by
 * EGalgPRminCur.
 * @param s pointer to the int32_EGalgPRnode_t* int32_source node in the network.
 * @param t pointer to the int32_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the int32_EGalgPRgraph_t* in wich we will work.
 * @return zero on success, non-zero otherwise.
 * @par Description:
 * We assume that our input graph is the (unaltered) result of a 
 * call to #int32_EGalgPRminSTcut. Also, note that while computing the actual 
 * max @a s-@a t flow, we don't need to look for @a gap in the array of 
 * distances.
 * Also note that once you call this function, the information in
 * #int32_EGalgPRnode_t::d don't correspond any more to the cut as defined in
 * #int32_EGalgPRminSTcut.
 * */
int int32_EGalgPRmaxSTflow (int32_EGalgPRgraph_t * const G,
											int32_EGalgPRnode_t * const s,
											int32_EGalgPRnode_t * const t);

/* ========================================================================= */
/** @brief Check if the given input graph (with it's residual capacities)
 * represent an optimal solution to the maximum @f$ s-t @f$ flow / minimum
 * capacity @f$ s-t @f$ cut.
 * @param s pointer to the int32_EGalgPRnode_t* int32_source node in the network.
 * @param t pointer to the int32_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the int32_EGalgPRgraph_t* in wich we will work.
 * @param error worst error while checking for optimality conditions.
 * @return zero if all discrepancies are under the #int32_epsLpNum threshold, 
 * otherwise, return the number of conditions that don't hold within that
 * threshold, and report in error the worst error found in any condition.
 * @note The input for this function should be the graph as returned by
 * #int32_EGalgPRmaxSTflow .
 * */
int int32_EGalgPRoptimalityTest (int32_EGalgPRgraph_t * const G,
													 int32_EGalgPRnode_t * const s,
													 int32_EGalgPRnode_t * const t,
													 int32_t * error);

/* ========================================================================= */
/* @} */
/* end of int32_eg_push_relabel.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgMinCut EGalgMinCut
 *
 * Here we implement the min-cut algorithm based on the srinking
 * pre-processing of Padberg And Rinaldi in the paper "An Efficient 
 * Algorithm For The Minimum Capacity Cut Problem", Mathematical Programming
 * 47 (1990) pages 19-36. But using as minimum s-t cut code the Push-Relabel
 * max flow algorithm as implemented in the @ref EGalgPushRelabel module. This 
 * implies that we only support positive edge-weights.
 *
 * This implementation allows uses of diferent numbers as supported by
 * @ref EGlpNum module. And follows the philosophy of embeded structures as in
 * @ref EGalgPushRelabel module. Also, much of the approach used in this 
 * implementation come from CONCORDE's implementation.
 *
 * It is usually the case that the Minimum Cut Problem is just a sub-problem
 * of some larger problem, is for that reason that we implement (just as in
 * CONCORDE) a callback function that is called whenever an improving solution
 * is found, so that the user can do something with the given node-cutset and
 * value. for more details see the definition of #int32_EGalgMCcbk_t .
 *
 * @note 
 * If run with types like EGfp20_t, if the arithmetic produces an overflow,
 * then we are in big trouble, note that the numbers involved in the algorithm
 * may range up to \f$\sum(w_e:e\in E(G))\f$.
 *
 * @version 0.0.1
 * @par History:
 * - 2005-08-19
 * 						- While computing a minimum S-T cut, choose S randomly. and T
 * 							as a node at maximum distance (number of edges) from S.
 * 						- Fix small problem with shrinking level 4
 * - 2005-06-20
 * 						- First Implementation.
 * */
/** @file
 * @ingroup EGalgMinCut */
/** @addtogroup EGalgMinCut */
/** @{ */
/** @example int32_eg_min_cut.ex.c */
/* ========================================================================= */
#ifndef int32__EG_MIN_CUT_H
#define int32__EG_MIN_CUT_H
/* ========================================================================= */
/** @brief Verbosity Level */
#define int32___MC_VRBLVL_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define int32___MC_DEBUG_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define int32___MC_PROFILE_ 0

/* ========================================================================= */
/** If profiling is enable (i.e. #int32___MC_PROFILE_ <= DEBUG), print 
 * some profiling information of the min cut used up to now, and reset 
 * all internal counters to zero, if profiling is not enabled, nothing 
 * happen. */
/** @{ */
void int32_EGalgMCprofile(void);
/** @} */

/* ========================================================================= */
/** @brief Call-back function, it receives as input the weight of the cut, the
 * size of the newly found cut, an array containing the cut (of length at
 * least the number of elements in the cut) as integers (as defined by the 
 * #int32_EGalgMCnode_t::id field), and a pointer to some internal
 * data (as stored in #int32_EGalgMCcbk_t::param). The function should return zero
 * on success, and non-zero if an error ocours, this error will be propagated
 * through the calling functions. */
typedef int (*int32_EGalgMCdo_f) (int32_t,
														const unsigned int,
														const unsigned int *const,
														void *);

/* ========================================================================= */
/** @brief Call-back structure for use when an improving minimum cut is found.
 * */
typedef struct int32_EGalgMCcbk_t
{
	int32_t cutoff;	/**< maximum value for the newly found minimum cut, for 
												 the function to be called. */
	void *param;			/**< external parameter needed by the function */
	int32_EGalgMCdo_f do_fn;/**< actual function to be called if the cut-off condition 
												 holds */
}
int32_EGalgMCcbk_t;

/* ========================================================================= */
/** @brief Initialize a call-back structure.
 * @param cb call-back to be initialized. */
#define int32_EGalgMCcbkInit(cb) ({\
	int32_EGalgMCcbk_t*const _EGalgMCcb = (cb);\
	int32_EGlpNumInitVar(_EGalgMCcb->cutoff);\
	_EGalgMCcb->param = 0;\
	_EGalgMCcb->do_fn = 0;})

/* ========================================================================= */
/** @brief Free all internal memory asociated with this structure (not
 * allocated by the user).
 * @param cb call-back strucure to be cleared */
#define int32_EGalgMCcbkClear(cb) int32_EGlpNumClearVar((cb)->cutoff)

/* ========================================================================= */
/** @brief Node structure for Minimum Cut */
typedef struct int32_EGalgMCnode_t
{
	int32_EGsrkNode_t node;		/**< Actual shrinkable node */
	unsigned int id;		/**< External Identifier for the node */
	EGeList_t lvl_cn;		/**< Connector for the level list */
	unsigned int int32_lvl;		/**< Current node level test to be performed */
	unsigned int new_id;/**< internal data, it's values can be discarded */
	int32_EGsrkEdge_t *hit;		/**< Used to speed-up the Padberg-Rinaldi tests. */
}
int32_EGalgMCnode_t;

/* ========================================================================= */
/** @brief Initialize a node structure for use.
 * @param N node to be initialized */
#define int32_EGalgMCnodeInit(N) ({\
	int32_EGalgMCnode_t*const _EGalgMCn = (N);\
	int32_EGsrkNodeInit(&(_EGalgMCn->node));\
	_EGalgMCn->lvl_cn = (EGeList_t){0,0};\
	_EGalgMCn->int32_lvl = 0;\
	_EGalgMCn->id = UINT_MAX;\
	_EGalgMCn->new_id = UINT_MAX;\
	_EGalgMCn->hit = 0;})

/* ========================================================================= */
/** @brief Clear any internal memory (not allocated by the user) used by this
 * structure.
 * @param N node to be cleared */
#define int32_EGalgMCnodeClear(N) int32_EGsrkNodeClear(&((N)->node))

/* ========================================================================= */
/** @brief Edge structure for the Minimum Cut */
typedef struct int32_EGalgMCedge_t
{
	int32_EGsrkEdge_t edge;	/**< Actual shrinkable edge */
	unsigned int id;	/**< External Identifier for the edge */
}
int32_EGalgMCedge_t;

/* ========================================================================= */
/** @brief Initialize an edge structure for use.
 * @param E edge to be initialized */
#define int32_EGalgMCedgeInit(E) ({\
	int32_EGalgMCedge_t*const _EGalgMCe = (E);\
	int32_EGsrkEdgeInit(&(_EGalgMCe->edge));\
	_EGalgMCe->id = UINT_MAX;})

/* ========================================================================= */
/** @brief Clear any internal memory (not allocated by the user) used by this
 * structure.
 * @param E node to be cleared */
#define int32_EGalgMCedgeClear(E) int32_EGsrkEdgeClear(&((E)->edge))

/* ========================================================================= */
/** @brief Graph Structure for Minimum Cut.
 *
 * Note that this structure also holds some parameters as the epsilon to use
  in the comparisons, the current best cut found (or bound), and the current
 * cut found so-far. As well as an array containing all edges and nodes in
 * thee graph (remember that when we Identify two nodes, we loose any
 * reference to the shrinked node in the graph structure as discussed in
 * #int32_EGsrkIdentifyNodes ) 
 * */
typedef struct int32_EGalgMCgraph_t
{
	int32_EGsrkGraph_t G;						/**< Actual shrinking graph used */
	int32_t epsilon;				/**< error tolerance used for equality testing */
	int32_t cut_val;				/**< if #int32_EGalgMCgraph_t::cut_sz is not zero, then 
																 this is the value of the (currenlty) best 
																 minimum cut found so far. otherwise is a bound 
																 on the value of the minimum cut (note that this
																 value should be set before actually computing 
																 the minimum cut, and can be set to the value 
																 of @f$\delta(v)@f$ for some node @a v in the 
																 graph. */
	unsigned int cut_sz;			/**< number of nodes in the current best cut, if 
																 set to zero, then no cut has been found 
																 (so far) */
	EGeList_t lvl_list[5];		/**< List of nodes in different levels of tests */
	unsigned int *cut;				/**< Array  storing the current cut, the size of 
																 this array should be at least 
																 #int32_EGsrkGraph_t::n_onodes */
	int32_EGalgMCnode_t *all_nodes;	/**< Array containing all nodes of the graph. */
	int32_EGalgMCedge_t *all_edges;	/**< Array containing all edges of the graph. */
}
int32_EGalgMCgraph_t;

/* ========================================================================= */
/** @brief Initialize a graph structure for use.
 * @param Graph graph to be initialized */
#define int32_EGalgMCgraphInit(Graph) ({\
	int32_EGalgMCgraph_t*const _EGalgMCg = (Graph);\
	int32_EGsrkGraphInit(&(_EGalgMCg->G));\
	int32_EGlpNumInitVar(_EGalgMCg->epsilon);\
	int32_EGlpNumZero(_EGalgMCg->epsilon);\
	int32_EGlpNumInitVar(_EGalgMCg->cut_val);\
	int32_EGlpNumZero(_EGalgMCg->cut_val);\
	_EGalgMCg->cut_sz = 0;\
	EGeListInit(_EGalgMCg->lvl_list);\
	EGeListInit(_EGalgMCg->lvl_list+1);\
	EGeListInit(_EGalgMCg->lvl_list+2);\
	EGeListInit(_EGalgMCg->lvl_list+3);\
	EGeListInit(_EGalgMCg->lvl_list+4);\
	_EGalgMCg->cut = 0;\
	_EGalgMCg->all_nodes = 0;\
	_EGalgMCg->all_edges = 0;})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a graph
 * structure.
 * @param Graph graph to be cleared. */
#define int32_EGalgMCgraphClear(Graph) ({\
	int32_EGsrkGraphClear(&((Graph)->G));\
	int32_EGlpNumClearVar((Graph)->epsilon);\
	int32_EGlpNumClearVar((Graph)->cut_val);})

/* ========================================================================= */
/** @brief Shrink two nodes in the graph, and update internal structures.
 * @param Graph current graph.
 * @param N node to keep in graph.
 * @param M node to shrink within N. */
#define int32_EGalgMCidentifyNodes(Graph,N,M) ({\
	int32_EGalgMCgraph_t*const _EGalgMCg = (Graph);\
	int32_EGalgMCnode_t*const _EGalgMCn = (N), *const _EGalgMCm = (M);\
	MESSAGE(int32___MC_DEBUG_,"Shrinking nodes with weight %lf %lf", \
					int32_EGlpNumToLf(_EGalgMCn->node.weight), \
					int32_EGlpNumToLf(_EGalgMCm->node.weight));\
	int32_EGsrkIdentifyNodes(&(_EGalgMCg->G), &(_EGalgMCn->node), &(_EGalgMCm->node));\
	if(_EGalgMCn->int32_lvl < 5)\
	{\
		EGeListDel(&(_EGalgMCm->lvl_cn));\
		EGeListMoveAfter(&(_EGalgMCn->lvl_cn), _EGalgMCg->lvl_list);\
	}\
	else EGeListAddAfter(&(_EGalgMCn->lvl_cn), _EGalgMCg->lvl_list);\
	_EGalgMCn->int32_lvl = 0;})

/* ========================================================================= */
/** @brief Identify all Padberg and Rinaldy edges. i.e. shrink all edges that
 * satisfy the conditions in their paper. we choose to make tests over pair of
 * nodes linked by an edge. 
 * @param max_lvl set a limit on wich tests to perform. for example, if set to
 * 1, only the first and second tests will be carried out.
 * @param G graph over wich we are working. 
 * @param cb call back structure to use (if set to NULL it is not used).
 * @return zero on success, non-zero otherwise. 
 *
 * Note that while doing this identification process, we update the values of
 * #int32_EGalgMCgraph_t::cut, #int32_EGalgMCgraph_t::cut_sz and #int32_EGalgMCgraph_t::cut_val,
 * as well as performing the actual shrinking procedure.
 *
 * The original theorem (for local conditions on shrinking) is the following:
 * Let @f$ Z @f$ be a proper subset of @f$ V @f$ (the set of all nodes in the
 * graph), @f$ |Z|\geq2 @f$, and let 
 * @f[ P(Z) = \bigcup\left\{ N(u)\cap N(v):u\neq v, u,v\in Z \right\} @f]
 * where @f$ N(u) @f$ if the set of neighbours of @f$ u @f$. If there exists
 * @f$ Y\subseteq P(Z) @f$ such that for every nonempty proper subset @f$ W
 * @f$ of @f$ Z @f$ and for every @f$ T\subseteq Y @f$ either:
 * -# @f$ w(\delta(W))/2 \leq w(W:(Y-T)+(Z-W)) @f$ or
 * -# @f$ w(\delta(Z-W))/2 \leq w(Z-W:T+W) @f$.
 * Then there exists a minimum cut @f$(X:V-X)@f$ such that either @f$
 * Z\subseteq X @f$ or @f$ X\subseteq Z @f$.
 *
 * And the original theorem (in fact is the corollary 3.5 in the paper) 
 * regarding global conditions for shrinking is the following:
 * Let @f$ u\neq v\in V @f$, and let @f$ q @f$ be an upper bound on the
 * minimum cut value, and @f$ lb_{uv} @f$ be a lower bound in the value of a
 * minimum @f$ u-v @f$ cut, then if @f$ lb_{uv}\geq q @f$ the set 
 * @f$ \{u,v\} @f$ is shrinkable.
 * 
 * The actual tests that we perform (for every edge) are the following:
 * -# If @f$ w(\delta(u)) < @f$ #int32_EGalgMCgraph_t::cut_val, update the minimum
 * cut value and set.
 * -# If @f$ w_{uv} \geq \min\{w(\delta(u)),w(\delta(v))\}/2 @f$ then we can 
 * safely shrink edge @f$ uv @f$.
 * -# If we have a triangle @f$ uv,\quad vw,\quad wu  @f$, with 
 * @f$ w_{uv} + w_{vw} \geq w(\delta(v))/2 @f$ and  
 * @f$ w_{uw} + w_{vw} \geq w(\delta(w))/2 @f$ then we can safely shrink edge
 * @f$ wv @f$.
 * -# Compute lower bound on the cut that separates the endpoints of the
 * current edge as :
 * @f[ lb_{uv}=w_{uv}+\sum\limits_{w\in N(u)\cap N(v)}\min\{w_{uw},w_{vw}\} @f]
 * If  @f$ lb_{uv} \geq  @f$ #int32_EGalgMCgraph_t::cut_val , then we can shrink the edge  @f$ uv @f$.
 * -# Consider the edge @f$ uv @f$ and two common neighbours @f$ x,y @f$. If  
 * @f$ w_{ux} + w_{uy} + w_{uv} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{vx} + w_{vy} + w_{vu} \geq w(\delta(v))/2 @f$ and at least one of 
 * @f$ w_{uv} + w_{uy} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{uv} + w_{vx} \geq w(\delta(v))/2 @f$ and at least one of 
 * @f$ w_{uv} + w_{ux} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{uv} + w_{vy} \geq w(\delta(v))/2 @f$ then we can safely shrink edge
 * @f$ uv @f$.
 *
 * We make thiese tests in order, i.e. first we perform all level 1 tests,
 * then level2, and so on, and whenever two nodes are Identify (shrinked) we
 * set the level of the node to 1 (i.e. in the next test we will test the
 * first condition). This is done using an array of (5) lists, where all nodes
 * are distributed. Originally all nodes should be in the first lists (i.e.
 * all nodes should be tested to improve the current best cut by themselves).
 * */
int int32_EGalgMCidentifyPRedges (int32_EGalgMCgraph_t * const G,
														int32_EGalgMCcbk_t * const cb,
														const unsigned int max_lvl);

/* ========================================================================= */
/** @brief Compute a minimum cut on the given graph. 
 * @param max_lvl set a limit on wich tests to perform during the
 * Padberg-Rinaldy shrinking step. for example, if set to
 * 1, only the first and second tests will be carried out.
 * @param G graph over wich we are working. 
 * @param cb call back structure to use (if set to NULL it is not used).
 * @return zero on success, non-zero otherwise. 
 *
 * This function takes as input a graph, and perform the minimum cut algorithm
 * as described in the paper "An Efficient 
 * Algorithm For The Minimum Capacity Cut Problem", Mathematical Programming
 * 47 (1990) pages 19-36. 
 *
 * Note that the graph should have all fields properly initialized.
 * */
int int32_EGalgMC (int32_EGalgMCgraph_t * const G,
						 int32_EGalgMCcbk_t * const cb,
						 const unsigned int max_lvl);

/* ========================================================================= */
/** @} 
 * end int32_eg_min_cut.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef int32___EG_NUMUTIL_H__
#define int32___EG_NUMUTIL_H__

/* ========================================================================= */
/** @defgroup EGlpNumUtil General Number Utilities
 * Here we put some utilities common for different number types but thaat we
 * want to implement as templates, like permutation sorting, inner product of
 * vectors, and so-on..
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2007-10-08
 *  					- Separate template file and independet file into eg_nummacros.h
 *  					- Move EGabs, EGswap, EGmin and EGmax to this file
 *  - 2005-10-31
 *  					- First implementation.
 * */
/** @{*/
/** @file
 * @brief This file provide the user interface and function definitions for
 * general number utilities.
 * */
/* ========================================================================= */
/** @brief compute the inner product of two arrays.
 * @param arr1 first array.
 * @param arr2 second array.
 * @param length number of entries to consider in both arrays, from zero to
 * length - 1.
 * @param rop where to store the result.
 * */
#define int32_EGlpNumInnProd(__rop,__arr1,__arr2,__length) int32___EGlpNumInnProd((&(__rop)),__arr1,__arr2,__length)
/* ========================================================================= */
/** @brief internal version, this is done to avoid using stdc99 and rely on
 * more basic stdc89 */
void int32___EGlpNumInnProd(int32_t*rop,int32_t*const arr1,int32_t*const arr2, const size_t length);
/* ========================================================================= */
/** @brief Sort (in increasing order) a sub-set of entries in an array using 
 * quicksort, by permutating the order of the elements in the subset rather 
 * than in the whole original array.
 * @param sz length of the permutation array.
 * @param perm array of indices of elements that we want to sort.
 * @param elem array (of length at least max(perm[k]:k=0,...,sz-1)) containing
 * the elements to be sorted.
 * @note The array of elements is not changed by this function.
 * @note This code is based in concorde's implementation of
 * permutation-quick-sort.
 * */
void int32_EGutilPermSort (const size_t sz,
										 int *const perm,
										 const int32_t * const elem);

/* ========================================================================= */
/** @brief Sort (in decreasing order) a sub-set of entries in an array using 
 * quicksort, by permutating the order of the elements in the subset rather 
 * than in the whole original array.
 * @param sz length of the permutation array.
 * @param perm array of indices of elements that we want to sort.
 * @param elem array (of length at least max(perm[k]:k=0,...,sz-1)) containing
 * the elements to be sorted.
 * @note The array of elements is not changed by this function.
 * @note This code is based in concorde's implementation of
 * permutation-quick-sort.
 * */
void int32_EGutilPermSort2 (const size_t sz,
										 int*const perm,
										 const int32_t*const elem);

/* ========================================================================= */
/** @}*/
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgDijkstra EGalgDijkstra
 * Dijkstra implementation with 2-heaps
 * */
/** @file
 * @ingroup EGalgDijkstra */
/** @addtogroup EGalgDijkstra */
/** @{ */
/** @example int32_eg_dijkstra.ex.c */
/* ========================================================================= */
#ifndef int32___EG_DIJKSTRA_H
#define int32___EG_DIJKSTRA_H
/* ========================================================================= */
/** @brief Verbosity Level */
#define int32_DJK_VRBLVL_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define int32_DJK_DEBUG_ 100

/* ========================================================================= */
/** @brief implement dijkstra.
 * */
int int32_EGalgDJK (
		int32_t const nnodes,
		int32_t const nedges,
		int32_t const*const ou_d,
		int32_t const*const ou_beg,
		int32_t const*const ou_e,
		int32_t const*const weight,
		int32_t const s,
		int32_t const nt,
		int32_t const*const t,
		int32_t*const father,
		int32_t*const dist
		);

/* ========================================================================= */
/** @brief read from a file in .x format (as in the concorde's .x files), the
 * format is as follows:
 * nnodes nedges
 * tail_1 head_1 weight_1
 * ...    ...    ....
 * tail_nnodes head_nnodes weight_nnodes
 * comments are allowed, if they start with % or #.
 * @param input file containing the data
 * @param n where to store the number of nodes
 * @param m where to store the number of edges
 * @param edges pointer to an array where to store the edges, note that memory
 * will be allocated in (*edges)
 * @param weight pointer to the array where we will store the weights, note
 * that this array will be allocated using int32_EGlpNumAllocArray, and should be
 * deallocated using int32_EGlpNumFreeArray.
 * @return zero on success, non-zero otherwise 
 * */
int int32_EGguReadXgraph(
		EGioFile_t*const input,
		int32_t*const n,
		int32_t*const m,
		int32_t**const edges,
		int32_t**const weight);
/* ========================================================================= */
/** @} 
 * end int32_eg_dijkstra.h */
#endif

#ifdef HAVE_LONG_DOUBLE
#if HAVE_LONG_DOUBLE
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef ldbl___EG_DMATRIX_H__
#define ldbl___EG_DMATRIX_H__

/* ========================================================================= */
/** @defgroup EGdMatrix Dense Matrices
 * Here we define a common interface for dense matrices (i.e. a structure), and
 * some common operations over dense matrices. The definition uses EGlpNum as
 * reference number type, this allow for template initializations.
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2005-10-27
 *  					- First implementation.
 * */
/** @{*/
/** @file
 * @brief This file provide the user interface and function definitions for
 * Dense Matrices.
 * */
/** @example ldbl_eg_dmatrix.ex.c */
/* ========================================================================= */
/** @brief structure to hold a dense matrix, we choose a row representation
 * of the matrix, and we allow row and column permutations. All actual values 
 * in the matrix are stored in #ldbl_EGdMatrix_t::matval, and the rows in
 * #ldbl_EGdMatrix_t::matrow. */
typedef struct ldbl_EGdMatrix_t
{
	size_t col_sz;		/**< @brief Number of columns in the matrix. */
	size_t row_sz;		/**< @brief Number of rows in the matrix */
	long double **matrow;
										/**< @brief Array of size #ldbl_EGdMatrix_t::row_sz containing 
												 all rows of the matrix */
	long double *matval;/**< @brief Values for all entries */
	int *col_ord;			/**< @brief Array of size at least #ldbl_EGdMatrix_t::col_sz 
												 containing the order ammong all columns i.e. it is a 
												 permutation of {0,....,col_sz-1} which is how the 
												 matrix is treated internally */
	int *row_ord;			/**< @brief Array of size at least #ldbl_EGdMatrix_t::row_sz 
												 containing the order ammong all rows, i.e. it is a 
												 permutation of {0,...,row_sz-1} which is how the 
												 matrix is treated internally */
}
ldbl_EGdMatrix_t;

/* ========================================================================= */
/** @brief Initialize (as a dense matrix of dimension 0x0) an #ldbl_EGdMatrix_t
 * structure.
 * @param __dmatrix dense matrix structure pointer.
 * */
#define ldbl_EGdMatrixInit(__dmatrix) memset(__dmatrix,0,sizeof(ldbl_EGdMatrix_t))

/* ========================================================================= */
/** @brief Clear a dense matrix structure, i.e. free all internally allocated
 * data of the structure. Note that no further use of the structure can be made
 * unless it is re-initialized and set to a suitable size.
 * @param __dmatrix dense matrix structure pointer.
 * */
#define ldbl_EGdMatrixClear(__dmatrix) do{\
	ldbl_EGdMatrix_t*const __EGdm = (__dmatrix);\
	ldbl_EGlpNumFreeArray(__EGdm->matval);\
	EGfree(__EGdm->matrow);\
	int_EGlpNumFreeArray(__EGdm->col_ord);\
	int_EGlpNumFreeArray(__EGdm->row_ord);} while(0)

/* ========================================================================= */
/** @brief Set new dimensions for a dense matrix structure.
 * @param __dmatrix dense matrix structure pointer.
 * @param __nnewrows number of rows in the matrix.
 * @param __nnewcols number of columns in the matrix.
 * @note Take care that the values stored in the matrix are not initialized to
 * any particular number. Also the ordering (for both column and row) is reset
 * to the standard ordering 0,....,n.
 * */
#define ldbl_EGdMatrixSetDimension(__dmatrix,__nnewrows,__nnewcols) do{\
	ldbl_EGdMatrix_t*const __EGdm = (__dmatrix);\
	register int __EGdmi;\
	__EGdm->col_sz = (__nnewcols);\
	__EGdm->row_sz = (__nnewrows);\
	ldbl_EGlpNumReallocArray(&(__EGdm->matval),__EGdm->col_sz * __EGdm->row_sz);\
	EGrealloc(__EGdm->matrow,__EGdm->row_sz * sizeof(long double*));\
	int_EGlpNumReallocArray(&(__EGdm->col_ord),__EGdm->col_sz);\
	int_EGlpNumReallocArray(&(__EGdm->row_ord),__EGdm->row_sz);\
	__EGdmi = (int)(__EGdm->col_sz);\
	while(__EGdmi--) __EGdm->col_ord[__EGdmi] = __EGdmi;\
	__EGdmi = (int)(__EGdm->row_sz);\
	while(__EGdmi--) \
		__EGdm->matrow[__EGdmi] = __EGdm->matval + ((size_t)(__EGdmi) * __EGdm->col_sz);\
	__EGdmi = (int)(__EGdm->row_sz);\
	while(__EGdmi--) __EGdm->row_ord[__EGdmi] = __EGdmi;} while(0)

/* ========================================================================= */
/** @brief Display a given #ldbl_EGdMatrix_t structure contents.
 * @param __dmatrix dense matrix structure pointer.
 * @param __nat_order if set to one, display the matrix using the natural 
 * internal order, i.e. we discard the order of columns and rows as defined in
 * #ldbl_EGdMatrix_t::col_ord and #ldbl_EGdMatrix_t::row_ord. Otherwise, use such orders.
 * @param __ofile pointer to a FILE structure where we want the output to be
 * printed.
 * */
#define ldbl_EGdMatrixDisplay(__dmatrix,__nat_order,__ofile) do{\
	ldbl_EGdMatrix_t*const __EGdm = (__dmatrix);\
	char* __EGdmstr = 0;\
	size_t __EGdmi, __EGdmj;\
	fprintf(__ofile,"Matrix %p\nDimensions: %zd rows, %zd columns\n", (void*)__EGdm, __EGdm->row_sz, __EGdm->col_sz);\
	if(__nat_order){\
		for(__EGdmi = 0 ; __EGdmi < __EGdm->row_sz ; __EGdmi++){\
			for(__EGdmj = 0 ; __EGdmj < __EGdm->col_sz ; __EGdmj++){\
				__EGdmstr = ldbl_EGlpNumGetStr(__EGdm->matrow[__EGdmi][__EGdmj]);\
				fprintf(__ofile,"%10s ", __EGdmstr);\
				EGfree(__EGdmstr);\
			}\
			fprintf(__ofile,"\n");}\
	} else {\
		for(__EGdmi = 0 ; __EGdmi < __EGdm->row_sz ; __EGdmi++){\
			for(__EGdmj = 0 ; __EGdmj < __EGdm->col_sz ; __EGdmj++){\
				__EGdmstr = ldbl_EGlpNumGetStr(__EGdm->matrow[__EGdm->row_ord[__EGdmi]][__EGdm->col_ord[__EGdmj]]);\
				fprintf(__ofile,"%10s ", __EGdmstr);\
				EGfree(__EGdmstr);\
			}\
			fprintf(__ofile,"\n");}\
	}} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set rows 
 * '__dest' to '__dest' + '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in row '__dest', and note that rows '__orig' and '__dest' should be different.
 * This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the row whose multiple will be added to the '__dest'
 * row.
 * @param '__dest' row to be replaced by '__dest' + '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' row.
 * @note The index of the row are taken as internal index, i.e. if we give row
 * 'k' we will use the row stored in #ldbl_EGdMatrix_t::matrow[k], wich does not
 * mean that we will access the k-th row in the matrix (wich would need to use
 * as index the value #ldbl_EGdMatrix_t::row_ord[k] instead). Note that we don't
 * test wether the given multiple is zero or not. we always perform the
 * operation.
 * */
#define ldbl_EGdMatrixAddRowMultiple(__dmatrix,__dest,__orig,__num) do{\
	ldbl_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (size_t)(__dest);\
	const size_t __EGori = (size_t)(__orig);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) \
		ldbl_EGlpNumAddInnProdTo(__EGdm->matrow[__EGdest][__EGdmj],\
												__EGdm->matrow[__EGori][__EGdmj],__num);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set rows 
 * '__dest' to '__dest' - '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in row '__dest', and note that rows '__orig' and '__dest' should be different.
 * This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the row whose multiple will be added to the '__dest'
 * row.
 * @param '__dest' row to be replaced by '__dest' - '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' row.
 * @note The index of the row are taken as internal index, i.e. if we give row
 * 'k' we will use the row stored in #ldbl_EGdMatrix_t::matrow[k], wich does not
 * mean that we will access the k-th row in the matrix (wich would need to use
 * as index the value #ldbl_EGdMatrix_t::row_ord[k] instead). Note that we don't
 * test wether the given multiple is zero or not. we always perform the
 * operation.
 * */
#define ldbl_EGdMatrixSubRowMultiple(__dmatrix,__dest,__orig,__num) do{\
	ldbl_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (__dest);\
	const size_t __EGori = (__orig);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) \
		ldbl_EGlpNumSubInnProdTo(__EGdm->matrow[__EGdest][__EGdmj],\
												__EGdm->matrow[__EGori][__EGdmj],__num);\
	} while(0)
/* ========================================================================= */
/** @brief Given a number and a row, multiply the complete row by the given
 * number. Note that the number MUST_NOT be stored in the row being multiplied,
 * this is because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param row_ind index of the row being multiplied, note that we will multiply
 * the row stored in #ldbl_EGdMatrix_t::matrow[row_ind], wich is different to say
 * that we multiply the row in the row_ind-th position in the row ordering (to
 * do that, then row_ind should be #ldbl_EGdMatrix_t::row_ord[k]).
 * @param multiple constant to be multiply to the row.
 * */
#define ldbl_EGdMatrixMultiplyRow(__dmatrix,row_ind,multiple) do{\
	ldbl_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdmi = (row_ind);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) ldbl_EGlpNumMultTo(__EGdm->matrow[__EGdmi][__EGdmj],multiple);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set columns 
 * '__dest' to '__dest' + '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in column '__dest', and note that columns '__orig' and '__dest' should be 
 * different. This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the column whose multiple will be added to the '__dest'
 * column.
 * @param '__dest' column to be replaced by '__dest' + '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' column.
 * @note The index of the column are taken as internal index, i.e. if we give 
 * column 'k' we will use the column stored in #ldbl_EGdMatrix_t::matrow[*][k], 
 * wich does not mean that we will access the k-th column in the matrix (wich
 * would need to use as index the value #ldbl_EGdMatrix_t::row_ord[k] instead). 
 * Note that we don't test wether the given multiple is zero or not. we 
 * always perform the operation.
 * */
#define ldbl_EGdMatrixAddColMultiple(__dmatrix,__dest,__orig,__num) do{\
	ldbl_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (__dest);\
	const size_t __EGori = (__orig);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) \
		ldbl_EGlpNumAddInnProdTo(__EGdm->matrow[__EGdmj][__EGdest],\
												__EGdm->matrow[__EGdmj][__EGori],__num);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set columns 
 * '__dest' to '__dest' - '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in column '__dest', and note that columns '__orig' and '__dest' should be 
 * different. This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the column whose multiple will be added to the '__dest'
 * column.
 * @param '__dest' column to be replaced by '__dest' - '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' column.
 * @note The index of the column are taken as internal index, i.e. if we give 
 * column 'k' we will use the column stored in #ldbl_EGdMatrix_t::matrow[*][k], 
 * wich does not mean that we will access the k-th column in the matrix (wich 
 * would need to use as index the value #ldbl_EGdMatrix_t::col_ord[k] instead). 
 * Note that we don't test wether the given multiple is zero or not. we 
 * always perform the operation.
 * */
#define ldbl_EGdMatrixSubColMultiple(__dmatrix,__dest,__orig,__num) do{\
	ldbl_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (size_t)(__dest);\
	const size_t __EGori = (size_t)(__orig);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) \
		ldbl_EGlpNumSubInnProdTo(__EGdm->matrow[__EGdmj][__EGdest],\
												__EGdm->matrow[__EGdmj][__EGori],__num);\
	} while(0)
/* ========================================================================= */
/** @brief Given a number and a column, multiply the complete column by the 
 * given number. Note that the number MUST_NOT be stored in the column being 
 * multiplied, this is because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param __colind index of the column being multiplied, note that we will 
 * multiply the column stored in #ldbl_EGdMatrix_t::matrow[*][__colind], wich is 
 * different to say that we multiply the column in the __colind-th position in
 * the column ordering (to do that, then __colind should be 
 * #ldbl_EGdMatrix_t::col_ord[k]).
 * @param __mult constant to be multiply to the column.
 * */
#define ldbl_EGdMatrixMultiplyCol(__dmatrix,__colind,__mult) do{\
	ldbl_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdmi = (__colind);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) ldbl_EGlpNumMultTo(__EGdm->matrow[__EGdmj][__EGdmi],__mult);\
	} while(0)


/* ========================================================================= */
/** @brief This function performs gaussian elimination to the given matrix,
 * depending on the given options it may do row/columns permutations allong the
 * way to improve numerical stabillity.
 * @param __dmatrix dense matrix structure pointer.
 * @param do_col_perm if set to one, the try columns permutation to improve
 * numericall stabillity, otherwise, not do column permutations at all.
 * @param do_row_perm if set to one, try row permutations to improve numericall
 * stabillity, otherwise, not do row permutations at all.
 * @param status pointer to where return an status, if the procedure finish all
 * the way (i.e. the matrix is full rank), then we return #EG_ALGSTAT_SUCCESS,
 * if the matrix is found to be partial rank, the status is
 * #EG_ALGSTAT_PARTIAL, otherwise, we return #EG_ALGSTAT_NUMERROR, wich means
 * that we stoped because a zero pivot was found (after checking for allowed
 * row/collumns permmutations).
 * @param rank where to return the (proven) rank of the matrix. This number is
 * accurate if the status is #EG_ALGSTAT_SUCCESS, or #EG_ALGSTAT_PARTIAL, but
 * is just a lower bound if the status is #EG_ALGSTAT_NUMERROR
 * @param zero_tol What is the threshold for a value to be considered zero.
 * @return if no error happen, we return zero, otherwise a non-zero valued is
 * returned. Note that the algorithm status is independent of the return value,
 * non zero values araise only if an error happen during execution, wich is
 * different to say that the algorithm didn't finish correctly. */
int ldbl_EGdMatrixGaussianElimination (ldbl_EGdMatrix_t * const __dmatrix,
																	const unsigned do_col_perm,
																	const unsigned do_row_perm,
																	unsigned *const rank,
																	const long double zero_tol,
																	int *const status);

/* ========================================================================= */
/** @}*/
#endif
#endif
#endif
#ifdef HAVE_LONG_DOUBLE
#if HAVE_LONG_DOUBLE
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef ldbl___EG_DBASIS_REDUCTION__
#define ldbl___EG_DBASIS_REDUCTION__
/* ========================================================================= */
/** @defgroup EGdBasisRed LLL Basis Reduction
 * Here we define a common interface for dense matrices (i.e. a structure), and
 * some common operations over dense matrices. The definition uses EGlpNum as
 * reference number type, this allow for template initializations.
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2005-10-28
 *  					- First implementation.
 * */
/**  @{ */
/** @file
 * @brief This file provide the user interface and function definitions for
 * the so-called LLL Basis Reduction Algorithm. This algorithm was first
 * presented in the paper "Factoring polynomials with rational coefficients",
 * Mathematische Annalen 261 (1981), p515-534. and has been extensivelly
 * studied elsewere. for more details just Google-it.
 * */
/** @example ldbl_eg_dmatrix.ex.c */
/* ========================================================================= */
/** @brief verbosity level */
#define ldbl_EG_DBSRED_VERBOSE 0

/* ========================================================================= */
/** @name Profiling structures and functions for the basis reduction algorithm.
 * */
/* @{ */
/* ========================================================================= */
/** @brief where to hold the profile information */
extern uintmax_t ldbl_EGdBsRedStats[10];

/* ========================================================================= */
/** @brief where we store the number of calls to #ldbl_EGdBsRed */
#define ldbl_EG_BSRED_CALLS 0

/* ========================================================================= */
/** @brief where we store the total number of size reductions performed in 
 * #ldbl_EGdBsRed */
#define ldbl_EG_BSRED_SZRED 1

/* ========================================================================= */
/** @brief where we store the total number of interchanges performed in 
 * #ldbl_EGdBsRed */
#define ldbl_EG_BSRED_INTR 2

/* ========================================================================= */
/** @brief where we store the total number of innermost loops performed in 
 * #ldbl_EGdBsRed */
#define ldbl_EG_BSRED_ITT 3

/* ========================================================================= */
/** @brief Print into the given file stream, the current statistics related
 * to the #ldbl_EGdBsRed algorithm. And reset all counters to zero.
 * @param __ofile where we want to print the profile information. */
#define ldbl_EGdBsRedProfile(__ofile) do{\
	fprintf(__ofile,"LLL Basis Reduction Statistics:\n");\
	fprintf(__ofile,"\tNumber Calls    : %ju\n", ldbl_EGdBsRedStats[ldbl_EG_BSRED_CALLS]);\
	fprintf(__ofile,"\tLoops           : %ju\n", ldbl_EGdBsRedStats[ldbl_EG_BSRED_ITT]);\
	fprintf(__ofile,"\tSize Reductions : %ju\n", ldbl_EGdBsRedStats[ldbl_EG_BSRED_SZRED]);\
	fprintf(__ofile,"\tInterchanges    : %ju\n", ldbl_EGdBsRedStats[ldbl_EG_BSRED_INTR]);\
	memset(ldbl_EGdBsRedStats,0,sizeof(ldbl_EGdBsRedStats));} while(0)

/* @} */

/* ========================================================================= */
/** @brief Value used in condition two of the LLL algorithm, remember that this
 * number should be between \f$(1/4,1)\f$. By default we choose \f$\lambda =
 * \frac{2^{20}-1}{2^{20}} \approx .99999904632568359375 \f$. */
#define ldbl_EG_DBSRED_ALPHA 0x7ffffp-20

/* ========================================================================= */
/** @brief structure to hold all necesary data to perform the LLL's basis
 * reduction algorithm. */
typedef struct ldbl_EGdBsRed_t
{
	size_t dim;				/**< @brief Number of elements in the basis */
	size_t length;		/**< @brief Length of the vectors in the basis, note that
												 it should be that length >= dim */
	size_t basis_sz;	/**< @brief Actual length of the #ldbl_EGdBsRed_t::basis 
												 array */
	long double **basis;/**< @brief array of pointers to arrays containing the 
												 vector basis in extended (including zero coef) form. 
												 The vectors themselves are considered as allocated 
												 outside. everything else is considered as internally
												 allocated. */
	ldbl_EGdMatrix_t GM;		/**< @brief Here we store and compute the Gram-Schmidt 
												 needed for the LLL basis reduction algorithm */
}
ldbl_EGdBsRed_t;

/* ========================================================================= */
/** @brief Initialize an #ldbl_EGdBsRed_t structure, as a basis with zero elements
 * of dimension zero.
 * @param __bsred pointer to an #ldbl_EGdBsRed_t structure.
 * */
#define ldbl_EGdBsRedInit(__bsred) do{\
	ldbl_EGdBsRed_t*const __EGdbs = (__bsred);\
	memset(__EGdbs,0,sizeof(ldbl_EGdBsRed_t));\
	ldbl_EGdMatrixInit(&(__EGdbs->GM));} while(0)

/* ========================================================================= */
/** @brief Free any internally allocated memory in a #ldbl_EGdBsRed_t structure.
 * @param __bsred pointer to an #ldbl_EGdBsRed_t structure.
 * */
#define ldbl_EGdBsRedClear(__bsred) do{\
	ldbl_EGdBsRed_t*const __EGdbs = (__bsred);\
	if(__EGdbs->basis) EGfree(__EGdbs->basis);\
	ldbl_EGdMatrixClear(&(__EGdbs->GM));} while(0)

/* ========================================================================= */
/** @brief reset an #ldbl_EGdBsRed_t structure as a basis without elements (note
 * that we do not reset the length of the vectors, just the number of vectors 
 * in the basis).
 * @param __bsred pointer to an #ldbl_EGdBsRed_t structure.
 * */
#define ldbl_EGdBsRedReset(__bsred) ((__bsred)->dim = 0)

/* ========================================================================= */
/** @brief set the length of the vectors used in the basis for an #ldbl_EGdBsRed_t
 * structure.
 * @param __bsred pointer to an #ldbl_EGdBsRed_t structure.
 * @param __new_length length of the vectors in the basis.
 * */
#define ldbl_EGdBsRedSetLength(__bsred,__new_length) ((__bsred)->length = (__new_length))

/* ========================================================================= */
/** @brief add a new vector to the basis.
 * @param __bsred pointer to an #ldbl_EGdBsRed_t structure.
 * @param __new_elem new vector to add to the basis.
 * */
#define ldbl_EGdBsRedAddElement(__bsred,__new_elem) do{\
	ldbl_EGdBsRed_t*const __EGdbs = (__bsred);\
	if(__EGdbs->basis_sz <= __EGdbs->dim){\
		__EGdbs->basis_sz += 10U;\
		EGrealloc(__EGdbs->basis,sizeof(long double*)*__EGdbs->basis_sz);}\
	__EGdbs->basis[__EGdbs->dim++] = (__new_elem);} while(0)

/* ========================================================================= */
/** @brief This function performs the so-called LLL basis reduction algorithm.
 * @param __bsred pointer to an #ldbl_EGdBsRed_t structure.
 * @param status where we return the status of the algorithm, if the algorithm
 * finish with non-zero reduced elements, the status is #EG_ALGSTAT_SUCCESS. if
 * the algorithm finish with some zero reduced vector, the status is
 * #EG_ALGSTAT_PARTIAL. if the algorithm stop because of numerical problems,
 * the status is #EG_ALGSTAT_NUMERROR.
 * @param zero_tol threshold for a number to be considered as zero.
 * @param dim pointer to a number where we return the dimension of the basis
 * that the algorithm could prove before running in any numerical problem. If
 * the algorithm stop with status #EG_ALGSTAT_SUCCESS, then this number should
 * be equal to #ldbl_EGdBsRed_t::dim. The vectors that we finish reducing are stored
 * in #ldbl_EGdMatrix_t::row_ord[0], ... , #ldbl_EGdMatrix_t::row_ord[dim], in the
 * #ldbl_EGdBsRed_t::GM matrix.
 * @return zero if the algorithm finish, non-zero if an unforeseen error occure
 * during execution. 
 * @par Details:
 * The implementation that we use introduce (as an heuristic step) the sorting
 * of the original basis vectors in increasing order according to their norms,
 * this simple step reduced the total running time of the algorithm, but does
 * not improve the theoretical running time. A second detail is that we only
 * compute the Gram-Schmidth coefficients only once (at the beggining of the
 * program), and then, we only update the changed entries for both operations
 * \a size \a reduction and \a interchange. The advantage of the approach is
 * that we save most Gram-Schmidth computations and also all the recomputations
 * of the inner products of the elements currently in the basis. Again, this
 * are improvements form the practical point of view, but not in practice. The
 * dissadvantage of this approach is that we do accumulate rounding errors in
 * the Gram-Schmidth coefficients allong the way, but if all original vectors
 * coefficients where integer (and not too big), then the error should not grow
 * too much. Still this may happen if the input basis is ill conditioned.
 * */
int ldbl_EGdBsRed (ldbl_EGdBsRed_t * const __bsred,
							unsigned *const dim,
							const long double zero_tol,
							int *const status);

/* ========================================================================= */
/**  @} */
#endif
#endif
#endif
#ifdef HAVE_LONG_DOUBLE
#if HAVE_LONG_DOUBLE
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGeHeap EGeHeap
 *
 * Here we define the basic interface for d-heaps as an embeded structure.
 * In this implementation the heap does not grow on the fly, meaning that it 
 * may fills-up during an add call, to avoid that, the user must call 
 * re-allocate when necesary. the heap start as a heap of size zero. 
 * This implementatioon is a minimum-heap implementatiton. Note also that the
 * internal connector array is shifted one position to the left. This is done 
 * so that the first element is in position 1, this also speed-up the 
 * computation of the parent and childrens of a given position.
 *
 * @version 0.0.1
 * @par History:
 * - 2010-09-05
 * 						- ldbl_EGeHeapClear will free any internal memory (even if it was
 * 						asked for by the user).
 * - 2005-07-14
 * 						- Add ldbl_EGeHeapEmpty to empty the heap (but keep its maximum
 * 							size)
 * 						- Add ldbl_EGeHeapIsFull to test wether a heap is full or not.
 * - 2005-07-07
 * 						- First Implementation
 * @note 
 * This implementatiton is designed as a template using as base the types of
 * @ref EGlpNum
 * */
/** @file 
 * @ingroup EGeHeap */
/** @addtogroup EGeHeap */
/** @{ */
/** @example ldbl_eg_eheap.ex.c
 * This is a simple example of the usage of heaps using @ref EGeHeap */
/* ========================================================================= */
#ifndef ldbl___EG_EHEAP__
#define ldbl___EG_EHEAP__
/* ========================================================================= */
/** @brief Debug level for the heap */
#ifndef ldbl_EG_EHEAP_DEBUG
#define ldbl_EG_EHEAP_DEBUG 1000
#endif

/* ========================================================================= */
/** @name Test macros, enabled only if debug level is high enough. */
/** @{ */
#if ldbl_EG_EHEAP_DEBUG <= DEBUG
#define ldbl_EGeHeapCHECK_CN(__hp2,__hcn2) EXIT(__hcn2->pos>=__hp2->sz,"Heap Connector possition %d out of range [0,%d]",__hcn2->pos,__hp2->sz)
#define ldbl_EGeHeapCHECK_NF(__hp2) EXIT(__hp2->sz >= __hp2->max_sz,"Heap "#__hp2" Is full, can't add an element")
#else
#define ldbl_EGeHeapCHECK_CN(__hp,__hcn) 
#define ldbl_EGeHeapCHECK_NF(__hp) 
#endif
/** @} */
/* ========================================================================= */
/** @brief Structure to store the information relevant to an element in the
 * heap. */
typedef struct 
{
	long double val;		/**< Value of this node in the heap */
	unsigned int pos;	/**< Position in the heap array for this node, if set to
												 #ldbl_EG_EHEAP_POISON, then the connector is not in any 
												 heap.*/
}
ldbl_EGeHeapCn_t;

/* ========================================================================= */
/** @brief Poison position for heap connector not in a heap. */
#define ldbl_EG_EHEAP_POISON UINT_MAX

/* ========================================================================= */
/** @brief Initialize a heap conector structure. This function will allocate any
 * interal memory not allocated by the user, it should be called only once, or
 * after a clear function call.
 * @param __hcn conector to initialize.
 * */
#define ldbl_EGeHeapCnInit(__hcn) ({ldbl_EGlpNumInitVar((__hcn)->val);(__hcn)->pos = ldbl_EG_EHEAP_POISON;})

/* ========================================================================= */
/** @brief Reset a heap conector to the same state as after an init call, this
 * function is provided only for completness.
 * @param __hcn conector to reset
 * */
#define ldbl_EGeHeapCnReset(__hcn) ((__hcn)->pos = ldbl_EG_EHEAP_POISON)

/* ========================================================================= */
/** @brief Free all internal memory used by this structured not allocated by the
 * user. This function should be called after an init call, and only once.
 * @param __hcn conector to clear.
 * */
#define ldbl_EGeHeapCnClear(__hcn) ldbl_EGlpNumClearVar((__hcn)->val)

/* ========================================================================= */
/** @brief Structure to hold a whole heap structure, this structure is designed
 * so that it can grow on the fly with a low cost */
typedef struct 
{
	ldbl_EGeHeapCn_t **cn;
	unsigned int d;
	unsigned int sz;
	unsigned int max_sz;
}
ldbl_EGeHeap_t;

/* ========================================================================= */
/** @brief Return one if the heap is full, zero otherwise.
 * @param __hp heat to check */
#define ldbl_EGeHeapIsFull(__hp) ({ldbl_EGeHeap_t*const __EGehp = (__hp); __EGehp->sz == __EGehp->max_sz;})

/* ========================================================================= */
/** @brief set the number of elements in hte heap to zero.
 * @param __hp heap to empty.
 * */
#define ldbl_EGeHeapEmpty(__hp) ((__hp)->sz = 0)

/* ========================================================================= */
/** @brief Initialize a heap as an empty heap (with no space for conectors).
 * @param __hp heap to initialize.
 * */
#define ldbl_EGeHeapInit(__hp) (*(__hp) = (ldbl_EGeHeap_t){0,0,0,0})

/* ========================================================================= */
/** @brief Reset the given heap as an empty heap (just as returned by the init
 * call.
 * @param __hp heap to reset 
 * */
#define ldbl_EGeHepReset(__hp) ldbl_EGeHeapResize(__hp,0)

/* ========================================================================= */
/** @brief Clear a heap structure, and free any internal memory (not allocated
 * by the user).
 * @param __hp heap to clear.
 * */
#define ldbl_EGeHeapClear(__hp) ldbl_EGeHeapResize(__hp,0)

/* ========================================================================= */
/** @brief get the minimum value in the heap.
 * @param __hp heap where we are working.
 * @param number where to store the result
 * @return zero on success, non-zero otherwise.
 * */
#define ldbl_EGeHeapGetMinVal(__hp,number) ({\
	ldbl_EGeHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? (ldbl_EGlpNumCopy(number,__EGehp->cn[0]->val),0):1;})

/* ========================================================================= */
/** @brief get the minimum conector in the heap, if the heap is empty, return
 * NULL.
 * @param __hp eap where we are working.
 * @return pointer to the minimum element in the heap.
 * */
#define ldbl_EGeHeapGetMin(__hp) ({\
	ldbl_EGeHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? __EGehp->cn[0] : 0;})

/* ========================================================================= */
/** @brief resize the heap cn array to the given size, if the new size is zero,
 * it is equivalent to free the internal memory, and left the heap as an empty
 * heap with zero space.
 * @param __hp heap where we are working.
 * @param new_sz new size for the  cn array .
 * */
#define ldbl_EGeHeapResize(__hp,new_sz) ({\
	ldbl_EGeHeap_t*const __EGehp = (__hp);\
	const size_t __EGehp_nsz = (size_t)(new_sz);\
	__EGehp->cn = EGrealloc((__EGehp->cn), __EGehp_nsz * sizeof(ldbl_EGeHeapCn_t*));\
	__EGehp->max_sz = (unsigned int)(__EGehp_nsz);})

/* ========================================================================= */
/** @brief return the index of the father of the given index.
 * @param __d breadth of the heap.
 * @param __id position in the array to wich we want to compute it's father.
 * */
#define ldbl_EGeHeapFatherId(__d,__id) ((__id)?(((__id)-1)/(__d)):0)

/* ========================================================================= */
/** @brief move an element in the heap up in the heap (position 0 is the top,
 * this kind of move is neded whenever we decrease the value in a heap element).
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * */
#define ldbl_EGeHeapSiftUp(__hp,__hcn) ({\
	ldbl_EGeHeap_t*const __EGehp = (__hp);\
	ldbl_EGeHeapCn_t*const __EGecn = (__hcn);\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfpos = ldbl_EGeHeapFatherId(__EGehp->d,__EGcpos);\
	ldbl_EGeHeapCn_t*__EGfcn = __EGehp->cn[__EGfpos];\
	ldbl_EGeHeapCHECK_CN(__EHehp,__EGecn);\
	while(__EGcpos && \
				ldbl_EGlpNumIsLess(__EGecn->val,__EGfcn->val))\
	{\
		__EGfcn->pos = __EGcpos;\
		__EGehp->cn[__EGcpos] = __EGfcn;\
		__EGcpos = __EGfpos;\
		__EGfpos = ldbl_EGeHeapFatherId(__EGehp->d,__EGcpos);\
		__EGfcn = __EGehp->cn[__EGfpos];\
	}\
	__EGecn->pos = __EGcpos;\
	__EGehp->cn[__EGcpos] = __EGecn;\
	0;})

/* ========================================================================= */
/** @brief Add an element to the heap
 * @param __hp heap where to add the element.
 * @param __hcn element to be added.
 * @return zero on success, non-zero otherwise.
 * */
#define ldbl_EGeHeapAdd(__hp,__hcn) ({\
	ldbl_EGeHeap_t*const __EGlhp = (__hp);\
	ldbl_EGeHeapCn_t*const __EGlcn = (__hcn);\
	ldbl_EGeHeapCHECK_NF(__EGlhp);\
	__EGlcn->pos = __EGlhp->sz, \
	__EGlhp->cn[__EGlhp->sz] = __EGlcn;\
	__EGlhp->sz +=1, \
	ldbl_EGeHeapSiftUp(__EGlhp,__EGlcn), 0;})

/* ========================================================================= */
/** @brief Give the first child for a given position.
 * @param __id position that we want to get the first child.
 * @param __d breath of the heap. */
#define ldbl_EGeHeapFirstChildId(__d,__id) ((__d)*(__id)+1)

/* ========================================================================= */
/** @brief Move an element down in the heap (position 0 is the
 * top), this kind of operation is needed whenever we increase the value in a
 * heap element.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define ldbl_EGeHeapSiftDown(__hp,__hcn) ({\
	ldbl_EGeHeap_t*const __EGehp = (__hp);\
	ldbl_EGeHeapCn_t*const __EGecn = (__hcn);\
	const unsigned int __EGhsz = __EGehp->sz;\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfchd = ldbl_EGeHeapFirstChildId(__EGehp->d,__EGcpos);\
	unsigned int __EGlchd = __EGfchd + __EGehp->d;\
	ldbl_EGeHeapCn_t*__EGcchd = 0;\
	register unsigned int __EGehi = 0;\
	ldbl_EGeHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGfchd < __EGhsz)\
	{\
		/* detect the minimum child */\
		__EGcchd = __EGehp->cn[__EGfchd];\
		for(__EGehi = __EGlchd > __EGhsz ? __EGhsz-1 : __EGlchd-1 ;\
			__EGehi > __EGfchd ; __EGehi--)\
			if(ldbl_EGlpNumIsLess(__EGehp->cn[__EGehi]->val,__EGcchd->val))\
				__EGcchd = __EGehp->cn[__EGehi];\
		/* if the minimum child is less than the current position, move the minimum\
		 * child to the position of the current element */\
		if(ldbl_EGlpNumIsLess(__EGcchd->val,__EGecn->val))\
		{\
			__EGfchd = __EGcchd->pos;\
			__EGcchd->pos = __EGcpos;\
			__EGehp->cn[__EGcpos] = __EGcchd;\
			__EGecn->pos = __EGcpos = __EGfchd;\
			__EGehp->cn[__EGcpos] = __EGecn;\
			__EGfchd = ldbl_EGeHeapFirstChildId(__EGehp->d,__EGcpos);\
			__EGlchd = __EGfchd + __EGehp->d;\
		}\
		/* else we exit the main loop */\
		else __EGfchd = UINT_MAX;\
	}\
	0;})

/* ========================================================================= */
/** @brief Change the value of an element in the heap.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap that we are going to change it's value.
 * @param __new_val new value for the element.
 * @return zero on success, non-zero otherwise.
 * */
#define ldbl_EGeHeapChangeVal(__hp,__hcn,__new_val) ({\
	(ldbl_EGlpNumIsLess(__new_val,(__hcn)->val)) ? (ldbl_EGlpNumCopy((__hcn)->val,__new_val),ldbl_EGeHeapSiftUp(__hp,__hcn)) : (ldbl_EGlpNumCopy((__hcn)->val,__new_val),ldbl_EGeHeapSiftDown(__hp,__hcn));})

/* ========================================================================= */
/** @brief Eliminate an element from the heap, note that the position stored in
 * the eliminated element is reset to zero.
 * @param __hp heap where we are working.
 * @param __hcn element to eliminate from the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define ldbl_EGeHeapDel(__hp,__hcn) ({\
	ldbl_EGeHeap_t*const __EGlhp = (__hp);\
	ldbl_EGeHeapCn_t*const __EGlhpcn = (__hcn);\
	unsigned int const __EGlcn = __EGlhpcn->pos;\
	unsigned int const __EGlhsz = __EGlhp->sz - 1;\
	__EGlhpcn->pos = ldbl_EG_EHEAP_POISON;\
	__EGlhp->sz = __EGlhsz;\
	if(__EGlhsz && __EGlhsz != __EGlcn){\
		__EGlhp->cn[__EGlcn] = __EGlhp->cn[__EGlhp->sz];\
		__EGlhp->cn[__EGlcn]->pos = __EGlcn;\
		ldbl_EGeHeapSiftDown(__EGlhp,__EGlhp->cn[__EGlcn]);}\
	__EGlhp->cn[__EGlhp->sz] = 0;})

/* ========================================================================= */
/** @brief Check the integrity of the given heap.
 * @param __hp heap to check.
 * @return zero on success, non-zero otherwise.
 * */
#if ldbl_EG_EHEAP_DEBUG <= DEBUG
#define ldbl_EGeHeapCheck(__hp) ({\
	ldbl_EGeHeap_t*const __EGehp = (__hp);\
	register unsigned int __EGehi = __EGehp->sz;\
	if(__EGehi)\
		while(--__EGehi)\
			if(__EGehp->cn[__EGehi]->pos != __EGehi || ldbl_EGlpNumIsLess( __EGehp->cn[\
				 __EGehi]->val,__EGehp->cn[ldbl_EGeHeapFatherId(__EGehp->d,__EGehi)]->val))\
			{\
				MESSAGE(ldbl_EG_EHEAP_DEBUG,"Element %u is wrong, pos %u val [%lf,%lf]"\
							 ,__EGehi, __EGehp->cn[__EGehi]->pos, \
							 ldbl_EGlpNumToLf(__EGehp->cn[__EGehi]->val), \
							 ldbl_EGlpNumToLf(__EGehp->cn[ldbl_EGeHeapFatherId(__EGehp->d,__EGehi)]->val));\
				break;\
			}\
	__EGehi;})
#else
#define ldbl_EGeHeapCheck(__hp) 0
#endif

/* ========================================================================= */
/** @brief set the breath of the heap, this function must be called only when
 * the heap is empty.
 * @param __hp heap to set breath.
 * @param __width new with for the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define ldbl_EGeHeapChangeD(__hp,__width) ({\
	ldbl_EGeHeap_t*const __EGehp = (__hp);\
	EXIT((__width)<2,"Width should be at least 2 for heaps");\
	__EGehp->sz ? 1 : (__EGehp->d = (__width), 0);})

/* ========================================================================= */
/** @} */
/* end of ldbl_eg_eheap.h */
#endif
#endif
#endif
#ifdef HAVE_LONG_DOUBLE
#if HAVE_LONG_DOUBLE
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGeKHeap EGeKHeap
 *
 * Here we define the basic interface for d-heaps with an array of values with
 * the lexicographic order for vectors as an embeded structure.
 * In this implementation the heap does not grow on the fly, meaning that it 
 * may fill-up during an add call, to avoid that, the user must call 
 * re-allocate when necesary. the heap start as a heap of size zero. 
 * This implementatioon is a minimum-heap implementatiton. Note also that the
 * internal connector array is shifted one position to the left. This is done 
 * so that the first element is in position 1, this also speed-up the 
 * computation of the parent and childrens of a given position.
 *
 * @version 0.0.1
 * @par History:
 * - 2010-09-05
 * 						- Change implementation of ldbl_EGeKHeapClear to free all internal
 * 						memory, including the one asked for the user during a
 * 						ldbl_EGeKHeapResize call.
 * - 2008-07-30
 * 						- First implementation
 * @note 
 * This implementatiton is designed as a template using as base the types of
 * @ref EGlpNum
 * */
/** @file 
 * @ingroup EGeKHeap */
/** @addtogroup EGeKHeap */
/** @{ */
/** @example ldbl_eg_ekheap.ex.c
 * This is a simple example of the usage of heaps using @ref EGeKHeap */
/* ========================================================================= */
#ifndef ldbl___EG_EKHEAP__
#define ldbl___EG_EKHEAP__
/* ========================================================================= */
/** @brief Debug level for the heap */
#ifndef ldbl_EG_EKHEAP_DEBUG
#define ldbl_EG_EKHEAP_DEBUG 100
#endif

/* ========================================================================= */
/** @name Test macros, enabled only if debug level is high enough. */
/** @{ */
#if ldbl_EG_EKHEAP_DEBUG <= DEBUG
#define ldbl_EGeKHeapCHECK_CN(__hp2,__hcn2) EXIT(__hcn2->pos>=__hp2->sz,"Heap Connector possition %d out of range [0,%d]",__hcn2->pos,__hp2->sz)
#define ldbl_EGeKHeapCHECK_NF(__hp2) EXIT(__hp2->sz >= __hp2->max_sz,"Heap "#__hp2" Is full, can't add an element")
#else
#define ldbl_EGeKHeapCHECK_CN(__hp,__hcn) 
#define ldbl_EGeKHeapCHECK_NF(__hp) 
#endif
/** @} */
/* ========================================================================= */
/** @brief number of maximum entries in the vector values */
#ifndef ldbl_EG_EKHEAP_ENTRY
#define ldbl_EG_EKHEAP_ENTRY 3
#endif
/* ========================================================================= */
/** @brief Structure to store the information relevant to an element in the
 * heap. */
typedef struct
{
	long double val[ldbl_EG_EKHEAP_ENTRY];/**< Value of this node in the heap */
	unsigned int pos;	/**< Position in the heap array for this node, if set to
												 #ldbl_EG_EKHEAP_POISON, then the connector is not in any 
												 heap.*/
}
ldbl_EGeKHeapCn_t;

/* ========================================================================= */
/** @brief Poison position for heap connector not in a heap. */
#define ldbl_EG_EKHEAP_POISON UINT_MAX

/* ========================================================================= */
/** @brief Initialize a heap conector structure. This function will allocate any
 * interal memory not allocated by the user, it should be called only once, or
 * after a clear function call.
 * @param __hcn conector to initialize.
 * */
#define ldbl_EGeKHeapCnInit(__hcn) do{\
	ldbl_EGeKHeapCn_t*const __EKHcn = (__hcn);\
	int __EKHi = ldbl_EG_EKHEAP_ENTRY;\
	memset(__EKHcn,0,sizeof(ldbl_EGeKHeapCn_t));\
	for( ; __EKHi-- ; ){ldbl_EGlpNumInitVar(__EKHcn->val[__EKHi]);}\
	__EKHcn->pos = ldbl_EG_EKHEAP_POISON;}while(0)

/* ========================================================================= */
/** @brief Reset a heap conector to the same state as after an init call, this
 * function is provided only for completness.
 * @param __hcn conector to reset
 * */
#define ldbl_EGeKHeapCnReset(__hcn) ((__hcn)->pos = ldbl_EG_EKHEAP_POISON)

/* ========================================================================= */
/** @brief Free all internal memory used by this structured not allocated by the
 * user. This function should be called after an init call, and only once.
 * @param __hcn conector to clear.
 * */
#define ldbl_EGeKHeapCnClear(__hcn) do{\
	ldbl_EGeKHeapCn_t*const __EKHcn = (__hcn);\
	int __EKHi = ldbl_EG_EKHEAP_ENTRY;\
	for( ; __EKHi-- ; ){ldbl_EGlpNumClearVar(__EKHcn->val[__EKHi]);}}while(0)

/* ========================================================================= */
/** @brief Structure to hold a whole heap structure, this structure is designed
 * so that it can grow on the fly with a low cost */
typedef struct
{
	ldbl_EGeKHeapCn_t **cn;
	unsigned int d;
	unsigned int sz;
	unsigned int max_sz;
}
ldbl_EGeKHeap_t;

/* ========================================================================= */
/** @brief Return one if the heap is full, zero otherwise.
 * @param __hp heat to check */
#define ldbl_EGeKHeapIsFull(__hp) ({ldbl_EGeKHeap_t*const __EGekhp = (__hp); __EGekhp->sz == __EGekhp->max_sz;})

/* ========================================================================= */
/** @brief set the number of elements in hte heap to zero.
 * @param __hp heap to empty.
 * */
#define ldbl_EGeKHeapEmpty(__hp) ((__hp)->sz = 0)

/* ========================================================================= */
/** @brief Initialize a heap as an empty heap (with no space for conectors).
 * @param __hp heap to initialize.
 * */
#define ldbl_EGeKHeapInit(__hp) (*(__hp) = (ldbl_EGeKHeap_t){0,0,0,0})

/* ========================================================================= */
/** @brief Reset the given heap as an empty heap (just as returned by the init
 * call.
 * @param __hp heap to reset 
 * */
#define ldbl_EGeKHepReset(__hp) ldbl_EGeKHeapResize(__hp,0)

/* ========================================================================= */
/** @brief Clear a heap structure, and free any internal memory (not allocated
 * by the user).
 * @param __hp heap to clear.
 * */
#define ldbl_EGeKHeapClear(__hp) ldbl_EGeKHeapResize(__hp,0)

/* ========================================================================= */
/** @brief get the minimum value in the heap, note that since we are dealing
 * with a vector of values sorted lexicographically, the value is the value in
 * the first coordinate, other values can be accesses through
 * ldbl_EGeKHeapGetMinKVal function.
 * @param __hp heap where we are working.
 * @param __number where to store the result
 * @return zero on success, non-zero otherwise.
 * */
#define ldbl_EGeKHeapGetMinVal(__hp,__number) ({\
	ldbl_EGeKHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? (ldbl_EGlpNumCopy(__number,__EGehp->cn[0]->val[0]),0):1;})

/* ========================================================================= */
/** @brief get the k-th value of the first element in the heap.
 * @param __hp heap where we are working.
 * @param __number where to store the result.
 * @param __k which value to get (between 0 and ldbl_EG_EKHEAP_ENTRY.
 * @return zero on success, non-zero otherwise.
 * */
#define ldbl_EGeKHeapGetMinKVal(__hp,__k,__number) ({\
	ldbl_EGeKHeap_t*const __EGehp = (__hp);\
	const int __EGki = (__k);\
	EXITL(ldbl_EG_EKHEAP_DEBUG,(__EGki >= ldbl_EG_EKHEAP_ENTRY) || (__EGki <0),\
				"K=%d out of range in ldbl_EGeKHeapGetMinKVal", __EGki);\
	__EGehp->sz ? (ldbl_EGlpNumCopy(__number,__EGehp->cn[0]->val[__EGki]),0):1;})

/* ========================================================================= */
/** @brief get the minimum conector in the heap, if the heap is empty, return
 * NULL.
 * @param __hp eap where we are working.
 * @return pointer to the minimum element in the heap.
 * */
#define ldbl_EGeKHeapGetMin(__hp) ({\
	ldbl_EGeKHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? __EGehp->cn[0] : 0;})

/* ========================================================================= */
/** @brief resize the heap cn array to the given size, if the new size is zero,
 * it is equivalent to free the internal memory, and left the heap as an empty
 * heap with zero space.
 * @param __hp heap where we are working.
 * @param __new_sz new size for the  cn array .
 * */
#define ldbl_EGeKHeapResize(__hp,__new_sz) ({\
	ldbl_EGeKHeap_t*const __EGehp = (__hp);\
	const size_t __EGehp_nsz = (size_t)(__new_sz);\
	__EGehp->cn = EGrealloc((__EGehp->cn), __EGehp_nsz * sizeof(ldbl_EGeKHeapCn_t*));\
	__EGehp->max_sz = (unsigned int)(__EGehp_nsz);})

/* ========================================================================= */
/** @brief return the index of the father of the given index.
 * @param __d breadth of the heap.
 * @param __id position in the array to wich we want to compute it's father.
 * */
#define ldbl_EGeKHeapFatherId(__d,__id) ((__id)?(((__id)-1)/(__d)):0)

/* ========================================================================= */
/** @brief given two heap connectors, return one if the first is less than the
 * second (in  lexicographic order).
 * @param __hcn1 first vector array.
 * @param __hcn2 second vector array.
 * @return one if __hcn1 <_LEX __hcn2 */
#define ldbl_EGeKHeapIsLess(__hcn1,__hcn2) ({\
	long double*const __EGEKH1 = (__hcn1);\
	long double*const __EGEKH2 = (__hcn2);\
	int __EGEKHj = 0, __EGEKHrval = 0;\
	for( ; __EGEKHj < ldbl_EG_EKHEAP_ENTRY ; __EGEKHj++)\
	{\
		if(ldbl_EGlpNumIsLess(__EGEKH1[__EGEKHj], __EGEKH2[__EGEKHj])){\
			__EGEKHrval = 1; break;}\
		else if (ldbl_EGlpNumIsNeq(__EGEKH1[__EGEKHj], __EGEKH2[__EGEKHj],ldbl_epsLpNum)){\
			__EGEKHrval = 0; break;}\
	}\
	__EGEKHrval;})

/* ========================================================================= */
/** @brief copy two vector of values (only  ldbl_EG_EKHEAP_ENTRY positions) from the
 * rource to the destination.
 * @param src ldbl_source array.
 * @param dst destination array.
 * */
void ldbl_EGeKHeapCopyVal(long double*const dst, const long double*const src);

/* ========================================================================= */
/** @brief move an element in the heap up in the heap (position 0 is the top,
 * this kind of move is neded whenever we decrease the value in a heap element).
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define ldbl_EGeKHeapSiftUp(__hp,__hcn) ({\
	ldbl_EGeKHeap_t*const __EGehp = (__hp);\
	ldbl_EGeKHeapCn_t*const __EGecn = (__hcn);\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfpos = ldbl_EGeKHeapFatherId(__EGehp->d,__EGcpos);\
	ldbl_EGeKHeapCn_t*__EGfcn = __EGehp->cn[__EGfpos];\
	ldbl_EGeKHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGcpos && \
				ldbl_EGeKHeapIsLess(__EGecn->val,__EGfcn->val))\
	{\
		__EGfcn->pos = __EGcpos;\
		__EGehp->cn[__EGcpos] = __EGfcn;\
		__EGcpos = __EGfpos;\
		__EGfpos = ldbl_EGeKHeapFatherId(__EGehp->d,__EGcpos);\
		__EGfcn = __EGehp->cn[__EGfpos];\
	}\
	__EGecn->pos = __EGcpos;\
	__EGehp->cn[__EGcpos] = __EGecn;\
	0;})

/* ========================================================================= */
/** @brief Add an element to the heap
 * @param __hp heap where to add the element.
 * @param __hcn element to be added.
 * @return zero on success, non-zero otherwise.
 * */
#define ldbl_EGeKHeapAdd(__hp,__hcn) ({\
	ldbl_EGeKHeap_t*const __EGlhp = (__hp);\
	ldbl_EGeKHeapCn_t*const __EGlcn = (__hcn);\
	ldbl_EGeKHeapCHECK_NF(__EGlhp);\
	__EGlcn->pos = __EGlhp->sz, \
	__EGlhp->cn[__EGlhp->sz] = __EGlcn, \
	__EGlhp->sz +=1, \
	ldbl_EGeKHeapSiftUp(__EGlhp,__EGlcn), 0;})

/* ========================================================================= */
/** @brief Give the first child for a given position.
 * @param __id position that we want to get the first child.
 * @param __d breath of the heap. */
#define ldbl_EGeKHeapFirstChildId(__d,__id) ((__d)*(__id)+1)

/* ========================================================================= */
/** @brief Move an element down in the heap (position 0 is the
 * top), this kind of operation is needed whenever we increase the value in a
 * heap element.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define ldbl_EGeKHeapSiftDown(__hp,__hcn) ({\
	ldbl_EGeKHeap_t*const __EGehp = (__hp);\
	ldbl_EGeKHeapCn_t*const __EGecn = (__hcn);\
	const unsigned int __EGhsz = __EGehp->sz;\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfchd = ldbl_EGeKHeapFirstChildId(__EGehp->d,__EGcpos);\
	unsigned int __EGlchd = __EGfchd + __EGehp->d;\
	ldbl_EGeKHeapCn_t*__EGcchd = 0;\
	register unsigned int __EGehi = 0;\
	ldbl_EGeKHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGfchd < __EGhsz)\
	{\
		/* detect the minimum child */\
		__EGcchd = __EGehp->cn[__EGfchd];\
		for(__EGehi = __EGlchd > __EGhsz ? __EGhsz-1 : __EGlchd-1 ;\
			__EGehi > __EGfchd ; __EGehi--)\
			if(ldbl_EGeKHeapIsLess(__EGehp->cn[__EGehi]->val,__EGcchd->val))\
				__EGcchd = __EGehp->cn[__EGehi];\
		/* if the minimum child is less than the current position, move the minimum\
		 * child to the position of the current element */\
		if(ldbl_EGeKHeapIsLess(__EGcchd->val,__EGecn->val))\
		{\
			__EGfchd = __EGcchd->pos;\
			__EGcchd->pos = __EGcpos;\
			__EGehp->cn[__EGcpos] = __EGcchd;\
			__EGecn->pos = __EGcpos = __EGfchd;\
			__EGehp->cn[__EGcpos] = __EGecn;\
			__EGfchd = ldbl_EGeKHeapFirstChildId(__EGehp->d,__EGcpos);\
			__EGlchd = __EGfchd + __EGehp->d;\
		}\
		/* else we exit the main loop */\
		else __EGfchd = UINT_MAX;\
	}\
	0;})

/* ========================================================================= */
/** @brief Change the value of an element in the heap.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap that we are going to change it's value.
 * @param __new_val new value for the element (note this is an array of size at
 * least ldbl_EG_EKHEAP_ENTRY.
 * @return zero on success, non-zero otherwise.
 * */
#define ldbl_EGeKHeapChangeVal(__hp,__hcn,__new_val) ({\
	ldbl_EGeKHeapCn_t*const __EGEKHcn = (__hcn);\
	(ldbl_EGeKHeapIsLess(__new_val,(__EGEKHcn)->val)) ? (ldbl_EGeKHeapCopyVal((__EGEKHcn)->val,__new_val),ldbl_EGeKHeapSiftUp(__hp,__EGEKHcn)) : (ldbl_EGeKHeapCopyVal((__EGEKHcn)->val,__new_val),ldbl_EGeKHeapSiftDown(__hp,__EGEKHcn));})

/* ========================================================================= */
/** @brief Eliminate an element from the heap, note that the position stored in
 * the eliminated element is reset to zero.
 * @param __hp heap where we are working.
 * @param __hcn element to eliminate from the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define ldbl_EGeKHeapDel(__hp,__hcn) ({\
	ldbl_EGeKHeap_t*const __EGlhp = (__hp);\
	ldbl_EGeKHeapCn_t*const __EGlhpcn = (__hcn);\
	unsigned int const __EGlcn = __EGlhpcn->pos;\
	unsigned int const __EGlhsz = __EGlhp->sz - 1;\
	__EGlhpcn->pos = ldbl_EG_EKHEAP_POISON;\
	__EGlhp->sz = __EGlhsz;\
	if(__EGlhsz && __EGlhsz != __EGlcn){\
		__EGlhp->cn[__EGlcn] = __EGlhp->cn[__EGlhp->sz];\
		__EGlhp->cn[__EGlcn]->pos = __EGlcn;\
		ldbl_EGeKHeapSiftDown(__EGlhp,__EGlhp->cn[__EGlcn]);}\
	__EGlhp->cn[__EGlhp->sz] = 0;})

/* ========================================================================= */
/** @brief Check the integrity of the given heap.
 * @param __hp heap to check.
 * @return zero on success, non-zero otherwise.
 * */
#if ldbl_EG_EKHEAP_DEBUG <= DEBUG
#define ldbl_EGeKHeapCheck(__hp) ({\
	ldbl_EGeKHeap_t*const __EGehp = (__hp);\
	register unsigned int __EGehi = __EGehp->sz;\
	if(__EGehi)\
		while(--__EGehi)\
			if(__EGehp->cn[__EGehi]->pos != __EGehi || \
				ldbl_EGeKHeapIsLess( __EGehp->cn[__EGehi]->val,\
												__EGehp->cn[ldbl_EGeKHeapFatherId(__EGehp->d,__EGehi)]->val))\
			{\
				MESSAGE(ldbl_EG_EKHEAP_DEBUG,"Element %u is wrong, pos %u val [%lf,%lf]"\
							 ,__EGehi, __EGehp->cn[__EGehi]->pos, \
							 ldbl_EGlpNumToLf(__EGehp->cn[__EGehi]->val[0]), \
							 ldbl_EGlpNumToLf(__EGehp->cn[ldbl_EGeKHeapFatherId(__EGehp->d,__EGehi)]->val[0]));\
				break;\
			}\
	__EGehi;})
#else
#define ldbl_EGeKHeapCheck(__hp) 0
#endif

/* ========================================================================= */
/** @brief set the breath of the heap, this function must be called only when
 * the heap is empty.
 * @param __hp heap to set breath.
 * @param __width new with for the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define ldbl_EGeKHeapChangeD(__hp,__width) ({\
	ldbl_EGeKHeap_t*const __EGehp = (__hp);\
	EXIT((__width)<2,"Width should be at least 2 for heaps");\
	__EGehp->sz ? 1 : (__EGehp->d = (__width), 0);})

/* ========================================================================= */
/** @} */
/* end of ldbl_eg_ekheap.h */
#endif
#endif
#endif
#ifdef HAVE_LONG_DOUBLE
#if HAVE_LONG_DOUBLE
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGsrkGraph EGsrkGraph
 * This is a group of functions, macros and types designed to work with
 * graphs that are shrinkable, meaning that we can take two nodes in the
 * (current) graph, and shrink them into a single node, and at the same time
 * collapse all edges that become loops and if two edges are parallel, keep
 * just one (but keep a reference to the collapsed edge). At the same time the
 * shrunken nodes keep a list to the nodes 'embeded' or 'shrunken' into the
 * given node. More details in the structure definition and in the example.
 * Note that this implementation only support undirected graphs with actual
 * weights on the edges, the weights must be of type long double, and their
 * values are updated during the shrinking procedure, so if anyone want to
 * have the original values omewere else, they will have to keep an extra copy
 * outside. Most of the ideas used in this implementation come from CONCORDE.
 * 
 * @version 0.0.1
 * @par History:
 * - 2005-06-01
 * 						- First Implementation.
 * */
/** @file
 * @ingroup EGsrkGraph */
/** @addtogroup EGsrkGraph */
/** @{ */
/** @example ldbl_eg_shrink_graph.ex.c */
/* ========================================================================= */

#ifndef ldbl__EGshrinkGraph_h__
#define ldbl__EGshrinkGraph_h__
#ifndef ldbl_EG_SRK_DEBUG
/* ========================================================================= */
/** @brief debuigging level, the lower the more debugging is carried out */
#define ldbl_EG_SRK_DEBUG 100
#endif

/* ========================================================================= */
/** @brief Edge structure for shrinkable graphs */
typedef struct ldbl_EGsrkEdge_t
{
	EGeUgraphEdge_t edge;	/**< Actual edge structure for the graph */
	EGeList_t members;		/**< list of other edges shrunken within this edge */
	unsigned int mmb_sz;	/**< length of the members list (without including the 
														 edge itsself */
	long double weight;			/**< Weight for the edge */
}
ldbl_EGsrkEdge_t;

/* ========================================================================= */
/** @brief Node structure for shrinkable graphs */
typedef struct ldbl_EGsrkNode_t
{
	EGeUgraphNode_t node;	/**< actual node structure for the graph */
	EGeList_t members;		/**< list of other nodes shrunken with this node */
	unsigned int mmb_sz;	/**< length of the members list (without including the
														 node itself */
	EGes_t parent;				/**< If this node is the representant for its class, 
														 then this is a 'parent' node, otherwise, is a 
														 shrunken node */
	long double weight;			/**< Weight of the @f$\delta(n)@f$ edges for this node
														 (in the shrunken graph), this should be 
														 initialized by the user. */
	ldbl_EGsrkEdge_t *hit;			/**< used for internal purposes, in particular, while 
														 merging two adjacency lists, this field is used 
														 to store the first edge touching this node, and 
														 then used to retrieve that information. When we 
														 call #ldbl_EGsrkIdentifyNodes this field is assumed 
														 to be NULL */
}
ldbl_EGsrkNode_t;

/* ========================================================================= */
/** @brief Graph structure for shrinkable graphs */
typedef struct ldbl_EGsrkGraph_t
{
	EGeUgraph_t G;					/**< Actual graph structure. */
	unsigned n_onodes;			/**< Number of original nodes */
	unsigned n_oedges;			/**< Number of original edges */
}
ldbl_EGsrkGraph_t;

/* ========================================================================= */
/** @brief Initialize an edge structure.
 * @param e_edge */
#define ldbl_EGsrkEdgeInit(e_edge) ({\
	ldbl_EGsrkEdge_t*const _EGsrkE = (e_edge);\
	EGeUgraphEdgeInit(&(_EGsrkE->edge));\
	EGeListInit(&(_EGsrkE->members));\
	_EGsrkE->mmb_sz = 0;\
	ldbl_EGlpNumInitVar(_EGsrkE->weight);\
	ldbl_EGlpNumZero(_EGsrkE->weight);})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of an edge
 * structure.
 * @param e_edge */
#define ldbl_EGsrkEdgeClear(e_edge) ({\
	EGeUgraphEdgeClear(&((e_edge)->edge));\
	ldbl_EGlpNumClearVar((e_edge)->weight);})

/* ========================================================================= */
/** @brief Initialize a graph structure 
 * @param graph graph to be initialized */
#define ldbl_EGsrkGraphInit(graph) ({\
	ldbl_EGsrkGraph_t*const _EGsrkG = (graph);\
	EGeUgraphInit(&(_EGsrkG->G));\
	_EGsrkG->n_onodes = _EGsrkG->n_oedges = 0;})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a graph
 * structure.
 * @param graph */
#define ldbl_EGsrkGraphClear(graph) EGeUgraphClear(&((graph)->G))

/* ========================================================================= */
/** @brief Initialize a node structure.
 * @param e_node node to be initialized */
#define ldbl_EGsrkNodeInit(e_node) ({\
	ldbl_EGsrkNode_t*const _EGsrkN = (e_node);\
	EGeUgraphNodeInit(&(_EGsrkN->node));\
	EGeListInit(&(_EGsrkN->members));\
	_EGsrkN->mmb_sz = 0;\
	_EGsrkN->hit = 0;\
	EGesInit(&(_EGsrkN->parent));\
	ldbl_EGlpNumInitVar(_EGsrkN->weight);\
	ldbl_EGlpNumZero(_EGsrkN->weight);})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a node
 * structure.
 * @param e_node */
#define ldbl_EGsrkNodeClear(e_node) ({\
	EGeUgraphNodeClear(&((e_node)->node));\
	ldbl_EGlpNumClearVar((e_node)->weight);})

/* ========================================================================= */
/** @brief Add a #ldbl_EGsrkNode_t node to a #ldbl_EGsrkGraph_t graph.
 * @param graph graph were to add the node.
 * @param N node to add to the graph.
 * @return zero on success, non-zero otherwise.
 * */
#define ldbl_EGsrkAddNode(graph,N) EGeUgraphAddNode(&((graph)->G),&((N)->node))

/* ========================================================================= */
/** @brief Add a #ldbl_EGsrkEdge_t edge to a #ldbl_EGsrkGraph_t graph.
 * @param lG graph were to add the edge.
 * @param head_pt head node of the edge.
 * @param tail_pt tail node of the edge.
 * @param E edge to be added with end-points head_pt and tail_pt.
 * Note that this function will update the accumulated weight of both
 * endpoints of the newly added edge according to the value stored in the
 * #ldbl_EGsrkEdge_t::weight field.
 * */
#define ldbl_EGsrkAddEdge(lG,head_pt,tail_pt,E) ({\
	ldbl_EGsrkNode_t*const _EGsrkH = (head_pt);\
	ldbl_EGsrkNode_t*const _EGsrkT = (tail_pt);\
	ldbl_EGsrkEdge_t*const _EGsrkE = (E);\
	ldbl_EGlpNumAddTo(_EGsrkH->weight,_EGsrkE->weight);\
	ldbl_EGlpNumAddTo(_EGsrkT->weight,_EGsrkE->weight);\
	EGeUgraphAddEdge(&((lG)->G),&(_EGsrkH->node),&(_EGsrkT->node),&(_EGsrkE->edge));})

/* ========================================================================= */
/** @brief Given two nodes in the current shrunken graph, shrunk them into one 
 * node.
 * @param G pointer to the graph where we are working
 * @param base first node.
 * @param srkN second node.
 * @return pointer to the new representing node.
 * @note We assume that the field ldbl_EGsrkNode_t::hit is identically NULL for all
 * nodes currently in the shrunken graph (including base and srkN). 
 * @note We allways assume that N1 will be the representing node.
 * @note Take note that this structure can't get back the pointer to the srkN
 * node, the user should take care of that if needed.
 * */
ldbl_EGsrkNode_t *ldbl_EGsrkIdentifyNodes (ldbl_EGsrkGraph_t * const G,
																 ldbl_EGsrkNode_t * const base,
																 ldbl_EGsrkNode_t * const srkN);

/* ========================================================================= */
/** @} 
 * end of ldbl_eg_shrink_graph.h */
#endif
#endif
#endif
#ifdef HAVE_LONG_DOUBLE
#if HAVE_LONG_DOUBLE
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgPushRelabel EGalgPushRelabel
 *
 * Here we implement the push-relabel algorithm as defined in the book "Network 
 * Flows" by Magnanti et. all, in chapter 6,7 and 8. Using the variant
 * "Highest-label preflow-push algorithm" (described on page 230) wich choose
 * the active node from wich to push from as the one with highest distance
 * label. This variant has running time @f$ \mathcal{O}(n^2\sqrt{m}) @f$ where
 * @a n is the number of nodes in the graph, and @a m the number of edges in it.
 * Note that the call to #ldbl_EGalgPRminSTcut produces a maximum @b pre_flow, to 
 * obtain a flow you should call the #ldbl_EGalgPRmaxSTflow that takes the graph 
 * produced by #ldbl_EGalgPRminSTcut and convert the preflow into a real flow. We
 * also choose to use to register the number of nodes with distance labels
 * @f$k,\quad\forall k=1,\ldots,n@f$ where @a n is the number of nodes in the
 * network. This is done because whenever the number of nodes with distance
 * labels @a k is zero, then all nodes with distance labels above @a k can be
 * set to @a n (and thus be added to the partially computed cut-set). This is an
 * (inportant) empirical speed-up, but does not affect the worst case complexity
 * analysis.
 * @version 1.0.0
 * @par History:
 * - 2010-05-07
 * 						- Add implementation using eg_adgraph.h
 * - 2005-06-01
 * 						- Add globla relabeling heuristic.
 * - 2005-05-30
 * 						- Final test results on the TSP x-files, all should be right now.
 * - 2005-05-26
 * 						- First Implementation.
 * @note This algorithm is implemented the embedded structures approach. I will
 * give further details on what this implies.
 *
 * @note It is important to note that this algorithm (as implemented here) 
 * @b WILL @b FAIL if an edge has infinite capacities. To handle that case
 * either we must re-program it, or you can put capacities suficiently large on
 * them (for example 2 times the sum of all bounded capacities) for this
 * algorithm to work.
 *
 * @note This implementation does use global relabeling, namelly, the
 * strategy when once in a while (for example every @a n or @a m relabeling
 * operations) we recompute
 * the exact distance labels. The use of this heuristic (together with the gap
 * heuristic) have been reported to be the most successfull in practice (see "On
 * Implementing Push-Relabel Method For The Maximum FLow Problem" from Boris V.
 * Cherkassy and Andrew V. Goldberg.) and also in the test that we have
 * performed on the fractional solutions of TSP's instances from the TSPLIB set
 * of problems using CONCORDE.
 * */
/** @file 
 * @ingroup EGalgPushRelabel */
/** @addtogroup EGalgPushRelabel */
/** @{ */
/** @example ldbl_eg_push_relabel.ex.c
 * This is a complete example for the min-cut max-flow problem using the
 * push/relabel implementation offered in EGalgPR. */
#ifndef ldbl___EG_PUSH_RELABEL_H__
#define ldbl___EG_PUSH_RELABEL_H__
/* ========================================================================= */

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define ldbl___PR_DEBUGL__ 100

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define ldbl___PR_TEST_VERBOSE__ 100

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define ldbl___PR_VERBOSE__ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define ldbl___PR_PROFILE__ 100

/* ========================================================================= */
/** @brief If profiling is enable (i.e. #ldbl___PR_PROFILE__ <= DEBUG), print 
 * some profiling information of the min s-t cut used up to now, and reset 
 * all internal counters to zero, if profiling is not enabled, nothing 
 * happen. */
/** @{ */
void ldbl_EGalgPRprofile(void);
/** @} */
/* ========================================================================= */
/** @brief If set to non-zero, use the global relabeling heuristic (to be called
 * every @a n number of relabel operations performed. if set to zero, it won't
 * use this heuristic. Note thought that it has been shown that this is a very
 * efficient heuristic to reduce the total running time, specially in the
 * #ldbl_EGalgPRminSTcut function call. */
#define ldbl_EG_PR_RELABEL 1

/* ========================================================================= */
/** @brief If #ldbl_EG_PR_RELABEL is set to one, then this initeger controls how
 * often we perform the global relabeling heuristic (in multiples of number of
 * nodes), the default value is 1. */
#define ldbl_EG_PR_RELABEL_FREC 1U

/* ========================================================================= */
/** @brief Node structure neede to run Push-Relabel algorithm on a network.
 * @note Notice that the directed graph part is embeded in this structure as
 * well. Note  that we could define internally space for  LVL_list, 
 * but for the sake of speed we include them in the node structure. */
typedef struct ldbl_EGalgPRnode_t
{
	EGeDgraphNode_t v;		/**< Actual node structure to work with (EGeDgraph) */
	EGeList_t LVL_list;		/**< Used to store the BFS list used for the first 
														 computations of the exact label distances, and 
														 then to store this node in it's current level list 
														 (this is used to implement the Highest-Label 
														 variant of the Preflow-Push algorithm) */
	EGeList_t T_cut;			/**< Used to speed-up the 'hole' heuristic, it is seted
														 once we enter the algorithm, so their value is 
														 non-important outside the function (but it's 
														 contents will be lost once we enter 
														 #ldbl_EGalgPRminSTcut). */
	unsigned int d;				/**< Exact label distance for this node. Note that 
														 nodes with distance lables @f$ \geq n @f$ (where 
														 @a n is the number of nodes in the graph) define 
														 the minimum @f$ s-t@f$ cut that we are looking 
														 for. */
	long double e;					/**< Exess flow in the node. Note that in particular 
														 the excess on node @a t (once #ldbl_EGalgPRminSTcut 
														 finish) correspond to the minimum cut value. */
}
ldbl_EGalgPRnode_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an ldbl_EGalgPRnode_t structure */
#define ldbl_EGalgPRnodeInit(node_pt) ({\
	ldbl_EGalgPRnode_t*const __EGalgPR_in = (node_pt);\
	ldbl_EGlpNumInitVar(__EGalgPR_in->e);\
	EGeDgraphNodeInit(&(__EGalgPR_in->v));})

/* ========================================================================= */
/** @brief Reset the given node pointer (as if it were new).
 * @param node_pt pointer to the node to reset.
 * 
 * This function set the node as an empty node not linked with any graph.
 * */
#define ldbl_EGalgPRnodeReset(node_pt) EGeDgraphNodeReset(&((node_pt)->v))

/* ========================================================================= */
/** @brief clear a pointer to an ldbl_EGalgPRnode_t structure, and let it ready to be
 * freed if necesary. */
#define ldbl_EGalgPRnodeClear(node_pt) ({\
	ldbl_EGlpNumClearVar((node_pt)->e);\
	EGeDgraphNodeClear(&((node_pt)->v));})

/* ========================================================================= */
/** @brief capacitated edge structure with forward/backward information. */
typedef struct ldbl_EGalgPRse_t
{
	EGeDgraphEdge_t e;	/**< actual edge information. */
	long double r;				/**< residual capacity of the edge. */
	long double u;				/**< maximum capacity on the edge. */
	unsigned char type;	/**< type of edge (0 for forward and 1 for backward */
}
ldbl_EGalgPRse_t;

/* ========================================================================= */
/** @brief Edge Structure needed to run Push-Relabel algorithm on a network.
 * @note Notice that the this edge actually has actually two capacited edge
  substructures, one for forward edges and one for backward edge, it is assumed
 * that fw.type == 0 and bw.type == 1. This is needed because the algorithm 
 * asumes that both
 * edges exists (althought one may have zero capacity). Moreover, while
 * computing the residual capacities we need to access both edges e_ij and e_ji
 * at the same time, thus our choice to represent both edges in just one
 * structure. We also assume that the lower bound on the flow of all edges is
 * zero. Note that we don't need to keep explicitly the flow on the edges,
 * because given the residual capacity and the capacity on the edge we have that
 * @f$ x_{ij} - x_{ji} = u_{ij} - r_{ij} @f$ and thus we can set @f$ x_{ij} =
 * (u_{ij}-r_{ij})_+ @f$ and @f$ x_{ji} = (r_{ij}-u_{ij})_+ @f$.
 * if we have computed the maximal flow. */
typedef struct ldbl_EGalgPRedge_t
{
	ldbl_EGalgPRse_t fw;		/**< forward edge, we assum that fw.type = 0 */
	ldbl_EGalgPRse_t bw;		/**< backward edge, we assume that bw.type = 1 */
}
ldbl_EGalgPRedge_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an ldbl_EGalgPRedge_t structure */
#define ldbl_EGalgPRedgeInit(edge_pt) ({\
	ldbl_EGalgPRedge_t*const __EGalgPR_ie = (edge_pt);\
	ldbl_EGlpNumInitVar(__EGalgPR_ie->fw.r);\
	ldbl_EGlpNumInitVar(__EGalgPR_ie->fw.u);\
	ldbl_EGlpNumInitVar(__EGalgPR_ie->bw.r);\
	ldbl_EGlpNumInitVar(__EGalgPR_ie->bw.u);\
	EGeDgraphEdgeInit(&(__EGalgPR_ie->fw.e));\
	EGeDgraphEdgeInit(&(__EGalgPR_ie->bw.e));\
	__EGalgPR_ie->bw.type = 1;\
	__EGalgPR_ie->fw.type = 0;})

/* ========================================================================= */
/** @brief Reset the given edge pointer (as if it were new).
 * @param edge_pt pointer to the node to reset.
 * 
 * This function set the edge as an empty edge not linked with any graph.
 * */
#define ldbl_EGalgPRedgeReset(edge_pt) ({\
	ldbl_EGalgPRedge_t*const __EGalgPR_ie = (edge_pt);\
	EGeDgraphEdgeReset(&(__EGalgPR_ie->fw.e));\
	EGeDgraphEdgeReset(&(__EGalgPR_ie->bw.e));\
	__EGalgPR_ie->bw.type = 1;\
	__EGalgPR_ie->fw.type = 0;})


/* ========================================================================= */
/** @brief clear a pointer to an ldbl_EGalgPRedge_t structure, and let it ready to be
 * freed if necesary. */
#define ldbl_EGalgPRedgeClear(edge_pt) ({\
	ldbl_EGlpNumClearVar((edge_pt)->fw.r);\
	ldbl_EGlpNumClearVar((edge_pt)->fw.u);\
	ldbl_EGlpNumClearVar((edge_pt)->bw.r);\
	ldbl_EGlpNumClearVar((edge_pt)->bw.u);\
	EGeDgraphEdgeClear(&((edge_pt)->fw.e));\
	EGeDgraphEdgeClear(&((edge_pt)->bw.e));})

/* ========================================================================= */
/** @brief Graph structure needed to run Push-Relabel algorithm (with highest
 * label node selection rule). */
typedef struct ldbl_EGalgPRgraph_t
{
	EGeDgraph_t G;				/**< EGeDgraph structure holding the graph 
														 information. */
}
ldbl_EGalgPRgraph_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an ldbl_EGalgPRgraph_t structure */
#define ldbl_EGalgPRgraphInit(graph_pt) EGeDgraphInit(&((graph_pt)->G))

/* ========================================================================= */
/** @brief Reset the given graph pointer (as if it were new).
 * @param graph_pt pointer to the node to reset.
 * 
 * This function set the graph as an empty graph.
 * */
#define ldbl_EGalgPRgraphReset(graph_pt) EGeDgraphReset(&((graph_pt)->G))

/* ========================================================================= */
/** @brief clear a pointer to an ldbl_EGalgPRgraph_t structure, and let it ready 
 * to be freed if necesary. */
#define ldbl_EGalgPRgraphClear(graph_pt) EGeDgraphClear(&((graph_pt)->G))

/* ========================================================================= */
/** @brief Compute a minimum @f$s-t@f$ cut.
 * @param s pointer to the ldbl_source node.
 * @param t pointer to the ldbl_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the ldbl_EGalgPRgraph_t* in wich we will work.
 * @return zero on success, non-zero otherwise.
 * @par Description:
 * When this funcion finish (successfully) all nodes with field
 * #ldbl_EGalgPRnode_t::d bigger than or equal to @a n (the number of nodes in the
 * graph) bellong to the @a s cut, while nodes with value strictly less than @a
 * n will bellong to the @a t cut. The residual capacities imply a maximum
 * pre-flow in the network, to get an acutal maximum flow you should run 
 * #ldbl_EGalgPRmaxSTflow function with imput the output graph of this function 
 * (for an example look at the file ldbl_eg_push_relabel.ex.c ).
 * @note This implementation uses the @a gap and @a global @a relabeling
 * heuristics to speed-up the computations.
 * */
int ldbl_EGalgPRminSTcut (ldbl_EGalgPRgraph_t * const G,
										 ldbl_EGalgPRnode_t * const s,
										 ldbl_EGalgPRnode_t * const t);

/* ========================================================================= */
/** @brief Compute a maximum @f$s-t@f$ flow from the ouput produced by
 * EGalgPRminCur.
 * @param s pointer to the ldbl_EGalgPRnode_t* ldbl_source node in the network.
 * @param t pointer to the ldbl_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the ldbl_EGalgPRgraph_t* in wich we will work.
 * @return zero on success, non-zero otherwise.
 * @par Description:
 * We assume that our input graph is the (unaltered) result of a 
 * call to #ldbl_EGalgPRminSTcut. Also, note that while computing the actual 
 * max @a s-@a t flow, we don't need to look for @a gap in the array of 
 * distances.
 * Also note that once you call this function, the information in
 * #ldbl_EGalgPRnode_t::d don't correspond any more to the cut as defined in
 * #ldbl_EGalgPRminSTcut.
 * */
int ldbl_EGalgPRmaxSTflow (ldbl_EGalgPRgraph_t * const G,
											ldbl_EGalgPRnode_t * const s,
											ldbl_EGalgPRnode_t * const t);

/* ========================================================================= */
/** @brief Check if the given input graph (with it's residual capacities)
 * represent an optimal solution to the maximum @f$ s-t @f$ flow / minimum
 * capacity @f$ s-t @f$ cut.
 * @param s pointer to the ldbl_EGalgPRnode_t* ldbl_source node in the network.
 * @param t pointer to the ldbl_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the ldbl_EGalgPRgraph_t* in wich we will work.
 * @param error worst error while checking for optimality conditions.
 * @return zero if all discrepancies are under the #ldbl_epsLpNum threshold, 
 * otherwise, return the number of conditions that don't hold within that
 * threshold, and report in error the worst error found in any condition.
 * @note The input for this function should be the graph as returned by
 * #ldbl_EGalgPRmaxSTflow .
 * */
int ldbl_EGalgPRoptimalityTest (ldbl_EGalgPRgraph_t * const G,
													 ldbl_EGalgPRnode_t * const s,
													 ldbl_EGalgPRnode_t * const t,
													 long double * error);

/* ========================================================================= */
/* @} */
/* end of ldbl_eg_push_relabel.h */
#endif
#endif
#endif
#ifdef HAVE_LONG_DOUBLE
#if HAVE_LONG_DOUBLE
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgMinCut EGalgMinCut
 *
 * Here we implement the min-cut algorithm based on the srinking
 * pre-processing of Padberg And Rinaldi in the paper "An Efficient 
 * Algorithm For The Minimum Capacity Cut Problem", Mathematical Programming
 * 47 (1990) pages 19-36. But using as minimum s-t cut code the Push-Relabel
 * max flow algorithm as implemented in the @ref EGalgPushRelabel module. This 
 * implies that we only support positive edge-weights.
 *
 * This implementation allows uses of diferent numbers as supported by
 * @ref EGlpNum module. And follows the philosophy of embeded structures as in
 * @ref EGalgPushRelabel module. Also, much of the approach used in this 
 * implementation come from CONCORDE's implementation.
 *
 * It is usually the case that the Minimum Cut Problem is just a sub-problem
 * of some larger problem, is for that reason that we implement (just as in
 * CONCORDE) a callback function that is called whenever an improving solution
 * is found, so that the user can do something with the given node-cutset and
 * value. for more details see the definition of #ldbl_EGalgMCcbk_t .
 *
 * @note 
 * If run with types like EGfp20_t, if the arithmetic produces an overflow,
 * then we are in big trouble, note that the numbers involved in the algorithm
 * may range up to \f$\sum(w_e:e\in E(G))\f$.
 *
 * @version 0.0.1
 * @par History:
 * - 2005-08-19
 * 						- While computing a minimum S-T cut, choose S randomly. and T
 * 							as a node at maximum distance (number of edges) from S.
 * 						- Fix small problem with shrinking level 4
 * - 2005-06-20
 * 						- First Implementation.
 * */
/** @file
 * @ingroup EGalgMinCut */
/** @addtogroup EGalgMinCut */
/** @{ */
/** @example ldbl_eg_min_cut.ex.c */
/* ========================================================================= */
#ifndef ldbl__EG_MIN_CUT_H
#define ldbl__EG_MIN_CUT_H
/* ========================================================================= */
/** @brief Verbosity Level */
#define ldbl___MC_VRBLVL_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define ldbl___MC_DEBUG_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define ldbl___MC_PROFILE_ 0

/* ========================================================================= */
/** If profiling is enable (i.e. #ldbl___MC_PROFILE_ <= DEBUG), print 
 * some profiling information of the min cut used up to now, and reset 
 * all internal counters to zero, if profiling is not enabled, nothing 
 * happen. */
/** @{ */
void ldbl_EGalgMCprofile(void);
/** @} */

/* ========================================================================= */
/** @brief Call-back function, it receives as input the weight of the cut, the
 * size of the newly found cut, an array containing the cut (of length at
 * least the number of elements in the cut) as integers (as defined by the 
 * #ldbl_EGalgMCnode_t::id field), and a pointer to some internal
 * data (as stored in #ldbl_EGalgMCcbk_t::param). The function should return zero
 * on success, and non-zero if an error ocours, this error will be propagated
 * through the calling functions. */
typedef int (*ldbl_EGalgMCdo_f) (long double,
														const unsigned int,
														const unsigned int *const,
														void *);

/* ========================================================================= */
/** @brief Call-back structure for use when an improving minimum cut is found.
 * */
typedef struct ldbl_EGalgMCcbk_t
{
	long double cutoff;	/**< maximum value for the newly found minimum cut, for 
												 the function to be called. */
	void *param;			/**< external parameter needed by the function */
	ldbl_EGalgMCdo_f do_fn;/**< actual function to be called if the cut-off condition 
												 holds */
}
ldbl_EGalgMCcbk_t;

/* ========================================================================= */
/** @brief Initialize a call-back structure.
 * @param cb call-back to be initialized. */
#define ldbl_EGalgMCcbkInit(cb) ({\
	ldbl_EGalgMCcbk_t*const _EGalgMCcb = (cb);\
	ldbl_EGlpNumInitVar(_EGalgMCcb->cutoff);\
	_EGalgMCcb->param = 0;\
	_EGalgMCcb->do_fn = 0;})

/* ========================================================================= */
/** @brief Free all internal memory asociated with this structure (not
 * allocated by the user).
 * @param cb call-back strucure to be cleared */
#define ldbl_EGalgMCcbkClear(cb) ldbl_EGlpNumClearVar((cb)->cutoff)

/* ========================================================================= */
/** @brief Node structure for Minimum Cut */
typedef struct ldbl_EGalgMCnode_t
{
	ldbl_EGsrkNode_t node;		/**< Actual shrinkable node */
	unsigned int id;		/**< External Identifier for the node */
	EGeList_t lvl_cn;		/**< Connector for the level list */
	unsigned int ldbl_lvl;		/**< Current node level test to be performed */
	unsigned int new_id;/**< internal data, it's values can be discarded */
	ldbl_EGsrkEdge_t *hit;		/**< Used to speed-up the Padberg-Rinaldi tests. */
}
ldbl_EGalgMCnode_t;

/* ========================================================================= */
/** @brief Initialize a node structure for use.
 * @param N node to be initialized */
#define ldbl_EGalgMCnodeInit(N) ({\
	ldbl_EGalgMCnode_t*const _EGalgMCn = (N);\
	ldbl_EGsrkNodeInit(&(_EGalgMCn->node));\
	_EGalgMCn->lvl_cn = (EGeList_t){0,0};\
	_EGalgMCn->ldbl_lvl = 0;\
	_EGalgMCn->id = UINT_MAX;\
	_EGalgMCn->new_id = UINT_MAX;\
	_EGalgMCn->hit = 0;})

/* ========================================================================= */
/** @brief Clear any internal memory (not allocated by the user) used by this
 * structure.
 * @param N node to be cleared */
#define ldbl_EGalgMCnodeClear(N) ldbl_EGsrkNodeClear(&((N)->node))

/* ========================================================================= */
/** @brief Edge structure for the Minimum Cut */
typedef struct ldbl_EGalgMCedge_t
{
	ldbl_EGsrkEdge_t edge;	/**< Actual shrinkable edge */
	unsigned int id;	/**< External Identifier for the edge */
}
ldbl_EGalgMCedge_t;

/* ========================================================================= */
/** @brief Initialize an edge structure for use.
 * @param E edge to be initialized */
#define ldbl_EGalgMCedgeInit(E) ({\
	ldbl_EGalgMCedge_t*const _EGalgMCe = (E);\
	ldbl_EGsrkEdgeInit(&(_EGalgMCe->edge));\
	_EGalgMCe->id = UINT_MAX;})

/* ========================================================================= */
/** @brief Clear any internal memory (not allocated by the user) used by this
 * structure.
 * @param E node to be cleared */
#define ldbl_EGalgMCedgeClear(E) ldbl_EGsrkEdgeClear(&((E)->edge))

/* ========================================================================= */
/** @brief Graph Structure for Minimum Cut.
 *
 * Note that this structure also holds some parameters as the epsilon to use
  in the comparisons, the current best cut found (or bound), and the current
 * cut found so-far. As well as an array containing all edges and nodes in
 * thee graph (remember that when we Identify two nodes, we loose any
 * reference to the shrinked node in the graph structure as discussed in
 * #ldbl_EGsrkIdentifyNodes ) 
 * */
typedef struct ldbl_EGalgMCgraph_t
{
	ldbl_EGsrkGraph_t G;						/**< Actual shrinking graph used */
	long double epsilon;				/**< error tolerance used for equality testing */
	long double cut_val;				/**< if #ldbl_EGalgMCgraph_t::cut_sz is not zero, then 
																 this is the value of the (currenlty) best 
																 minimum cut found so far. otherwise is a bound 
																 on the value of the minimum cut (note that this
																 value should be set before actually computing 
																 the minimum cut, and can be set to the value 
																 of @f$\delta(v)@f$ for some node @a v in the 
																 graph. */
	unsigned int cut_sz;			/**< number of nodes in the current best cut, if 
																 set to zero, then no cut has been found 
																 (so far) */
	EGeList_t lvl_list[5];		/**< List of nodes in different levels of tests */
	unsigned int *cut;				/**< Array  storing the current cut, the size of 
																 this array should be at least 
																 #ldbl_EGsrkGraph_t::n_onodes */
	ldbl_EGalgMCnode_t *all_nodes;	/**< Array containing all nodes of the graph. */
	ldbl_EGalgMCedge_t *all_edges;	/**< Array containing all edges of the graph. */
}
ldbl_EGalgMCgraph_t;

/* ========================================================================= */
/** @brief Initialize a graph structure for use.
 * @param Graph graph to be initialized */
#define ldbl_EGalgMCgraphInit(Graph) ({\
	ldbl_EGalgMCgraph_t*const _EGalgMCg = (Graph);\
	ldbl_EGsrkGraphInit(&(_EGalgMCg->G));\
	ldbl_EGlpNumInitVar(_EGalgMCg->epsilon);\
	ldbl_EGlpNumZero(_EGalgMCg->epsilon);\
	ldbl_EGlpNumInitVar(_EGalgMCg->cut_val);\
	ldbl_EGlpNumZero(_EGalgMCg->cut_val);\
	_EGalgMCg->cut_sz = 0;\
	EGeListInit(_EGalgMCg->lvl_list);\
	EGeListInit(_EGalgMCg->lvl_list+1);\
	EGeListInit(_EGalgMCg->lvl_list+2);\
	EGeListInit(_EGalgMCg->lvl_list+3);\
	EGeListInit(_EGalgMCg->lvl_list+4);\
	_EGalgMCg->cut = 0;\
	_EGalgMCg->all_nodes = 0;\
	_EGalgMCg->all_edges = 0;})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a graph
 * structure.
 * @param Graph graph to be cleared. */
#define ldbl_EGalgMCgraphClear(Graph) ({\
	ldbl_EGsrkGraphClear(&((Graph)->G));\
	ldbl_EGlpNumClearVar((Graph)->epsilon);\
	ldbl_EGlpNumClearVar((Graph)->cut_val);})

/* ========================================================================= */
/** @brief Shrink two nodes in the graph, and update internal structures.
 * @param Graph current graph.
 * @param N node to keep in graph.
 * @param M node to shrink within N. */
#define ldbl_EGalgMCidentifyNodes(Graph,N,M) ({\
	ldbl_EGalgMCgraph_t*const _EGalgMCg = (Graph);\
	ldbl_EGalgMCnode_t*const _EGalgMCn = (N), *const _EGalgMCm = (M);\
	MESSAGE(ldbl___MC_DEBUG_,"Shrinking nodes with weight %lf %lf", \
					ldbl_EGlpNumToLf(_EGalgMCn->node.weight), \
					ldbl_EGlpNumToLf(_EGalgMCm->node.weight));\
	ldbl_EGsrkIdentifyNodes(&(_EGalgMCg->G), &(_EGalgMCn->node), &(_EGalgMCm->node));\
	if(_EGalgMCn->ldbl_lvl < 5)\
	{\
		EGeListDel(&(_EGalgMCm->lvl_cn));\
		EGeListMoveAfter(&(_EGalgMCn->lvl_cn), _EGalgMCg->lvl_list);\
	}\
	else EGeListAddAfter(&(_EGalgMCn->lvl_cn), _EGalgMCg->lvl_list);\
	_EGalgMCn->ldbl_lvl = 0;})

/* ========================================================================= */
/** @brief Identify all Padberg and Rinaldy edges. i.e. shrink all edges that
 * satisfy the conditions in their paper. we choose to make tests over pair of
 * nodes linked by an edge. 
 * @param max_lvl set a limit on wich tests to perform. for example, if set to
 * 1, only the first and second tests will be carried out.
 * @param G graph over wich we are working. 
 * @param cb call back structure to use (if set to NULL it is not used).
 * @return zero on success, non-zero otherwise. 
 *
 * Note that while doing this identification process, we update the values of
 * #ldbl_EGalgMCgraph_t::cut, #ldbl_EGalgMCgraph_t::cut_sz and #ldbl_EGalgMCgraph_t::cut_val,
 * as well as performing the actual shrinking procedure.
 *
 * The original theorem (for local conditions on shrinking) is the following:
 * Let @f$ Z @f$ be a proper subset of @f$ V @f$ (the set of all nodes in the
 * graph), @f$ |Z|\geq2 @f$, and let 
 * @f[ P(Z) = \bigcup\left\{ N(u)\cap N(v):u\neq v, u,v\in Z \right\} @f]
 * where @f$ N(u) @f$ if the set of neighbours of @f$ u @f$. If there exists
 * @f$ Y\subseteq P(Z) @f$ such that for every nonempty proper subset @f$ W
 * @f$ of @f$ Z @f$ and for every @f$ T\subseteq Y @f$ either:
 * -# @f$ w(\delta(W))/2 \leq w(W:(Y-T)+(Z-W)) @f$ or
 * -# @f$ w(\delta(Z-W))/2 \leq w(Z-W:T+W) @f$.
 * Then there exists a minimum cut @f$(X:V-X)@f$ such that either @f$
 * Z\subseteq X @f$ or @f$ X\subseteq Z @f$.
 *
 * And the original theorem (in fact is the corollary 3.5 in the paper) 
 * regarding global conditions for shrinking is the following:
 * Let @f$ u\neq v\in V @f$, and let @f$ q @f$ be an upper bound on the
 * minimum cut value, and @f$ lb_{uv} @f$ be a lower bound in the value of a
 * minimum @f$ u-v @f$ cut, then if @f$ lb_{uv}\geq q @f$ the set 
 * @f$ \{u,v\} @f$ is shrinkable.
 * 
 * The actual tests that we perform (for every edge) are the following:
 * -# If @f$ w(\delta(u)) < @f$ #ldbl_EGalgMCgraph_t::cut_val, update the minimum
 * cut value and set.
 * -# If @f$ w_{uv} \geq \min\{w(\delta(u)),w(\delta(v))\}/2 @f$ then we can 
 * safely shrink edge @f$ uv @f$.
 * -# If we have a triangle @f$ uv,\quad vw,\quad wu  @f$, with 
 * @f$ w_{uv} + w_{vw} \geq w(\delta(v))/2 @f$ and  
 * @f$ w_{uw} + w_{vw} \geq w(\delta(w))/2 @f$ then we can safely shrink edge
 * @f$ wv @f$.
 * -# Compute lower bound on the cut that separates the endpoints of the
 * current edge as :
 * @f[ lb_{uv}=w_{uv}+\sum\limits_{w\in N(u)\cap N(v)}\min\{w_{uw},w_{vw}\} @f]
 * If  @f$ lb_{uv} \geq  @f$ #ldbl_EGalgMCgraph_t::cut_val , then we can shrink the edge  @f$ uv @f$.
 * -# Consider the edge @f$ uv @f$ and two common neighbours @f$ x,y @f$. If  
 * @f$ w_{ux} + w_{uy} + w_{uv} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{vx} + w_{vy} + w_{vu} \geq w(\delta(v))/2 @f$ and at least one of 
 * @f$ w_{uv} + w_{uy} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{uv} + w_{vx} \geq w(\delta(v))/2 @f$ and at least one of 
 * @f$ w_{uv} + w_{ux} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{uv} + w_{vy} \geq w(\delta(v))/2 @f$ then we can safely shrink edge
 * @f$ uv @f$.
 *
 * We make thiese tests in order, i.e. first we perform all level 1 tests,
 * then level2, and so on, and whenever two nodes are Identify (shrinked) we
 * set the level of the node to 1 (i.e. in the next test we will test the
 * first condition). This is done using an array of (5) lists, where all nodes
 * are distributed. Originally all nodes should be in the first lists (i.e.
 * all nodes should be tested to improve the current best cut by themselves).
 * */
int ldbl_EGalgMCidentifyPRedges (ldbl_EGalgMCgraph_t * const G,
														ldbl_EGalgMCcbk_t * const cb,
														const unsigned int max_lvl);

/* ========================================================================= */
/** @brief Compute a minimum cut on the given graph. 
 * @param max_lvl set a limit on wich tests to perform during the
 * Padberg-Rinaldy shrinking step. for example, if set to
 * 1, only the first and second tests will be carried out.
 * @param G graph over wich we are working. 
 * @param cb call back structure to use (if set to NULL it is not used).
 * @return zero on success, non-zero otherwise. 
 *
 * This function takes as input a graph, and perform the minimum cut algorithm
 * as described in the paper "An Efficient 
 * Algorithm For The Minimum Capacity Cut Problem", Mathematical Programming
 * 47 (1990) pages 19-36. 
 *
 * Note that the graph should have all fields properly initialized.
 * */
int ldbl_EGalgMC (ldbl_EGalgMCgraph_t * const G,
						 ldbl_EGalgMCcbk_t * const cb,
						 const unsigned int max_lvl);

/* ========================================================================= */
/** @} 
 * end ldbl_eg_min_cut.h */
#endif
#endif
#endif
#ifdef HAVE_LONG_DOUBLE
#if HAVE_LONG_DOUBLE
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef ldbl___EG_NUMUTIL_H__
#define ldbl___EG_NUMUTIL_H__

/* ========================================================================= */
/** @defgroup EGlpNumUtil General Number Utilities
 * Here we put some utilities common for different number types but thaat we
 * want to implement as templates, like permutation sorting, inner product of
 * vectors, and so-on..
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2007-10-08
 *  					- Separate template file and independet file into eg_nummacros.h
 *  					- Move EGabs, EGswap, EGmin and EGmax to this file
 *  - 2005-10-31
 *  					- First implementation.
 * */
/** @{*/
/** @file
 * @brief This file provide the user interface and function definitions for
 * general number utilities.
 * */
/* ========================================================================= */
/** @brief compute the inner product of two arrays.
 * @param arr1 first array.
 * @param arr2 second array.
 * @param length number of entries to consider in both arrays, from zero to
 * length - 1.
 * @param rop where to store the result.
 * */
#define ldbl_EGlpNumInnProd(__rop,__arr1,__arr2,__length) ldbl___EGlpNumInnProd((&(__rop)),__arr1,__arr2,__length)
/* ========================================================================= */
/** @brief internal version, this is done to avoid using stdc99 and rely on
 * more basic stdc89 */
void ldbl___EGlpNumInnProd(long double*rop,long double*const arr1,long double*const arr2, const size_t length);
/* ========================================================================= */
/** @brief Sort (in increasing order) a sub-set of entries in an array using 
 * quicksort, by permutating the order of the elements in the subset rather 
 * than in the whole original array.
 * @param sz length of the permutation array.
 * @param perm array of indices of elements that we want to sort.
 * @param elem array (of length at least max(perm[k]:k=0,...,sz-1)) containing
 * the elements to be sorted.
 * @note The array of elements is not changed by this function.
 * @note This code is based in concorde's implementation of
 * permutation-quick-sort.
 * */
void ldbl_EGutilPermSort (const size_t sz,
										 int *const perm,
										 const long double * const elem);

/* ========================================================================= */
/** @brief Sort (in decreasing order) a sub-set of entries in an array using 
 * quicksort, by permutating the order of the elements in the subset rather 
 * than in the whole original array.
 * @param sz length of the permutation array.
 * @param perm array of indices of elements that we want to sort.
 * @param elem array (of length at least max(perm[k]:k=0,...,sz-1)) containing
 * the elements to be sorted.
 * @note The array of elements is not changed by this function.
 * @note This code is based in concorde's implementation of
 * permutation-quick-sort.
 * */
void ldbl_EGutilPermSort2 (const size_t sz,
										 int*const perm,
										 const long double*const elem);

/* ========================================================================= */
/** @}*/
#endif
#endif
#endif
#ifdef HAVE_LONG_DOUBLE
#if HAVE_LONG_DOUBLE
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgDijkstra EGalgDijkstra
 * Dijkstra implementation with 2-heaps
 * */
/** @file
 * @ingroup EGalgDijkstra */
/** @addtogroup EGalgDijkstra */
/** @{ */
/** @example ldbl_eg_dijkstra.ex.c */
/* ========================================================================= */
#ifndef ldbl___EG_DIJKSTRA_H
#define ldbl___EG_DIJKSTRA_H
/* ========================================================================= */
/** @brief Verbosity Level */
#define ldbl_DJK_VRBLVL_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define ldbl_DJK_DEBUG_ 100

/* ========================================================================= */
/** @brief implement dijkstra.
 * */
int ldbl_EGalgDJK (
		int32_t const nnodes,
		int32_t const nedges,
		int32_t const*const ou_d,
		int32_t const*const ou_beg,
		int32_t const*const ou_e,
		long double const*const weight,
		int32_t const s,
		int32_t const nt,
		int32_t const*const t,
		int32_t*const father,
		long double*const dist
		);

/* ========================================================================= */
/** @brief read from a file in .x format (as in the concorde's .x files), the
 * format is as follows:
 * nnodes nedges
 * tail_1 head_1 weight_1
 * ...    ...    ....
 * tail_nnodes head_nnodes weight_nnodes
 * comments are allowed, if they start with % or #.
 * @param input file containing the data
 * @param n where to store the number of nodes
 * @param m where to store the number of edges
 * @param edges pointer to an array where to store the edges, note that memory
 * will be allocated in (*edges)
 * @param weight pointer to the array where we will store the weights, note
 * that this array will be allocated using ldbl_EGlpNumAllocArray, and should be
 * deallocated using ldbl_EGlpNumFreeArray.
 * @return zero on success, non-zero otherwise 
 * */
int ldbl_EGguReadXgraph(
		EGioFile_t*const input,
		int32_t*const n,
		int32_t*const m,
		int32_t**const edges,
		long double**const weight);
/* ========================================================================= */
/** @} 
 * end ldbl_eg_dijkstra.h */
#endif

#endif
#endif
#ifdef HAVE_LIBGMP
#if HAVE_LIBGMP
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef mpq___EG_DMATRIX_H__
#define mpq___EG_DMATRIX_H__

/* ========================================================================= */
/** @defgroup EGdMatrix Dense Matrices
 * Here we define a common interface for dense matrices (i.e. a structure), and
 * some common operations over dense matrices. The definition uses EGlpNum as
 * reference number type, this allow for template initializations.
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2005-10-27
 *  					- First implementation.
 * */
/** @{*/
/** @file
 * @brief This file provide the user interface and function definitions for
 * Dense Matrices.
 * */
/** @example mpq_eg_dmatrix.ex.c */
/* ========================================================================= */
/** @brief structure to hold a dense matrix, we choose a row representation
 * of the matrix, and we allow row and column permutations. All actual values 
 * in the matrix are stored in #mpq_EGdMatrix_t::matval, and the rows in
 * #mpq_EGdMatrix_t::matrow. */
typedef struct mpq_EGdMatrix_t
{
	size_t col_sz;		/**< @brief Number of columns in the matrix. */
	size_t row_sz;		/**< @brief Number of rows in the matrix */
	mpq_t **matrow;
										/**< @brief Array of size #mpq_EGdMatrix_t::row_sz containing 
												 all rows of the matrix */
	mpq_t *matval;/**< @brief Values for all entries */
	int *col_ord;			/**< @brief Array of size at least #mpq_EGdMatrix_t::col_sz 
												 containing the order ammong all columns i.e. it is a 
												 permutation of {0,....,col_sz-1} which is how the 
												 matrix is treated internally */
	int *row_ord;			/**< @brief Array of size at least #mpq_EGdMatrix_t::row_sz 
												 containing the order ammong all rows, i.e. it is a 
												 permutation of {0,...,row_sz-1} which is how the 
												 matrix is treated internally */
}
mpq_EGdMatrix_t;

/* ========================================================================= */
/** @brief Initialize (as a dense matrix of dimension 0x0) an #mpq_EGdMatrix_t
 * structure.
 * @param __dmatrix dense matrix structure pointer.
 * */
#define mpq_EGdMatrixInit(__dmatrix) memset(__dmatrix,0,sizeof(mpq_EGdMatrix_t))

/* ========================================================================= */
/** @brief Clear a dense matrix structure, i.e. free all internally allocated
 * data of the structure. Note that no further use of the structure can be made
 * unless it is re-initialized and set to a suitable size.
 * @param __dmatrix dense matrix structure pointer.
 * */
#define mpq_EGdMatrixClear(__dmatrix) do{\
	mpq_EGdMatrix_t*const __EGdm = (__dmatrix);\
	mpq_EGlpNumFreeArray(__EGdm->matval);\
	EGfree(__EGdm->matrow);\
	int_EGlpNumFreeArray(__EGdm->col_ord);\
	int_EGlpNumFreeArray(__EGdm->row_ord);} while(0)

/* ========================================================================= */
/** @brief Set new dimensions for a dense matrix structure.
 * @param __dmatrix dense matrix structure pointer.
 * @param __nnewrows number of rows in the matrix.
 * @param __nnewcols number of columns in the matrix.
 * @note Take care that the values stored in the matrix are not initialized to
 * any particular number. Also the ordering (for both column and row) is reset
 * to the standard ordering 0,....,n.
 * */
#define mpq_EGdMatrixSetDimension(__dmatrix,__nnewrows,__nnewcols) do{\
	mpq_EGdMatrix_t*const __EGdm = (__dmatrix);\
	register int __EGdmi;\
	__EGdm->col_sz = (__nnewcols);\
	__EGdm->row_sz = (__nnewrows);\
	mpq_EGlpNumReallocArray(&(__EGdm->matval),__EGdm->col_sz * __EGdm->row_sz);\
	EGrealloc(__EGdm->matrow,__EGdm->row_sz * sizeof(mpq_t*));\
	int_EGlpNumReallocArray(&(__EGdm->col_ord),__EGdm->col_sz);\
	int_EGlpNumReallocArray(&(__EGdm->row_ord),__EGdm->row_sz);\
	__EGdmi = (int)(__EGdm->col_sz);\
	while(__EGdmi--) __EGdm->col_ord[__EGdmi] = __EGdmi;\
	__EGdmi = (int)(__EGdm->row_sz);\
	while(__EGdmi--) \
		__EGdm->matrow[__EGdmi] = __EGdm->matval + ((size_t)(__EGdmi) * __EGdm->col_sz);\
	__EGdmi = (int)(__EGdm->row_sz);\
	while(__EGdmi--) __EGdm->row_ord[__EGdmi] = __EGdmi;} while(0)

/* ========================================================================= */
/** @brief Display a given #mpq_EGdMatrix_t structure contents.
 * @param __dmatrix dense matrix structure pointer.
 * @param __nat_order if set to one, display the matrix using the natural 
 * internal order, i.e. we discard the order of columns and rows as defined in
 * #mpq_EGdMatrix_t::col_ord and #mpq_EGdMatrix_t::row_ord. Otherwise, use such orders.
 * @param __ofile pointer to a FILE structure where we want the output to be
 * printed.
 * */
#define mpq_EGdMatrixDisplay(__dmatrix,__nat_order,__ofile) do{\
	mpq_EGdMatrix_t*const __EGdm = (__dmatrix);\
	char* __EGdmstr = 0;\
	size_t __EGdmi, __EGdmj;\
	fprintf(__ofile,"Matrix %p\nDimensions: %zd rows, %zd columns\n", (void*)__EGdm, __EGdm->row_sz, __EGdm->col_sz);\
	if(__nat_order){\
		for(__EGdmi = 0 ; __EGdmi < __EGdm->row_sz ; __EGdmi++){\
			for(__EGdmj = 0 ; __EGdmj < __EGdm->col_sz ; __EGdmj++){\
				__EGdmstr = mpq_EGlpNumGetStr(__EGdm->matrow[__EGdmi][__EGdmj]);\
				fprintf(__ofile,"%10s ", __EGdmstr);\
				EGfree(__EGdmstr);\
			}\
			fprintf(__ofile,"\n");}\
	} else {\
		for(__EGdmi = 0 ; __EGdmi < __EGdm->row_sz ; __EGdmi++){\
			for(__EGdmj = 0 ; __EGdmj < __EGdm->col_sz ; __EGdmj++){\
				__EGdmstr = mpq_EGlpNumGetStr(__EGdm->matrow[__EGdm->row_ord[__EGdmi]][__EGdm->col_ord[__EGdmj]]);\
				fprintf(__ofile,"%10s ", __EGdmstr);\
				EGfree(__EGdmstr);\
			}\
			fprintf(__ofile,"\n");}\
	}} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set rows 
 * '__dest' to '__dest' + '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in row '__dest', and note that rows '__orig' and '__dest' should be different.
 * This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the row whose multiple will be added to the '__dest'
 * row.
 * @param '__dest' row to be replaced by '__dest' + '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' row.
 * @note The index of the row are taken as internal index, i.e. if we give row
 * 'k' we will use the row stored in #mpq_EGdMatrix_t::matrow[k], wich does not
 * mean that we will access the k-th row in the matrix (wich would need to use
 * as index the value #mpq_EGdMatrix_t::row_ord[k] instead). Note that we don't
 * test wether the given multiple is zero or not. we always perform the
 * operation.
 * */
#define mpq_EGdMatrixAddRowMultiple(__dmatrix,__dest,__orig,__num) do{\
	mpq_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (size_t)(__dest);\
	const size_t __EGori = (size_t)(__orig);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) \
		mpq_EGlpNumAddInnProdTo(__EGdm->matrow[__EGdest][__EGdmj],\
												__EGdm->matrow[__EGori][__EGdmj],__num);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set rows 
 * '__dest' to '__dest' - '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in row '__dest', and note that rows '__orig' and '__dest' should be different.
 * This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the row whose multiple will be added to the '__dest'
 * row.
 * @param '__dest' row to be replaced by '__dest' - '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' row.
 * @note The index of the row are taken as internal index, i.e. if we give row
 * 'k' we will use the row stored in #mpq_EGdMatrix_t::matrow[k], wich does not
 * mean that we will access the k-th row in the matrix (wich would need to use
 * as index the value #mpq_EGdMatrix_t::row_ord[k] instead). Note that we don't
 * test wether the given multiple is zero or not. we always perform the
 * operation.
 * */
#define mpq_EGdMatrixSubRowMultiple(__dmatrix,__dest,__orig,__num) do{\
	mpq_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (__dest);\
	const size_t __EGori = (__orig);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) \
		mpq_EGlpNumSubInnProdTo(__EGdm->matrow[__EGdest][__EGdmj],\
												__EGdm->matrow[__EGori][__EGdmj],__num);\
	} while(0)
/* ========================================================================= */
/** @brief Given a number and a row, multiply the complete row by the given
 * number. Note that the number MUST_NOT be stored in the row being multiplied,
 * this is because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param row_ind index of the row being multiplied, note that we will multiply
 * the row stored in #mpq_EGdMatrix_t::matrow[row_ind], wich is different to say
 * that we multiply the row in the row_ind-th position in the row ordering (to
 * do that, then row_ind should be #mpq_EGdMatrix_t::row_ord[k]).
 * @param multiple constant to be multiply to the row.
 * */
#define mpq_EGdMatrixMultiplyRow(__dmatrix,row_ind,multiple) do{\
	mpq_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdmi = (row_ind);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) mpq_EGlpNumMultTo(__EGdm->matrow[__EGdmi][__EGdmj],multiple);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set columns 
 * '__dest' to '__dest' + '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in column '__dest', and note that columns '__orig' and '__dest' should be 
 * different. This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the column whose multiple will be added to the '__dest'
 * column.
 * @param '__dest' column to be replaced by '__dest' + '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' column.
 * @note The index of the column are taken as internal index, i.e. if we give 
 * column 'k' we will use the column stored in #mpq_EGdMatrix_t::matrow[*][k], 
 * wich does not mean that we will access the k-th column in the matrix (wich
 * would need to use as index the value #mpq_EGdMatrix_t::row_ord[k] instead). 
 * Note that we don't test wether the given multiple is zero or not. we 
 * always perform the operation.
 * */
#define mpq_EGdMatrixAddColMultiple(__dmatrix,__dest,__orig,__num) do{\
	mpq_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (__dest);\
	const size_t __EGori = (__orig);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) \
		mpq_EGlpNumAddInnProdTo(__EGdm->matrow[__EGdmj][__EGdest],\
												__EGdm->matrow[__EGdmj][__EGori],__num);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set columns 
 * '__dest' to '__dest' - '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in column '__dest', and note that columns '__orig' and '__dest' should be 
 * different. This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the column whose multiple will be added to the '__dest'
 * column.
 * @param '__dest' column to be replaced by '__dest' - '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' column.
 * @note The index of the column are taken as internal index, i.e. if we give 
 * column 'k' we will use the column stored in #mpq_EGdMatrix_t::matrow[*][k], 
 * wich does not mean that we will access the k-th column in the matrix (wich 
 * would need to use as index the value #mpq_EGdMatrix_t::col_ord[k] instead). 
 * Note that we don't test wether the given multiple is zero or not. we 
 * always perform the operation.
 * */
#define mpq_EGdMatrixSubColMultiple(__dmatrix,__dest,__orig,__num) do{\
	mpq_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (size_t)(__dest);\
	const size_t __EGori = (size_t)(__orig);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) \
		mpq_EGlpNumSubInnProdTo(__EGdm->matrow[__EGdmj][__EGdest],\
												__EGdm->matrow[__EGdmj][__EGori],__num);\
	} while(0)
/* ========================================================================= */
/** @brief Given a number and a column, multiply the complete column by the 
 * given number. Note that the number MUST_NOT be stored in the column being 
 * multiplied, this is because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param __colind index of the column being multiplied, note that we will 
 * multiply the column stored in #mpq_EGdMatrix_t::matrow[*][__colind], wich is 
 * different to say that we multiply the column in the __colind-th position in
 * the column ordering (to do that, then __colind should be 
 * #mpq_EGdMatrix_t::col_ord[k]).
 * @param __mult constant to be multiply to the column.
 * */
#define mpq_EGdMatrixMultiplyCol(__dmatrix,__colind,__mult) do{\
	mpq_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdmi = (__colind);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) mpq_EGlpNumMultTo(__EGdm->matrow[__EGdmj][__EGdmi],__mult);\
	} while(0)


/* ========================================================================= */
/** @brief This function performs gaussian elimination to the given matrix,
 * depending on the given options it may do row/columns permutations allong the
 * way to improve numerical stabillity.
 * @param __dmatrix dense matrix structure pointer.
 * @param do_col_perm if set to one, the try columns permutation to improve
 * numericall stabillity, otherwise, not do column permutations at all.
 * @param do_row_perm if set to one, try row permutations to improve numericall
 * stabillity, otherwise, not do row permutations at all.
 * @param status pointer to where return an status, if the procedure finish all
 * the way (i.e. the matrix is full rank), then we return #EG_ALGSTAT_SUCCESS,
 * if the matrix is found to be partial rank, the status is
 * #EG_ALGSTAT_PARTIAL, otherwise, we return #EG_ALGSTAT_NUMERROR, wich means
 * that we stoped because a zero pivot was found (after checking for allowed
 * row/collumns permmutations).
 * @param rank where to return the (proven) rank of the matrix. This number is
 * accurate if the status is #EG_ALGSTAT_SUCCESS, or #EG_ALGSTAT_PARTIAL, but
 * is just a lower bound if the status is #EG_ALGSTAT_NUMERROR
 * @param zero_tol What is the threshold for a value to be considered zero.
 * @return if no error happen, we return zero, otherwise a non-zero valued is
 * returned. Note that the algorithm status is independent of the return value,
 * non zero values araise only if an error happen during execution, wich is
 * different to say that the algorithm didn't finish correctly. */
int mpq_EGdMatrixGaussianElimination (mpq_EGdMatrix_t * const __dmatrix,
																	const unsigned do_col_perm,
																	const unsigned do_row_perm,
																	unsigned *const rank,
																	const mpq_t zero_tol,
																	int *const status);

/* ========================================================================= */
/** @}*/
#endif
#endif
#endif
#ifdef HAVE_LIBGMP
#if HAVE_LIBGMP
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef mpq___EG_DBASIS_REDUCTION__
#define mpq___EG_DBASIS_REDUCTION__
/* ========================================================================= */
/** @defgroup EGdBasisRed LLL Basis Reduction
 * Here we define a common interface for dense matrices (i.e. a structure), and
 * some common operations over dense matrices. The definition uses EGlpNum as
 * reference number type, this allow for template initializations.
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2005-10-28
 *  					- First implementation.
 * */
/**  @{ */
/** @file
 * @brief This file provide the user interface and function definitions for
 * the so-called LLL Basis Reduction Algorithm. This algorithm was first
 * presented in the paper "Factoring polynomials with rational coefficients",
 * Mathematische Annalen 261 (1981), p515-534. and has been extensivelly
 * studied elsewere. for more details just Google-it.
 * */
/** @example mpq_eg_dmatrix.ex.c */
/* ========================================================================= */
/** @brief verbosity level */
#define mpq_EG_DBSRED_VERBOSE 0

/* ========================================================================= */
/** @name Profiling structures and functions for the basis reduction algorithm.
 * */
/* @{ */
/* ========================================================================= */
/** @brief where to hold the profile information */
extern uintmax_t mpq_EGdBsRedStats[10];

/* ========================================================================= */
/** @brief where we store the number of calls to #mpq_EGdBsRed */
#define mpq_EG_BSRED_CALLS 0

/* ========================================================================= */
/** @brief where we store the total number of size reductions performed in 
 * #mpq_EGdBsRed */
#define mpq_EG_BSRED_SZRED 1

/* ========================================================================= */
/** @brief where we store the total number of interchanges performed in 
 * #mpq_EGdBsRed */
#define mpq_EG_BSRED_INTR 2

/* ========================================================================= */
/** @brief where we store the total number of innermost loops performed in 
 * #mpq_EGdBsRed */
#define mpq_EG_BSRED_ITT 3

/* ========================================================================= */
/** @brief Print into the given file stream, the current statistics related
 * to the #mpq_EGdBsRed algorithm. And reset all counters to zero.
 * @param __ofile where we want to print the profile information. */
#define mpq_EGdBsRedProfile(__ofile) do{\
	fprintf(__ofile,"LLL Basis Reduction Statistics:\n");\
	fprintf(__ofile,"\tNumber Calls    : %ju\n", mpq_EGdBsRedStats[mpq_EG_BSRED_CALLS]);\
	fprintf(__ofile,"\tLoops           : %ju\n", mpq_EGdBsRedStats[mpq_EG_BSRED_ITT]);\
	fprintf(__ofile,"\tSize Reductions : %ju\n", mpq_EGdBsRedStats[mpq_EG_BSRED_SZRED]);\
	fprintf(__ofile,"\tInterchanges    : %ju\n", mpq_EGdBsRedStats[mpq_EG_BSRED_INTR]);\
	memset(mpq_EGdBsRedStats,0,sizeof(mpq_EGdBsRedStats));} while(0)

/* @} */

/* ========================================================================= */
/** @brief Value used in condition two of the LLL algorithm, remember that this
 * number should be between \f$(1/4,1)\f$. By default we choose \f$\lambda =
 * \frac{2^{20}-1}{2^{20}} \approx .99999904632568359375 \f$. */
#define mpq_EG_DBSRED_ALPHA 0x7ffffp-20

/* ========================================================================= */
/** @brief structure to hold all necesary data to perform the LLL's basis
 * reduction algorithm. */
typedef struct mpq_EGdBsRed_t
{
	size_t dim;				/**< @brief Number of elements in the basis */
	size_t length;		/**< @brief Length of the vectors in the basis, note that
												 it should be that length >= dim */
	size_t basis_sz;	/**< @brief Actual length of the #mpq_EGdBsRed_t::basis 
												 array */
	mpq_t **basis;/**< @brief array of pointers to arrays containing the 
												 vector basis in extended (including zero coef) form. 
												 The vectors themselves are considered as allocated 
												 outside. everything else is considered as internally
												 allocated. */
	mpq_EGdMatrix_t GM;		/**< @brief Here we store and compute the Gram-Schmidt 
												 needed for the LLL basis reduction algorithm */
}
mpq_EGdBsRed_t;

/* ========================================================================= */
/** @brief Initialize an #mpq_EGdBsRed_t structure, as a basis with zero elements
 * of dimension zero.
 * @param __bsred pointer to an #mpq_EGdBsRed_t structure.
 * */
#define mpq_EGdBsRedInit(__bsred) do{\
	mpq_EGdBsRed_t*const __EGdbs = (__bsred);\
	memset(__EGdbs,0,sizeof(mpq_EGdBsRed_t));\
	mpq_EGdMatrixInit(&(__EGdbs->GM));} while(0)

/* ========================================================================= */
/** @brief Free any internally allocated memory in a #mpq_EGdBsRed_t structure.
 * @param __bsred pointer to an #mpq_EGdBsRed_t structure.
 * */
#define mpq_EGdBsRedClear(__bsred) do{\
	mpq_EGdBsRed_t*const __EGdbs = (__bsred);\
	if(__EGdbs->basis) EGfree(__EGdbs->basis);\
	mpq_EGdMatrixClear(&(__EGdbs->GM));} while(0)

/* ========================================================================= */
/** @brief reset an #mpq_EGdBsRed_t structure as a basis without elements (note
 * that we do not reset the length of the vectors, just the number of vectors 
 * in the basis).
 * @param __bsred pointer to an #mpq_EGdBsRed_t structure.
 * */
#define mpq_EGdBsRedReset(__bsred) ((__bsred)->dim = 0)

/* ========================================================================= */
/** @brief set the length of the vectors used in the basis for an #mpq_EGdBsRed_t
 * structure.
 * @param __bsred pointer to an #mpq_EGdBsRed_t structure.
 * @param __new_length length of the vectors in the basis.
 * */
#define mpq_EGdBsRedSetLength(__bsred,__new_length) ((__bsred)->length = (__new_length))

/* ========================================================================= */
/** @brief add a new vector to the basis.
 * @param __bsred pointer to an #mpq_EGdBsRed_t structure.
 * @param __new_elem new vector to add to the basis.
 * */
#define mpq_EGdBsRedAddElement(__bsred,__new_elem) do{\
	mpq_EGdBsRed_t*const __EGdbs = (__bsred);\
	if(__EGdbs->basis_sz <= __EGdbs->dim){\
		__EGdbs->basis_sz += 10U;\
		EGrealloc(__EGdbs->basis,sizeof(mpq_t*)*__EGdbs->basis_sz);}\
	__EGdbs->basis[__EGdbs->dim++] = (__new_elem);} while(0)

/* ========================================================================= */
/** @brief This function performs the so-called LLL basis reduction algorithm.
 * @param __bsred pointer to an #mpq_EGdBsRed_t structure.
 * @param status where we return the status of the algorithm, if the algorithm
 * finish with non-zero reduced elements, the status is #EG_ALGSTAT_SUCCESS. if
 * the algorithm finish with some zero reduced vector, the status is
 * #EG_ALGSTAT_PARTIAL. if the algorithm stop because of numerical problems,
 * the status is #EG_ALGSTAT_NUMERROR.
 * @param zero_tol threshold for a number to be considered as zero.
 * @param dim pointer to a number where we return the dimension of the basis
 * that the algorithm could prove before running in any numerical problem. If
 * the algorithm stop with status #EG_ALGSTAT_SUCCESS, then this number should
 * be equal to #mpq_EGdBsRed_t::dim. The vectors that we finish reducing are stored
 * in #mpq_EGdMatrix_t::row_ord[0], ... , #mpq_EGdMatrix_t::row_ord[dim], in the
 * #mpq_EGdBsRed_t::GM matrix.
 * @return zero if the algorithm finish, non-zero if an unforeseen error occure
 * during execution. 
 * @par Details:
 * The implementation that we use introduce (as an heuristic step) the sorting
 * of the original basis vectors in increasing order according to their norms,
 * this simple step reduced the total running time of the algorithm, but does
 * not improve the theoretical running time. A second detail is that we only
 * compute the Gram-Schmidth coefficients only once (at the beggining of the
 * program), and then, we only update the changed entries for both operations
 * \a size \a reduction and \a interchange. The advantage of the approach is
 * that we save most Gram-Schmidth computations and also all the recomputations
 * of the inner products of the elements currently in the basis. Again, this
 * are improvements form the practical point of view, but not in practice. The
 * dissadvantage of this approach is that we do accumulate rounding errors in
 * the Gram-Schmidth coefficients allong the way, but if all original vectors
 * coefficients where integer (and not too big), then the error should not grow
 * too much. Still this may happen if the input basis is ill conditioned.
 * */
int mpq_EGdBsRed (mpq_EGdBsRed_t * const __bsred,
							unsigned *const dim,
							const mpq_t zero_tol,
							int *const status);

/* ========================================================================= */
/**  @} */
#endif
#endif
#endif
#ifdef HAVE_LIBGMP
#if HAVE_LIBGMP
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGeHeap EGeHeap
 *
 * Here we define the basic interface for d-heaps as an embeded structure.
 * In this implementation the heap does not grow on the fly, meaning that it 
 * may fills-up during an add call, to avoid that, the user must call 
 * re-allocate when necesary. the heap start as a heap of size zero. 
 * This implementatioon is a minimum-heap implementatiton. Note also that the
 * internal connector array is shifted one position to the left. This is done 
 * so that the first element is in position 1, this also speed-up the 
 * computation of the parent and childrens of a given position.
 *
 * @version 0.0.1
 * @par History:
 * - 2010-09-05
 * 						- mpq_EGeHeapClear will free any internal memory (even if it was
 * 						asked for by the user).
 * - 2005-07-14
 * 						- Add mpq_EGeHeapEmpty to empty the heap (but keep its maximum
 * 							size)
 * 						- Add mpq_EGeHeapIsFull to test wether a heap is full or not.
 * - 2005-07-07
 * 						- First Implementation
 * @note 
 * This implementatiton is designed as a template using as base the types of
 * @ref EGlpNum
 * */
/** @file 
 * @ingroup EGeHeap */
/** @addtogroup EGeHeap */
/** @{ */
/** @example mpq_eg_eheap.ex.c
 * This is a simple example of the usage of heaps using @ref EGeHeap */
/* ========================================================================= */
#ifndef mpq___EG_EHEAP__
#define mpq___EG_EHEAP__
/* ========================================================================= */
/** @brief Debug level for the heap */
#ifndef mpq_EG_EHEAP_DEBUG
#define mpq_EG_EHEAP_DEBUG 1000
#endif

/* ========================================================================= */
/** @name Test macros, enabled only if debug level is high enough. */
/** @{ */
#if mpq_EG_EHEAP_DEBUG <= DEBUG
#define mpq_EGeHeapCHECK_CN(__hp2,__hcn2) EXIT(__hcn2->pos>=__hp2->sz,"Heap Connector possition %d out of range [0,%d]",__hcn2->pos,__hp2->sz)
#define mpq_EGeHeapCHECK_NF(__hp2) EXIT(__hp2->sz >= __hp2->max_sz,"Heap "#__hp2" Is full, can't add an element")
#else
#define mpq_EGeHeapCHECK_CN(__hp,__hcn) 
#define mpq_EGeHeapCHECK_NF(__hp) 
#endif
/** @} */
/* ========================================================================= */
/** @brief Structure to store the information relevant to an element in the
 * heap. */
typedef struct 
{
	mpq_t val;		/**< Value of this node in the heap */
	unsigned int pos;	/**< Position in the heap array for this node, if set to
												 #mpq_EG_EHEAP_POISON, then the connector is not in any 
												 heap.*/
}
mpq_EGeHeapCn_t;

/* ========================================================================= */
/** @brief Poison position for heap connector not in a heap. */
#define mpq_EG_EHEAP_POISON UINT_MAX

/* ========================================================================= */
/** @brief Initialize a heap conector structure. This function will allocate any
 * interal memory not allocated by the user, it should be called only once, or
 * after a clear function call.
 * @param __hcn conector to initialize.
 * */
#define mpq_EGeHeapCnInit(__hcn) ({mpq_EGlpNumInitVar((__hcn)->val);(__hcn)->pos = mpq_EG_EHEAP_POISON;})

/* ========================================================================= */
/** @brief Reset a heap conector to the same state as after an init call, this
 * function is provided only for completness.
 * @param __hcn conector to reset
 * */
#define mpq_EGeHeapCnReset(__hcn) ((__hcn)->pos = mpq_EG_EHEAP_POISON)

/* ========================================================================= */
/** @brief Free all internal memory used by this structured not allocated by the
 * user. This function should be called after an init call, and only once.
 * @param __hcn conector to clear.
 * */
#define mpq_EGeHeapCnClear(__hcn) mpq_EGlpNumClearVar((__hcn)->val)

/* ========================================================================= */
/** @brief Structure to hold a whole heap structure, this structure is designed
 * so that it can grow on the fly with a low cost */
typedef struct 
{
	mpq_EGeHeapCn_t **cn;
	unsigned int d;
	unsigned int sz;
	unsigned int max_sz;
}
mpq_EGeHeap_t;

/* ========================================================================= */
/** @brief Return one if the heap is full, zero otherwise.
 * @param __hp heat to check */
#define mpq_EGeHeapIsFull(__hp) ({mpq_EGeHeap_t*const __EGehp = (__hp); __EGehp->sz == __EGehp->max_sz;})

/* ========================================================================= */
/** @brief set the number of elements in hte heap to zero.
 * @param __hp heap to empty.
 * */
#define mpq_EGeHeapEmpty(__hp) ((__hp)->sz = 0)

/* ========================================================================= */
/** @brief Initialize a heap as an empty heap (with no space for conectors).
 * @param __hp heap to initialize.
 * */
#define mpq_EGeHeapInit(__hp) (*(__hp) = (mpq_EGeHeap_t){0,0,0,0})

/* ========================================================================= */
/** @brief Reset the given heap as an empty heap (just as returned by the init
 * call.
 * @param __hp heap to reset 
 * */
#define mpq_EGeHepReset(__hp) mpq_EGeHeapResize(__hp,0)

/* ========================================================================= */
/** @brief Clear a heap structure, and free any internal memory (not allocated
 * by the user).
 * @param __hp heap to clear.
 * */
#define mpq_EGeHeapClear(__hp) mpq_EGeHeapResize(__hp,0)

/* ========================================================================= */
/** @brief get the minimum value in the heap.
 * @param __hp heap where we are working.
 * @param number where to store the result
 * @return zero on success, non-zero otherwise.
 * */
#define mpq_EGeHeapGetMinVal(__hp,number) ({\
	mpq_EGeHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? (mpq_EGlpNumCopy(number,__EGehp->cn[0]->val),0):1;})

/* ========================================================================= */
/** @brief get the minimum conector in the heap, if the heap is empty, return
 * NULL.
 * @param __hp eap where we are working.
 * @return pointer to the minimum element in the heap.
 * */
#define mpq_EGeHeapGetMin(__hp) ({\
	mpq_EGeHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? __EGehp->cn[0] : 0;})

/* ========================================================================= */
/** @brief resize the heap cn array to the given size, if the new size is zero,
 * it is equivalent to free the internal memory, and left the heap as an empty
 * heap with zero space.
 * @param __hp heap where we are working.
 * @param new_sz new size for the  cn array .
 * */
#define mpq_EGeHeapResize(__hp,new_sz) ({\
	mpq_EGeHeap_t*const __EGehp = (__hp);\
	const size_t __EGehp_nsz = (size_t)(new_sz);\
	__EGehp->cn = EGrealloc((__EGehp->cn), __EGehp_nsz * sizeof(mpq_EGeHeapCn_t*));\
	__EGehp->max_sz = (unsigned int)(__EGehp_nsz);})

/* ========================================================================= */
/** @brief return the index of the father of the given index.
 * @param __d breadth of the heap.
 * @param __id position in the array to wich we want to compute it's father.
 * */
#define mpq_EGeHeapFatherId(__d,__id) ((__id)?(((__id)-1)/(__d)):0)

/* ========================================================================= */
/** @brief move an element in the heap up in the heap (position 0 is the top,
 * this kind of move is neded whenever we decrease the value in a heap element).
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * */
#define mpq_EGeHeapSiftUp(__hp,__hcn) ({\
	mpq_EGeHeap_t*const __EGehp = (__hp);\
	mpq_EGeHeapCn_t*const __EGecn = (__hcn);\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfpos = mpq_EGeHeapFatherId(__EGehp->d,__EGcpos);\
	mpq_EGeHeapCn_t*__EGfcn = __EGehp->cn[__EGfpos];\
	mpq_EGeHeapCHECK_CN(__EHehp,__EGecn);\
	while(__EGcpos && \
				mpq_EGlpNumIsLess(__EGecn->val,__EGfcn->val))\
	{\
		__EGfcn->pos = __EGcpos;\
		__EGehp->cn[__EGcpos] = __EGfcn;\
		__EGcpos = __EGfpos;\
		__EGfpos = mpq_EGeHeapFatherId(__EGehp->d,__EGcpos);\
		__EGfcn = __EGehp->cn[__EGfpos];\
	}\
	__EGecn->pos = __EGcpos;\
	__EGehp->cn[__EGcpos] = __EGecn;\
	0;})

/* ========================================================================= */
/** @brief Add an element to the heap
 * @param __hp heap where to add the element.
 * @param __hcn element to be added.
 * @return zero on success, non-zero otherwise.
 * */
#define mpq_EGeHeapAdd(__hp,__hcn) ({\
	mpq_EGeHeap_t*const __EGlhp = (__hp);\
	mpq_EGeHeapCn_t*const __EGlcn = (__hcn);\
	mpq_EGeHeapCHECK_NF(__EGlhp);\
	__EGlcn->pos = __EGlhp->sz, \
	__EGlhp->cn[__EGlhp->sz] = __EGlcn;\
	__EGlhp->sz +=1, \
	mpq_EGeHeapSiftUp(__EGlhp,__EGlcn), 0;})

/* ========================================================================= */
/** @brief Give the first child for a given position.
 * @param __id position that we want to get the first child.
 * @param __d breath of the heap. */
#define mpq_EGeHeapFirstChildId(__d,__id) ((__d)*(__id)+1)

/* ========================================================================= */
/** @brief Move an element down in the heap (position 0 is the
 * top), this kind of operation is needed whenever we increase the value in a
 * heap element.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define mpq_EGeHeapSiftDown(__hp,__hcn) ({\
	mpq_EGeHeap_t*const __EGehp = (__hp);\
	mpq_EGeHeapCn_t*const __EGecn = (__hcn);\
	const unsigned int __EGhsz = __EGehp->sz;\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfchd = mpq_EGeHeapFirstChildId(__EGehp->d,__EGcpos);\
	unsigned int __EGlchd = __EGfchd + __EGehp->d;\
	mpq_EGeHeapCn_t*__EGcchd = 0;\
	register unsigned int __EGehi = 0;\
	mpq_EGeHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGfchd < __EGhsz)\
	{\
		/* detect the minimum child */\
		__EGcchd = __EGehp->cn[__EGfchd];\
		for(__EGehi = __EGlchd > __EGhsz ? __EGhsz-1 : __EGlchd-1 ;\
			__EGehi > __EGfchd ; __EGehi--)\
			if(mpq_EGlpNumIsLess(__EGehp->cn[__EGehi]->val,__EGcchd->val))\
				__EGcchd = __EGehp->cn[__EGehi];\
		/* if the minimum child is less than the current position, move the minimum\
		 * child to the position of the current element */\
		if(mpq_EGlpNumIsLess(__EGcchd->val,__EGecn->val))\
		{\
			__EGfchd = __EGcchd->pos;\
			__EGcchd->pos = __EGcpos;\
			__EGehp->cn[__EGcpos] = __EGcchd;\
			__EGecn->pos = __EGcpos = __EGfchd;\
			__EGehp->cn[__EGcpos] = __EGecn;\
			__EGfchd = mpq_EGeHeapFirstChildId(__EGehp->d,__EGcpos);\
			__EGlchd = __EGfchd + __EGehp->d;\
		}\
		/* else we exit the main loop */\
		else __EGfchd = UINT_MAX;\
	}\
	0;})

/* ========================================================================= */
/** @brief Change the value of an element in the heap.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap that we are going to change it's value.
 * @param __new_val new value for the element.
 * @return zero on success, non-zero otherwise.
 * */
#define mpq_EGeHeapChangeVal(__hp,__hcn,__new_val) ({\
	(mpq_EGlpNumIsLess(__new_val,(__hcn)->val)) ? (mpq_EGlpNumCopy((__hcn)->val,__new_val),mpq_EGeHeapSiftUp(__hp,__hcn)) : (mpq_EGlpNumCopy((__hcn)->val,__new_val),mpq_EGeHeapSiftDown(__hp,__hcn));})

/* ========================================================================= */
/** @brief Eliminate an element from the heap, note that the position stored in
 * the eliminated element is reset to zero.
 * @param __hp heap where we are working.
 * @param __hcn element to eliminate from the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define mpq_EGeHeapDel(__hp,__hcn) ({\
	mpq_EGeHeap_t*const __EGlhp = (__hp);\
	mpq_EGeHeapCn_t*const __EGlhpcn = (__hcn);\
	unsigned int const __EGlcn = __EGlhpcn->pos;\
	unsigned int const __EGlhsz = __EGlhp->sz - 1;\
	__EGlhpcn->pos = mpq_EG_EHEAP_POISON;\
	__EGlhp->sz = __EGlhsz;\
	if(__EGlhsz && __EGlhsz != __EGlcn){\
		__EGlhp->cn[__EGlcn] = __EGlhp->cn[__EGlhp->sz];\
		__EGlhp->cn[__EGlcn]->pos = __EGlcn;\
		mpq_EGeHeapSiftDown(__EGlhp,__EGlhp->cn[__EGlcn]);}\
	__EGlhp->cn[__EGlhp->sz] = 0;})

/* ========================================================================= */
/** @brief Check the integrity of the given heap.
 * @param __hp heap to check.
 * @return zero on success, non-zero otherwise.
 * */
#if mpq_EG_EHEAP_DEBUG <= DEBUG
#define mpq_EGeHeapCheck(__hp) ({\
	mpq_EGeHeap_t*const __EGehp = (__hp);\
	register unsigned int __EGehi = __EGehp->sz;\
	if(__EGehi)\
		while(--__EGehi)\
			if(__EGehp->cn[__EGehi]->pos != __EGehi || mpq_EGlpNumIsLess( __EGehp->cn[\
				 __EGehi]->val,__EGehp->cn[mpq_EGeHeapFatherId(__EGehp->d,__EGehi)]->val))\
			{\
				MESSAGE(mpq_EG_EHEAP_DEBUG,"Element %u is wrong, pos %u val [%lf,%lf]"\
							 ,__EGehi, __EGehp->cn[__EGehi]->pos, \
							 mpq_EGlpNumToLf(__EGehp->cn[__EGehi]->val), \
							 mpq_EGlpNumToLf(__EGehp->cn[mpq_EGeHeapFatherId(__EGehp->d,__EGehi)]->val));\
				break;\
			}\
	__EGehi;})
#else
#define mpq_EGeHeapCheck(__hp) 0
#endif

/* ========================================================================= */
/** @brief set the breath of the heap, this function must be called only when
 * the heap is empty.
 * @param __hp heap to set breath.
 * @param __width new with for the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define mpq_EGeHeapChangeD(__hp,__width) ({\
	mpq_EGeHeap_t*const __EGehp = (__hp);\
	EXIT((__width)<2,"Width should be at least 2 for heaps");\
	__EGehp->sz ? 1 : (__EGehp->d = (__width), 0);})

/* ========================================================================= */
/** @} */
/* end of mpq_eg_eheap.h */
#endif
#endif
#endif
#ifdef HAVE_LIBGMP
#if HAVE_LIBGMP
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGeKHeap EGeKHeap
 *
 * Here we define the basic interface for d-heaps with an array of values with
 * the lexicographic order for vectors as an embeded structure.
 * In this implementation the heap does not grow on the fly, meaning that it 
 * may fill-up during an add call, to avoid that, the user must call 
 * re-allocate when necesary. the heap start as a heap of size zero. 
 * This implementatioon is a minimum-heap implementatiton. Note also that the
 * internal connector array is shifted one position to the left. This is done 
 * so that the first element is in position 1, this also speed-up the 
 * computation of the parent and childrens of a given position.
 *
 * @version 0.0.1
 * @par History:
 * - 2010-09-05
 * 						- Change implementation of mpq_EGeKHeapClear to free all internal
 * 						memory, including the one asked for the user during a
 * 						mpq_EGeKHeapResize call.
 * - 2008-07-30
 * 						- First implementation
 * @note 
 * This implementatiton is designed as a template using as base the types of
 * @ref EGlpNum
 * */
/** @file 
 * @ingroup EGeKHeap */
/** @addtogroup EGeKHeap */
/** @{ */
/** @example mpq_eg_ekheap.ex.c
 * This is a simple example of the usage of heaps using @ref EGeKHeap */
/* ========================================================================= */
#ifndef mpq___EG_EKHEAP__
#define mpq___EG_EKHEAP__
/* ========================================================================= */
/** @brief Debug level for the heap */
#ifndef mpq_EG_EKHEAP_DEBUG
#define mpq_EG_EKHEAP_DEBUG 100
#endif

/* ========================================================================= */
/** @name Test macros, enabled only if debug level is high enough. */
/** @{ */
#if mpq_EG_EKHEAP_DEBUG <= DEBUG
#define mpq_EGeKHeapCHECK_CN(__hp2,__hcn2) EXIT(__hcn2->pos>=__hp2->sz,"Heap Connector possition %d out of range [0,%d]",__hcn2->pos,__hp2->sz)
#define mpq_EGeKHeapCHECK_NF(__hp2) EXIT(__hp2->sz >= __hp2->max_sz,"Heap "#__hp2" Is full, can't add an element")
#else
#define mpq_EGeKHeapCHECK_CN(__hp,__hcn) 
#define mpq_EGeKHeapCHECK_NF(__hp) 
#endif
/** @} */
/* ========================================================================= */
/** @brief number of maximum entries in the vector values */
#ifndef mpq_EG_EKHEAP_ENTRY
#define mpq_EG_EKHEAP_ENTRY 3
#endif
/* ========================================================================= */
/** @brief Structure to store the information relevant to an element in the
 * heap. */
typedef struct
{
	mpq_t val[mpq_EG_EKHEAP_ENTRY];/**< Value of this node in the heap */
	unsigned int pos;	/**< Position in the heap array for this node, if set to
												 #mpq_EG_EKHEAP_POISON, then the connector is not in any 
												 heap.*/
}
mpq_EGeKHeapCn_t;

/* ========================================================================= */
/** @brief Poison position for heap connector not in a heap. */
#define mpq_EG_EKHEAP_POISON UINT_MAX

/* ========================================================================= */
/** @brief Initialize a heap conector structure. This function will allocate any
 * interal memory not allocated by the user, it should be called only once, or
 * after a clear function call.
 * @param __hcn conector to initialize.
 * */
#define mpq_EGeKHeapCnInit(__hcn) do{\
	mpq_EGeKHeapCn_t*const __EKHcn = (__hcn);\
	int __EKHi = mpq_EG_EKHEAP_ENTRY;\
	memset(__EKHcn,0,sizeof(mpq_EGeKHeapCn_t));\
	for( ; __EKHi-- ; ){mpq_EGlpNumInitVar(__EKHcn->val[__EKHi]);}\
	__EKHcn->pos = mpq_EG_EKHEAP_POISON;}while(0)

/* ========================================================================= */
/** @brief Reset a heap conector to the same state as after an init call, this
 * function is provided only for completness.
 * @param __hcn conector to reset
 * */
#define mpq_EGeKHeapCnReset(__hcn) ((__hcn)->pos = mpq_EG_EKHEAP_POISON)

/* ========================================================================= */
/** @brief Free all internal memory used by this structured not allocated by the
 * user. This function should be called after an init call, and only once.
 * @param __hcn conector to clear.
 * */
#define mpq_EGeKHeapCnClear(__hcn) do{\
	mpq_EGeKHeapCn_t*const __EKHcn = (__hcn);\
	int __EKHi = mpq_EG_EKHEAP_ENTRY;\
	for( ; __EKHi-- ; ){mpq_EGlpNumClearVar(__EKHcn->val[__EKHi]);}}while(0)

/* ========================================================================= */
/** @brief Structure to hold a whole heap structure, this structure is designed
 * so that it can grow on the fly with a low cost */
typedef struct
{
	mpq_EGeKHeapCn_t **cn;
	unsigned int d;
	unsigned int sz;
	unsigned int max_sz;
}
mpq_EGeKHeap_t;

/* ========================================================================= */
/** @brief Return one if the heap is full, zero otherwise.
 * @param __hp heat to check */
#define mpq_EGeKHeapIsFull(__hp) ({mpq_EGeKHeap_t*const __EGekhp = (__hp); __EGekhp->sz == __EGekhp->max_sz;})

/* ========================================================================= */
/** @brief set the number of elements in hte heap to zero.
 * @param __hp heap to empty.
 * */
#define mpq_EGeKHeapEmpty(__hp) ((__hp)->sz = 0)

/* ========================================================================= */
/** @brief Initialize a heap as an empty heap (with no space for conectors).
 * @param __hp heap to initialize.
 * */
#define mpq_EGeKHeapInit(__hp) (*(__hp) = (mpq_EGeKHeap_t){0,0,0,0})

/* ========================================================================= */
/** @brief Reset the given heap as an empty heap (just as returned by the init
 * call.
 * @param __hp heap to reset 
 * */
#define mpq_EGeKHepReset(__hp) mpq_EGeKHeapResize(__hp,0)

/* ========================================================================= */
/** @brief Clear a heap structure, and free any internal memory (not allocated
 * by the user).
 * @param __hp heap to clear.
 * */
#define mpq_EGeKHeapClear(__hp) mpq_EGeKHeapResize(__hp,0)

/* ========================================================================= */
/** @brief get the minimum value in the heap, note that since we are dealing
 * with a vector of values sorted lexicographically, the value is the value in
 * the first coordinate, other values can be accesses through
 * mpq_EGeKHeapGetMinKVal function.
 * @param __hp heap where we are working.
 * @param __number where to store the result
 * @return zero on success, non-zero otherwise.
 * */
#define mpq_EGeKHeapGetMinVal(__hp,__number) ({\
	mpq_EGeKHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? (mpq_EGlpNumCopy(__number,__EGehp->cn[0]->val[0]),0):1;})

/* ========================================================================= */
/** @brief get the k-th value of the first element in the heap.
 * @param __hp heap where we are working.
 * @param __number where to store the result.
 * @param __k which value to get (between 0 and mpq_EG_EKHEAP_ENTRY.
 * @return zero on success, non-zero otherwise.
 * */
#define mpq_EGeKHeapGetMinKVal(__hp,__k,__number) ({\
	mpq_EGeKHeap_t*const __EGehp = (__hp);\
	const int __EGki = (__k);\
	EXITL(mpq_EG_EKHEAP_DEBUG,(__EGki >= mpq_EG_EKHEAP_ENTRY) || (__EGki <0),\
				"K=%d out of range in mpq_EGeKHeapGetMinKVal", __EGki);\
	__EGehp->sz ? (mpq_EGlpNumCopy(__number,__EGehp->cn[0]->val[__EGki]),0):1;})

/* ========================================================================= */
/** @brief get the minimum conector in the heap, if the heap is empty, return
 * NULL.
 * @param __hp eap where we are working.
 * @return pointer to the minimum element in the heap.
 * */
#define mpq_EGeKHeapGetMin(__hp) ({\
	mpq_EGeKHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? __EGehp->cn[0] : 0;})

/* ========================================================================= */
/** @brief resize the heap cn array to the given size, if the new size is zero,
 * it is equivalent to free the internal memory, and left the heap as an empty
 * heap with zero space.
 * @param __hp heap where we are working.
 * @param __new_sz new size for the  cn array .
 * */
#define mpq_EGeKHeapResize(__hp,__new_sz) ({\
	mpq_EGeKHeap_t*const __EGehp = (__hp);\
	const size_t __EGehp_nsz = (size_t)(__new_sz);\
	__EGehp->cn = EGrealloc((__EGehp->cn), __EGehp_nsz * sizeof(mpq_EGeKHeapCn_t*));\
	__EGehp->max_sz = (unsigned int)(__EGehp_nsz);})

/* ========================================================================= */
/** @brief return the index of the father of the given index.
 * @param __d breadth of the heap.
 * @param __id position in the array to wich we want to compute it's father.
 * */
#define mpq_EGeKHeapFatherId(__d,__id) ((__id)?(((__id)-1)/(__d)):0)

/* ========================================================================= */
/** @brief given two heap connectors, return one if the first is less than the
 * second (in  lexicographic order).
 * @param __hcn1 first vector array.
 * @param __hcn2 second vector array.
 * @return one if __hcn1 <_LEX __hcn2 */
#define mpq_EGeKHeapIsLess(__hcn1,__hcn2) ({\
	mpq_t*const __EGEKH1 = (__hcn1);\
	mpq_t*const __EGEKH2 = (__hcn2);\
	int __EGEKHj = 0, __EGEKHrval = 0;\
	for( ; __EGEKHj < mpq_EG_EKHEAP_ENTRY ; __EGEKHj++)\
	{\
		if(mpq_EGlpNumIsLess(__EGEKH1[__EGEKHj], __EGEKH2[__EGEKHj])){\
			__EGEKHrval = 1; break;}\
		else if (mpq_EGlpNumIsNeq(__EGEKH1[__EGEKHj], __EGEKH2[__EGEKHj],mpq_epsLpNum)){\
			__EGEKHrval = 0; break;}\
	}\
	__EGEKHrval;})

/* ========================================================================= */
/** @brief copy two vector of values (only  mpq_EG_EKHEAP_ENTRY positions) from the
 * rource to the destination.
 * @param src mpq_source array.
 * @param dst destination array.
 * */
void mpq_EGeKHeapCopyVal(mpq_t*const dst, const mpq_t*const src);

/* ========================================================================= */
/** @brief move an element in the heap up in the heap (position 0 is the top,
 * this kind of move is neded whenever we decrease the value in a heap element).
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define mpq_EGeKHeapSiftUp(__hp,__hcn) ({\
	mpq_EGeKHeap_t*const __EGehp = (__hp);\
	mpq_EGeKHeapCn_t*const __EGecn = (__hcn);\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfpos = mpq_EGeKHeapFatherId(__EGehp->d,__EGcpos);\
	mpq_EGeKHeapCn_t*__EGfcn = __EGehp->cn[__EGfpos];\
	mpq_EGeKHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGcpos && \
				mpq_EGeKHeapIsLess(__EGecn->val,__EGfcn->val))\
	{\
		__EGfcn->pos = __EGcpos;\
		__EGehp->cn[__EGcpos] = __EGfcn;\
		__EGcpos = __EGfpos;\
		__EGfpos = mpq_EGeKHeapFatherId(__EGehp->d,__EGcpos);\
		__EGfcn = __EGehp->cn[__EGfpos];\
	}\
	__EGecn->pos = __EGcpos;\
	__EGehp->cn[__EGcpos] = __EGecn;\
	0;})

/* ========================================================================= */
/** @brief Add an element to the heap
 * @param __hp heap where to add the element.
 * @param __hcn element to be added.
 * @return zero on success, non-zero otherwise.
 * */
#define mpq_EGeKHeapAdd(__hp,__hcn) ({\
	mpq_EGeKHeap_t*const __EGlhp = (__hp);\
	mpq_EGeKHeapCn_t*const __EGlcn = (__hcn);\
	mpq_EGeKHeapCHECK_NF(__EGlhp);\
	__EGlcn->pos = __EGlhp->sz, \
	__EGlhp->cn[__EGlhp->sz] = __EGlcn, \
	__EGlhp->sz +=1, \
	mpq_EGeKHeapSiftUp(__EGlhp,__EGlcn), 0;})

/* ========================================================================= */
/** @brief Give the first child for a given position.
 * @param __id position that we want to get the first child.
 * @param __d breath of the heap. */
#define mpq_EGeKHeapFirstChildId(__d,__id) ((__d)*(__id)+1)

/* ========================================================================= */
/** @brief Move an element down in the heap (position 0 is the
 * top), this kind of operation is needed whenever we increase the value in a
 * heap element.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define mpq_EGeKHeapSiftDown(__hp,__hcn) ({\
	mpq_EGeKHeap_t*const __EGehp = (__hp);\
	mpq_EGeKHeapCn_t*const __EGecn = (__hcn);\
	const unsigned int __EGhsz = __EGehp->sz;\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfchd = mpq_EGeKHeapFirstChildId(__EGehp->d,__EGcpos);\
	unsigned int __EGlchd = __EGfchd + __EGehp->d;\
	mpq_EGeKHeapCn_t*__EGcchd = 0;\
	register unsigned int __EGehi = 0;\
	mpq_EGeKHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGfchd < __EGhsz)\
	{\
		/* detect the minimum child */\
		__EGcchd = __EGehp->cn[__EGfchd];\
		for(__EGehi = __EGlchd > __EGhsz ? __EGhsz-1 : __EGlchd-1 ;\
			__EGehi > __EGfchd ; __EGehi--)\
			if(mpq_EGeKHeapIsLess(__EGehp->cn[__EGehi]->val,__EGcchd->val))\
				__EGcchd = __EGehp->cn[__EGehi];\
		/* if the minimum child is less than the current position, move the minimum\
		 * child to the position of the current element */\
		if(mpq_EGeKHeapIsLess(__EGcchd->val,__EGecn->val))\
		{\
			__EGfchd = __EGcchd->pos;\
			__EGcchd->pos = __EGcpos;\
			__EGehp->cn[__EGcpos] = __EGcchd;\
			__EGecn->pos = __EGcpos = __EGfchd;\
			__EGehp->cn[__EGcpos] = __EGecn;\
			__EGfchd = mpq_EGeKHeapFirstChildId(__EGehp->d,__EGcpos);\
			__EGlchd = __EGfchd + __EGehp->d;\
		}\
		/* else we exit the main loop */\
		else __EGfchd = UINT_MAX;\
	}\
	0;})

/* ========================================================================= */
/** @brief Change the value of an element in the heap.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap that we are going to change it's value.
 * @param __new_val new value for the element (note this is an array of size at
 * least mpq_EG_EKHEAP_ENTRY.
 * @return zero on success, non-zero otherwise.
 * */
#define mpq_EGeKHeapChangeVal(__hp,__hcn,__new_val) ({\
	mpq_EGeKHeapCn_t*const __EGEKHcn = (__hcn);\
	(mpq_EGeKHeapIsLess(__new_val,(__EGEKHcn)->val)) ? (mpq_EGeKHeapCopyVal((__EGEKHcn)->val,__new_val),mpq_EGeKHeapSiftUp(__hp,__EGEKHcn)) : (mpq_EGeKHeapCopyVal((__EGEKHcn)->val,__new_val),mpq_EGeKHeapSiftDown(__hp,__EGEKHcn));})

/* ========================================================================= */
/** @brief Eliminate an element from the heap, note that the position stored in
 * the eliminated element is reset to zero.
 * @param __hp heap where we are working.
 * @param __hcn element to eliminate from the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define mpq_EGeKHeapDel(__hp,__hcn) ({\
	mpq_EGeKHeap_t*const __EGlhp = (__hp);\
	mpq_EGeKHeapCn_t*const __EGlhpcn = (__hcn);\
	unsigned int const __EGlcn = __EGlhpcn->pos;\
	unsigned int const __EGlhsz = __EGlhp->sz - 1;\
	__EGlhpcn->pos = mpq_EG_EKHEAP_POISON;\
	__EGlhp->sz = __EGlhsz;\
	if(__EGlhsz && __EGlhsz != __EGlcn){\
		__EGlhp->cn[__EGlcn] = __EGlhp->cn[__EGlhp->sz];\
		__EGlhp->cn[__EGlcn]->pos = __EGlcn;\
		mpq_EGeKHeapSiftDown(__EGlhp,__EGlhp->cn[__EGlcn]);}\
	__EGlhp->cn[__EGlhp->sz] = 0;})

/* ========================================================================= */
/** @brief Check the integrity of the given heap.
 * @param __hp heap to check.
 * @return zero on success, non-zero otherwise.
 * */
#if mpq_EG_EKHEAP_DEBUG <= DEBUG
#define mpq_EGeKHeapCheck(__hp) ({\
	mpq_EGeKHeap_t*const __EGehp = (__hp);\
	register unsigned int __EGehi = __EGehp->sz;\
	if(__EGehi)\
		while(--__EGehi)\
			if(__EGehp->cn[__EGehi]->pos != __EGehi || \
				mpq_EGeKHeapIsLess( __EGehp->cn[__EGehi]->val,\
												__EGehp->cn[mpq_EGeKHeapFatherId(__EGehp->d,__EGehi)]->val))\
			{\
				MESSAGE(mpq_EG_EKHEAP_DEBUG,"Element %u is wrong, pos %u val [%lf,%lf]"\
							 ,__EGehi, __EGehp->cn[__EGehi]->pos, \
							 mpq_EGlpNumToLf(__EGehp->cn[__EGehi]->val[0]), \
							 mpq_EGlpNumToLf(__EGehp->cn[mpq_EGeKHeapFatherId(__EGehp->d,__EGehi)]->val[0]));\
				break;\
			}\
	__EGehi;})
#else
#define mpq_EGeKHeapCheck(__hp) 0
#endif

/* ========================================================================= */
/** @brief set the breath of the heap, this function must be called only when
 * the heap is empty.
 * @param __hp heap to set breath.
 * @param __width new with for the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define mpq_EGeKHeapChangeD(__hp,__width) ({\
	mpq_EGeKHeap_t*const __EGehp = (__hp);\
	EXIT((__width)<2,"Width should be at least 2 for heaps");\
	__EGehp->sz ? 1 : (__EGehp->d = (__width), 0);})

/* ========================================================================= */
/** @} */
/* end of mpq_eg_ekheap.h */
#endif
#endif
#endif
#ifdef HAVE_LIBGMP
#if HAVE_LIBGMP
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGsrkGraph EGsrkGraph
 * This is a group of functions, macros and types designed to work with
 * graphs that are shrinkable, meaning that we can take two nodes in the
 * (current) graph, and shrink them into a single node, and at the same time
 * collapse all edges that become loops and if two edges are parallel, keep
 * just one (but keep a reference to the collapsed edge). At the same time the
 * shrunken nodes keep a list to the nodes 'embeded' or 'shrunken' into the
 * given node. More details in the structure definition and in the example.
 * Note that this implementation only support undirected graphs with actual
 * weights on the edges, the weights must be of type mpq_t, and their
 * values are updated during the shrinking procedure, so if anyone want to
 * have the original values omewere else, they will have to keep an extra copy
 * outside. Most of the ideas used in this implementation come from CONCORDE.
 * 
 * @version 0.0.1
 * @par History:
 * - 2005-06-01
 * 						- First Implementation.
 * */
/** @file
 * @ingroup EGsrkGraph */
/** @addtogroup EGsrkGraph */
/** @{ */
/** @example mpq_eg_shrink_graph.ex.c */
/* ========================================================================= */

#ifndef mpq__EGshrinkGraph_h__
#define mpq__EGshrinkGraph_h__
#ifndef mpq_EG_SRK_DEBUG
/* ========================================================================= */
/** @brief debuigging level, the lower the more debugging is carried out */
#define mpq_EG_SRK_DEBUG 100
#endif

/* ========================================================================= */
/** @brief Edge structure for shrinkable graphs */
typedef struct mpq_EGsrkEdge_t
{
	EGeUgraphEdge_t edge;	/**< Actual edge structure for the graph */
	EGeList_t members;		/**< list of other edges shrunken within this edge */
	unsigned int mmb_sz;	/**< length of the members list (without including the 
														 edge itsself */
	mpq_t weight;			/**< Weight for the edge */
}
mpq_EGsrkEdge_t;

/* ========================================================================= */
/** @brief Node structure for shrinkable graphs */
typedef struct mpq_EGsrkNode_t
{
	EGeUgraphNode_t node;	/**< actual node structure for the graph */
	EGeList_t members;		/**< list of other nodes shrunken with this node */
	unsigned int mmb_sz;	/**< length of the members list (without including the
														 node itself */
	EGes_t parent;				/**< If this node is the representant for its class, 
														 then this is a 'parent' node, otherwise, is a 
														 shrunken node */
	mpq_t weight;			/**< Weight of the @f$\delta(n)@f$ edges for this node
														 (in the shrunken graph), this should be 
														 initialized by the user. */
	mpq_EGsrkEdge_t *hit;			/**< used for internal purposes, in particular, while 
														 merging two adjacency lists, this field is used 
														 to store the first edge touching this node, and 
														 then used to retrieve that information. When we 
														 call #mpq_EGsrkIdentifyNodes this field is assumed 
														 to be NULL */
}
mpq_EGsrkNode_t;

/* ========================================================================= */
/** @brief Graph structure for shrinkable graphs */
typedef struct mpq_EGsrkGraph_t
{
	EGeUgraph_t G;					/**< Actual graph structure. */
	unsigned n_onodes;			/**< Number of original nodes */
	unsigned n_oedges;			/**< Number of original edges */
}
mpq_EGsrkGraph_t;

/* ========================================================================= */
/** @brief Initialize an edge structure.
 * @param e_edge */
#define mpq_EGsrkEdgeInit(e_edge) ({\
	mpq_EGsrkEdge_t*const _EGsrkE = (e_edge);\
	EGeUgraphEdgeInit(&(_EGsrkE->edge));\
	EGeListInit(&(_EGsrkE->members));\
	_EGsrkE->mmb_sz = 0;\
	mpq_EGlpNumInitVar(_EGsrkE->weight);\
	mpq_EGlpNumZero(_EGsrkE->weight);})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of an edge
 * structure.
 * @param e_edge */
#define mpq_EGsrkEdgeClear(e_edge) ({\
	EGeUgraphEdgeClear(&((e_edge)->edge));\
	mpq_EGlpNumClearVar((e_edge)->weight);})

/* ========================================================================= */
/** @brief Initialize a graph structure 
 * @param graph graph to be initialized */
#define mpq_EGsrkGraphInit(graph) ({\
	mpq_EGsrkGraph_t*const _EGsrkG = (graph);\
	EGeUgraphInit(&(_EGsrkG->G));\
	_EGsrkG->n_onodes = _EGsrkG->n_oedges = 0;})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a graph
 * structure.
 * @param graph */
#define mpq_EGsrkGraphClear(graph) EGeUgraphClear(&((graph)->G))

/* ========================================================================= */
/** @brief Initialize a node structure.
 * @param e_node node to be initialized */
#define mpq_EGsrkNodeInit(e_node) ({\
	mpq_EGsrkNode_t*const _EGsrkN = (e_node);\
	EGeUgraphNodeInit(&(_EGsrkN->node));\
	EGeListInit(&(_EGsrkN->members));\
	_EGsrkN->mmb_sz = 0;\
	_EGsrkN->hit = 0;\
	EGesInit(&(_EGsrkN->parent));\
	mpq_EGlpNumInitVar(_EGsrkN->weight);\
	mpq_EGlpNumZero(_EGsrkN->weight);})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a node
 * structure.
 * @param e_node */
#define mpq_EGsrkNodeClear(e_node) ({\
	EGeUgraphNodeClear(&((e_node)->node));\
	mpq_EGlpNumClearVar((e_node)->weight);})

/* ========================================================================= */
/** @brief Add a #mpq_EGsrkNode_t node to a #mpq_EGsrkGraph_t graph.
 * @param graph graph were to add the node.
 * @param N node to add to the graph.
 * @return zero on success, non-zero otherwise.
 * */
#define mpq_EGsrkAddNode(graph,N) EGeUgraphAddNode(&((graph)->G),&((N)->node))

/* ========================================================================= */
/** @brief Add a #mpq_EGsrkEdge_t edge to a #mpq_EGsrkGraph_t graph.
 * @param lG graph were to add the edge.
 * @param head_pt head node of the edge.
 * @param tail_pt tail node of the edge.
 * @param E edge to be added with end-points head_pt and tail_pt.
 * Note that this function will update the accumulated weight of both
 * endpoints of the newly added edge according to the value stored in the
 * #mpq_EGsrkEdge_t::weight field.
 * */
#define mpq_EGsrkAddEdge(lG,head_pt,tail_pt,E) ({\
	mpq_EGsrkNode_t*const _EGsrkH = (head_pt);\
	mpq_EGsrkNode_t*const _EGsrkT = (tail_pt);\
	mpq_EGsrkEdge_t*const _EGsrkE = (E);\
	mpq_EGlpNumAddTo(_EGsrkH->weight,_EGsrkE->weight);\
	mpq_EGlpNumAddTo(_EGsrkT->weight,_EGsrkE->weight);\
	EGeUgraphAddEdge(&((lG)->G),&(_EGsrkH->node),&(_EGsrkT->node),&(_EGsrkE->edge));})

/* ========================================================================= */
/** @brief Given two nodes in the current shrunken graph, shrunk them into one 
 * node.
 * @param G pointer to the graph where we are working
 * @param base first node.
 * @param srkN second node.
 * @return pointer to the new representing node.
 * @note We assume that the field mpq_EGsrkNode_t::hit is identically NULL for all
 * nodes currently in the shrunken graph (including base and srkN). 
 * @note We allways assume that N1 will be the representing node.
 * @note Take note that this structure can't get back the pointer to the srkN
 * node, the user should take care of that if needed.
 * */
mpq_EGsrkNode_t *mpq_EGsrkIdentifyNodes (mpq_EGsrkGraph_t * const G,
																 mpq_EGsrkNode_t * const base,
																 mpq_EGsrkNode_t * const srkN);

/* ========================================================================= */
/** @} 
 * end of mpq_eg_shrink_graph.h */
#endif
#endif
#endif
#ifdef HAVE_LIBGMP
#if HAVE_LIBGMP
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgPushRelabel EGalgPushRelabel
 *
 * Here we implement the push-relabel algorithm as defined in the book "Network 
 * Flows" by Magnanti et. all, in chapter 6,7 and 8. Using the variant
 * "Highest-label preflow-push algorithm" (described on page 230) wich choose
 * the active node from wich to push from as the one with highest distance
 * label. This variant has running time @f$ \mathcal{O}(n^2\sqrt{m}) @f$ where
 * @a n is the number of nodes in the graph, and @a m the number of edges in it.
 * Note that the call to #mpq_EGalgPRminSTcut produces a maximum @b pre_flow, to 
 * obtain a flow you should call the #mpq_EGalgPRmaxSTflow that takes the graph 
 * produced by #mpq_EGalgPRminSTcut and convert the preflow into a real flow. We
 * also choose to use to register the number of nodes with distance labels
 * @f$k,\quad\forall k=1,\ldots,n@f$ where @a n is the number of nodes in the
 * network. This is done because whenever the number of nodes with distance
 * labels @a k is zero, then all nodes with distance labels above @a k can be
 * set to @a n (and thus be added to the partially computed cut-set). This is an
 * (inportant) empirical speed-up, but does not affect the worst case complexity
 * analysis.
 * @version 1.0.0
 * @par History:
 * - 2010-05-07
 * 						- Add implementation using eg_adgraph.h
 * - 2005-06-01
 * 						- Add globla relabeling heuristic.
 * - 2005-05-30
 * 						- Final test results on the TSP x-files, all should be right now.
 * - 2005-05-26
 * 						- First Implementation.
 * @note This algorithm is implemented the embedded structures approach. I will
 * give further details on what this implies.
 *
 * @note It is important to note that this algorithm (as implemented here) 
 * @b WILL @b FAIL if an edge has infinite capacities. To handle that case
 * either we must re-program it, or you can put capacities suficiently large on
 * them (for example 2 times the sum of all bounded capacities) for this
 * algorithm to work.
 *
 * @note This implementation does use global relabeling, namelly, the
 * strategy when once in a while (for example every @a n or @a m relabeling
 * operations) we recompute
 * the exact distance labels. The use of this heuristic (together with the gap
 * heuristic) have been reported to be the most successfull in practice (see "On
 * Implementing Push-Relabel Method For The Maximum FLow Problem" from Boris V.
 * Cherkassy and Andrew V. Goldberg.) and also in the test that we have
 * performed on the fractional solutions of TSP's instances from the TSPLIB set
 * of problems using CONCORDE.
 * */
/** @file 
 * @ingroup EGalgPushRelabel */
/** @addtogroup EGalgPushRelabel */
/** @{ */
/** @example mpq_eg_push_relabel.ex.c
 * This is a complete example for the min-cut max-flow problem using the
 * push/relabel implementation offered in EGalgPR. */
#ifndef mpq___EG_PUSH_RELABEL_H__
#define mpq___EG_PUSH_RELABEL_H__
/* ========================================================================= */

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define mpq___PR_DEBUGL__ 100

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define mpq___PR_TEST_VERBOSE__ 100

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define mpq___PR_VERBOSE__ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define mpq___PR_PROFILE__ 100

/* ========================================================================= */
/** @brief If profiling is enable (i.e. #mpq___PR_PROFILE__ <= DEBUG), print 
 * some profiling information of the min s-t cut used up to now, and reset 
 * all internal counters to zero, if profiling is not enabled, nothing 
 * happen. */
/** @{ */
void mpq_EGalgPRprofile(void);
/** @} */
/* ========================================================================= */
/** @brief If set to non-zero, use the global relabeling heuristic (to be called
 * every @a n number of relabel operations performed. if set to zero, it won't
 * use this heuristic. Note thought that it has been shown that this is a very
 * efficient heuristic to reduce the total running time, specially in the
 * #mpq_EGalgPRminSTcut function call. */
#define mpq_EG_PR_RELABEL 1

/* ========================================================================= */
/** @brief If #mpq_EG_PR_RELABEL is set to one, then this initeger controls how
 * often we perform the global relabeling heuristic (in multiples of number of
 * nodes), the default value is 1. */
#define mpq_EG_PR_RELABEL_FREC 1U

/* ========================================================================= */
/** @brief Node structure neede to run Push-Relabel algorithm on a network.
 * @note Notice that the directed graph part is embeded in this structure as
 * well. Note  that we could define internally space for  LVL_list, 
 * but for the sake of speed we include them in the node structure. */
typedef struct mpq_EGalgPRnode_t
{
	EGeDgraphNode_t v;		/**< Actual node structure to work with (EGeDgraph) */
	EGeList_t LVL_list;		/**< Used to store the BFS list used for the first 
														 computations of the exact label distances, and 
														 then to store this node in it's current level list 
														 (this is used to implement the Highest-Label 
														 variant of the Preflow-Push algorithm) */
	EGeList_t T_cut;			/**< Used to speed-up the 'hole' heuristic, it is seted
														 once we enter the algorithm, so their value is 
														 non-important outside the function (but it's 
														 contents will be lost once we enter 
														 #mpq_EGalgPRminSTcut). */
	unsigned int d;				/**< Exact label distance for this node. Note that 
														 nodes with distance lables @f$ \geq n @f$ (where 
														 @a n is the number of nodes in the graph) define 
														 the minimum @f$ s-t@f$ cut that we are looking 
														 for. */
	mpq_t e;					/**< Exess flow in the node. Note that in particular 
														 the excess on node @a t (once #mpq_EGalgPRminSTcut 
														 finish) correspond to the minimum cut value. */
}
mpq_EGalgPRnode_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an mpq_EGalgPRnode_t structure */
#define mpq_EGalgPRnodeInit(node_pt) ({\
	mpq_EGalgPRnode_t*const __EGalgPR_in = (node_pt);\
	mpq_EGlpNumInitVar(__EGalgPR_in->e);\
	EGeDgraphNodeInit(&(__EGalgPR_in->v));})

/* ========================================================================= */
/** @brief Reset the given node pointer (as if it were new).
 * @param node_pt pointer to the node to reset.
 * 
 * This function set the node as an empty node not linked with any graph.
 * */
#define mpq_EGalgPRnodeReset(node_pt) EGeDgraphNodeReset(&((node_pt)->v))

/* ========================================================================= */
/** @brief clear a pointer to an mpq_EGalgPRnode_t structure, and let it ready to be
 * freed if necesary. */
#define mpq_EGalgPRnodeClear(node_pt) ({\
	mpq_EGlpNumClearVar((node_pt)->e);\
	EGeDgraphNodeClear(&((node_pt)->v));})

/* ========================================================================= */
/** @brief capacitated edge structure with forward/backward information. */
typedef struct mpq_EGalgPRse_t
{
	EGeDgraphEdge_t e;	/**< actual edge information. */
	mpq_t r;				/**< residual capacity of the edge. */
	mpq_t u;				/**< maximum capacity on the edge. */
	unsigned char type;	/**< type of edge (0 for forward and 1 for backward */
}
mpq_EGalgPRse_t;

/* ========================================================================= */
/** @brief Edge Structure needed to run Push-Relabel algorithm on a network.
 * @note Notice that the this edge actually has actually two capacited edge
  substructures, one for forward edges and one for backward edge, it is assumed
 * that fw.type == 0 and bw.type == 1. This is needed because the algorithm 
 * asumes that both
 * edges exists (althought one may have zero capacity). Moreover, while
 * computing the residual capacities we need to access both edges e_ij and e_ji
 * at the same time, thus our choice to represent both edges in just one
 * structure. We also assume that the lower bound on the flow of all edges is
 * zero. Note that we don't need to keep explicitly the flow on the edges,
 * because given the residual capacity and the capacity on the edge we have that
 * @f$ x_{ij} - x_{ji} = u_{ij} - r_{ij} @f$ and thus we can set @f$ x_{ij} =
 * (u_{ij}-r_{ij})_+ @f$ and @f$ x_{ji} = (r_{ij}-u_{ij})_+ @f$.
 * if we have computed the maximal flow. */
typedef struct mpq_EGalgPRedge_t
{
	mpq_EGalgPRse_t fw;		/**< forward edge, we assum that fw.type = 0 */
	mpq_EGalgPRse_t bw;		/**< backward edge, we assume that bw.type = 1 */
}
mpq_EGalgPRedge_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an mpq_EGalgPRedge_t structure */
#define mpq_EGalgPRedgeInit(edge_pt) ({\
	mpq_EGalgPRedge_t*const __EGalgPR_ie = (edge_pt);\
	mpq_EGlpNumInitVar(__EGalgPR_ie->fw.r);\
	mpq_EGlpNumInitVar(__EGalgPR_ie->fw.u);\
	mpq_EGlpNumInitVar(__EGalgPR_ie->bw.r);\
	mpq_EGlpNumInitVar(__EGalgPR_ie->bw.u);\
	EGeDgraphEdgeInit(&(__EGalgPR_ie->fw.e));\
	EGeDgraphEdgeInit(&(__EGalgPR_ie->bw.e));\
	__EGalgPR_ie->bw.type = 1;\
	__EGalgPR_ie->fw.type = 0;})

/* ========================================================================= */
/** @brief Reset the given edge pointer (as if it were new).
 * @param edge_pt pointer to the node to reset.
 * 
 * This function set the edge as an empty edge not linked with any graph.
 * */
#define mpq_EGalgPRedgeReset(edge_pt) ({\
	mpq_EGalgPRedge_t*const __EGalgPR_ie = (edge_pt);\
	EGeDgraphEdgeReset(&(__EGalgPR_ie->fw.e));\
	EGeDgraphEdgeReset(&(__EGalgPR_ie->bw.e));\
	__EGalgPR_ie->bw.type = 1;\
	__EGalgPR_ie->fw.type = 0;})


/* ========================================================================= */
/** @brief clear a pointer to an mpq_EGalgPRedge_t structure, and let it ready to be
 * freed if necesary. */
#define mpq_EGalgPRedgeClear(edge_pt) ({\
	mpq_EGlpNumClearVar((edge_pt)->fw.r);\
	mpq_EGlpNumClearVar((edge_pt)->fw.u);\
	mpq_EGlpNumClearVar((edge_pt)->bw.r);\
	mpq_EGlpNumClearVar((edge_pt)->bw.u);\
	EGeDgraphEdgeClear(&((edge_pt)->fw.e));\
	EGeDgraphEdgeClear(&((edge_pt)->bw.e));})

/* ========================================================================= */
/** @brief Graph structure needed to run Push-Relabel algorithm (with highest
 * label node selection rule). */
typedef struct mpq_EGalgPRgraph_t
{
	EGeDgraph_t G;				/**< EGeDgraph structure holding the graph 
														 information. */
}
mpq_EGalgPRgraph_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an mpq_EGalgPRgraph_t structure */
#define mpq_EGalgPRgraphInit(graph_pt) EGeDgraphInit(&((graph_pt)->G))

/* ========================================================================= */
/** @brief Reset the given graph pointer (as if it were new).
 * @param graph_pt pointer to the node to reset.
 * 
 * This function set the graph as an empty graph.
 * */
#define mpq_EGalgPRgraphReset(graph_pt) EGeDgraphReset(&((graph_pt)->G))

/* ========================================================================= */
/** @brief clear a pointer to an mpq_EGalgPRgraph_t structure, and let it ready 
 * to be freed if necesary. */
#define mpq_EGalgPRgraphClear(graph_pt) EGeDgraphClear(&((graph_pt)->G))

/* ========================================================================= */
/** @brief Compute a minimum @f$s-t@f$ cut.
 * @param s pointer to the mpq_source node.
 * @param t pointer to the mpq_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the mpq_EGalgPRgraph_t* in wich we will work.
 * @return zero on success, non-zero otherwise.
 * @par Description:
 * When this funcion finish (successfully) all nodes with field
 * #mpq_EGalgPRnode_t::d bigger than or equal to @a n (the number of nodes in the
 * graph) bellong to the @a s cut, while nodes with value strictly less than @a
 * n will bellong to the @a t cut. The residual capacities imply a maximum
 * pre-flow in the network, to get an acutal maximum flow you should run 
 * #mpq_EGalgPRmaxSTflow function with imput the output graph of this function 
 * (for an example look at the file mpq_eg_push_relabel.ex.c ).
 * @note This implementation uses the @a gap and @a global @a relabeling
 * heuristics to speed-up the computations.
 * */
int mpq_EGalgPRminSTcut (mpq_EGalgPRgraph_t * const G,
										 mpq_EGalgPRnode_t * const s,
										 mpq_EGalgPRnode_t * const t);

/* ========================================================================= */
/** @brief Compute a maximum @f$s-t@f$ flow from the ouput produced by
 * EGalgPRminCur.
 * @param s pointer to the mpq_EGalgPRnode_t* mpq_source node in the network.
 * @param t pointer to the mpq_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the mpq_EGalgPRgraph_t* in wich we will work.
 * @return zero on success, non-zero otherwise.
 * @par Description:
 * We assume that our input graph is the (unaltered) result of a 
 * call to #mpq_EGalgPRminSTcut. Also, note that while computing the actual 
 * max @a s-@a t flow, we don't need to look for @a gap in the array of 
 * distances.
 * Also note that once you call this function, the information in
 * #mpq_EGalgPRnode_t::d don't correspond any more to the cut as defined in
 * #mpq_EGalgPRminSTcut.
 * */
int mpq_EGalgPRmaxSTflow (mpq_EGalgPRgraph_t * const G,
											mpq_EGalgPRnode_t * const s,
											mpq_EGalgPRnode_t * const t);

/* ========================================================================= */
/** @brief Check if the given input graph (with it's residual capacities)
 * represent an optimal solution to the maximum @f$ s-t @f$ flow / minimum
 * capacity @f$ s-t @f$ cut.
 * @param s pointer to the mpq_EGalgPRnode_t* mpq_source node in the network.
 * @param t pointer to the mpq_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the mpq_EGalgPRgraph_t* in wich we will work.
 * @param error worst error while checking for optimality conditions.
 * @return zero if all discrepancies are under the #mpq_epsLpNum threshold, 
 * otherwise, return the number of conditions that don't hold within that
 * threshold, and report in error the worst error found in any condition.
 * @note The input for this function should be the graph as returned by
 * #mpq_EGalgPRmaxSTflow .
 * */
int mpq_EGalgPRoptimalityTest (mpq_EGalgPRgraph_t * const G,
													 mpq_EGalgPRnode_t * const s,
													 mpq_EGalgPRnode_t * const t,
													 mpq_t * error);

/* ========================================================================= */
/* @} */
/* end of mpq_eg_push_relabel.h */
#endif
#endif
#endif
#ifdef HAVE_LIBGMP
#if HAVE_LIBGMP
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgMinCut EGalgMinCut
 *
 * Here we implement the min-cut algorithm based on the srinking
 * pre-processing of Padberg And Rinaldi in the paper "An Efficient 
 * Algorithm For The Minimum Capacity Cut Problem", Mathematical Programming
 * 47 (1990) pages 19-36. But using as minimum s-t cut code the Push-Relabel
 * max flow algorithm as implemented in the @ref EGalgPushRelabel module. This 
 * implies that we only support positive edge-weights.
 *
 * This implementation allows uses of diferent numbers as supported by
 * @ref EGlpNum module. And follows the philosophy of embeded structures as in
 * @ref EGalgPushRelabel module. Also, much of the approach used in this 
 * implementation come from CONCORDE's implementation.
 *
 * It is usually the case that the Minimum Cut Problem is just a sub-problem
 * of some larger problem, is for that reason that we implement (just as in
 * CONCORDE) a callback function that is called whenever an improving solution
 * is found, so that the user can do something with the given node-cutset and
 * value. for more details see the definition of #mpq_EGalgMCcbk_t .
 *
 * @note 
 * If run with types like EGfp20_t, if the arithmetic produces an overflow,
 * then we are in big trouble, note that the numbers involved in the algorithm
 * may range up to \f$\sum(w_e:e\in E(G))\f$.
 *
 * @version 0.0.1
 * @par History:
 * - 2005-08-19
 * 						- While computing a minimum S-T cut, choose S randomly. and T
 * 							as a node at maximum distance (number of edges) from S.
 * 						- Fix small problem with shrinking level 4
 * - 2005-06-20
 * 						- First Implementation.
 * */
/** @file
 * @ingroup EGalgMinCut */
/** @addtogroup EGalgMinCut */
/** @{ */
/** @example mpq_eg_min_cut.ex.c */
/* ========================================================================= */
#ifndef mpq__EG_MIN_CUT_H
#define mpq__EG_MIN_CUT_H
/* ========================================================================= */
/** @brief Verbosity Level */
#define mpq___MC_VRBLVL_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define mpq___MC_DEBUG_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define mpq___MC_PROFILE_ 0

/* ========================================================================= */
/** If profiling is enable (i.e. #mpq___MC_PROFILE_ <= DEBUG), print 
 * some profiling information of the min cut used up to now, and reset 
 * all internal counters to zero, if profiling is not enabled, nothing 
 * happen. */
/** @{ */
void mpq_EGalgMCprofile(void);
/** @} */

/* ========================================================================= */
/** @brief Call-back function, it receives as input the weight of the cut, the
 * size of the newly found cut, an array containing the cut (of length at
 * least the number of elements in the cut) as integers (as defined by the 
 * #mpq_EGalgMCnode_t::id field), and a pointer to some internal
 * data (as stored in #mpq_EGalgMCcbk_t::param). The function should return zero
 * on success, and non-zero if an error ocours, this error will be propagated
 * through the calling functions. */
typedef int (*mpq_EGalgMCdo_f) (mpq_t,
														const unsigned int,
														const unsigned int *const,
														void *);

/* ========================================================================= */
/** @brief Call-back structure for use when an improving minimum cut is found.
 * */
typedef struct mpq_EGalgMCcbk_t
{
	mpq_t cutoff;	/**< maximum value for the newly found minimum cut, for 
												 the function to be called. */
	void *param;			/**< external parameter needed by the function */
	mpq_EGalgMCdo_f do_fn;/**< actual function to be called if the cut-off condition 
												 holds */
}
mpq_EGalgMCcbk_t;

/* ========================================================================= */
/** @brief Initialize a call-back structure.
 * @param cb call-back to be initialized. */
#define mpq_EGalgMCcbkInit(cb) ({\
	mpq_EGalgMCcbk_t*const _EGalgMCcb = (cb);\
	mpq_EGlpNumInitVar(_EGalgMCcb->cutoff);\
	_EGalgMCcb->param = 0;\
	_EGalgMCcb->do_fn = 0;})

/* ========================================================================= */
/** @brief Free all internal memory asociated with this structure (not
 * allocated by the user).
 * @param cb call-back strucure to be cleared */
#define mpq_EGalgMCcbkClear(cb) mpq_EGlpNumClearVar((cb)->cutoff)

/* ========================================================================= */
/** @brief Node structure for Minimum Cut */
typedef struct mpq_EGalgMCnode_t
{
	mpq_EGsrkNode_t node;		/**< Actual shrinkable node */
	unsigned int id;		/**< External Identifier for the node */
	EGeList_t lvl_cn;		/**< Connector for the level list */
	unsigned int mpq_lvl;		/**< Current node level test to be performed */
	unsigned int new_id;/**< internal data, it's values can be discarded */
	mpq_EGsrkEdge_t *hit;		/**< Used to speed-up the Padberg-Rinaldi tests. */
}
mpq_EGalgMCnode_t;

/* ========================================================================= */
/** @brief Initialize a node structure for use.
 * @param N node to be initialized */
#define mpq_EGalgMCnodeInit(N) ({\
	mpq_EGalgMCnode_t*const _EGalgMCn = (N);\
	mpq_EGsrkNodeInit(&(_EGalgMCn->node));\
	_EGalgMCn->lvl_cn = (EGeList_t){0,0};\
	_EGalgMCn->mpq_lvl = 0;\
	_EGalgMCn->id = UINT_MAX;\
	_EGalgMCn->new_id = UINT_MAX;\
	_EGalgMCn->hit = 0;})

/* ========================================================================= */
/** @brief Clear any internal memory (not allocated by the user) used by this
 * structure.
 * @param N node to be cleared */
#define mpq_EGalgMCnodeClear(N) mpq_EGsrkNodeClear(&((N)->node))

/* ========================================================================= */
/** @brief Edge structure for the Minimum Cut */
typedef struct mpq_EGalgMCedge_t
{
	mpq_EGsrkEdge_t edge;	/**< Actual shrinkable edge */
	unsigned int id;	/**< External Identifier for the edge */
}
mpq_EGalgMCedge_t;

/* ========================================================================= */
/** @brief Initialize an edge structure for use.
 * @param E edge to be initialized */
#define mpq_EGalgMCedgeInit(E) ({\
	mpq_EGalgMCedge_t*const _EGalgMCe = (E);\
	mpq_EGsrkEdgeInit(&(_EGalgMCe->edge));\
	_EGalgMCe->id = UINT_MAX;})

/* ========================================================================= */
/** @brief Clear any internal memory (not allocated by the user) used by this
 * structure.
 * @param E node to be cleared */
#define mpq_EGalgMCedgeClear(E) mpq_EGsrkEdgeClear(&((E)->edge))

/* ========================================================================= */
/** @brief Graph Structure for Minimum Cut.
 *
 * Note that this structure also holds some parameters as the epsilon to use
  in the comparisons, the current best cut found (or bound), and the current
 * cut found so-far. As well as an array containing all edges and nodes in
 * thee graph (remember that when we Identify two nodes, we loose any
 * reference to the shrinked node in the graph structure as discussed in
 * #mpq_EGsrkIdentifyNodes ) 
 * */
typedef struct mpq_EGalgMCgraph_t
{
	mpq_EGsrkGraph_t G;						/**< Actual shrinking graph used */
	mpq_t epsilon;				/**< error tolerance used for equality testing */
	mpq_t cut_val;				/**< if #mpq_EGalgMCgraph_t::cut_sz is not zero, then 
																 this is the value of the (currenlty) best 
																 minimum cut found so far. otherwise is a bound 
																 on the value of the minimum cut (note that this
																 value should be set before actually computing 
																 the minimum cut, and can be set to the value 
																 of @f$\delta(v)@f$ for some node @a v in the 
																 graph. */
	unsigned int cut_sz;			/**< number of nodes in the current best cut, if 
																 set to zero, then no cut has been found 
																 (so far) */
	EGeList_t lvl_list[5];		/**< List of nodes in different levels of tests */
	unsigned int *cut;				/**< Array  storing the current cut, the size of 
																 this array should be at least 
																 #mpq_EGsrkGraph_t::n_onodes */
	mpq_EGalgMCnode_t *all_nodes;	/**< Array containing all nodes of the graph. */
	mpq_EGalgMCedge_t *all_edges;	/**< Array containing all edges of the graph. */
}
mpq_EGalgMCgraph_t;

/* ========================================================================= */
/** @brief Initialize a graph structure for use.
 * @param Graph graph to be initialized */
#define mpq_EGalgMCgraphInit(Graph) ({\
	mpq_EGalgMCgraph_t*const _EGalgMCg = (Graph);\
	mpq_EGsrkGraphInit(&(_EGalgMCg->G));\
	mpq_EGlpNumInitVar(_EGalgMCg->epsilon);\
	mpq_EGlpNumZero(_EGalgMCg->epsilon);\
	mpq_EGlpNumInitVar(_EGalgMCg->cut_val);\
	mpq_EGlpNumZero(_EGalgMCg->cut_val);\
	_EGalgMCg->cut_sz = 0;\
	EGeListInit(_EGalgMCg->lvl_list);\
	EGeListInit(_EGalgMCg->lvl_list+1);\
	EGeListInit(_EGalgMCg->lvl_list+2);\
	EGeListInit(_EGalgMCg->lvl_list+3);\
	EGeListInit(_EGalgMCg->lvl_list+4);\
	_EGalgMCg->cut = 0;\
	_EGalgMCg->all_nodes = 0;\
	_EGalgMCg->all_edges = 0;})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a graph
 * structure.
 * @param Graph graph to be cleared. */
#define mpq_EGalgMCgraphClear(Graph) ({\
	mpq_EGsrkGraphClear(&((Graph)->G));\
	mpq_EGlpNumClearVar((Graph)->epsilon);\
	mpq_EGlpNumClearVar((Graph)->cut_val);})

/* ========================================================================= */
/** @brief Shrink two nodes in the graph, and update internal structures.
 * @param Graph current graph.
 * @param N node to keep in graph.
 * @param M node to shrink within N. */
#define mpq_EGalgMCidentifyNodes(Graph,N,M) ({\
	mpq_EGalgMCgraph_t*const _EGalgMCg = (Graph);\
	mpq_EGalgMCnode_t*const _EGalgMCn = (N), *const _EGalgMCm = (M);\
	MESSAGE(mpq___MC_DEBUG_,"Shrinking nodes with weight %lf %lf", \
					mpq_EGlpNumToLf(_EGalgMCn->node.weight), \
					mpq_EGlpNumToLf(_EGalgMCm->node.weight));\
	mpq_EGsrkIdentifyNodes(&(_EGalgMCg->G), &(_EGalgMCn->node), &(_EGalgMCm->node));\
	if(_EGalgMCn->mpq_lvl < 5)\
	{\
		EGeListDel(&(_EGalgMCm->lvl_cn));\
		EGeListMoveAfter(&(_EGalgMCn->lvl_cn), _EGalgMCg->lvl_list);\
	}\
	else EGeListAddAfter(&(_EGalgMCn->lvl_cn), _EGalgMCg->lvl_list);\
	_EGalgMCn->mpq_lvl = 0;})

/* ========================================================================= */
/** @brief Identify all Padberg and Rinaldy edges. i.e. shrink all edges that
 * satisfy the conditions in their paper. we choose to make tests over pair of
 * nodes linked by an edge. 
 * @param max_lvl set a limit on wich tests to perform. for example, if set to
 * 1, only the first and second tests will be carried out.
 * @param G graph over wich we are working. 
 * @param cb call back structure to use (if set to NULL it is not used).
 * @return zero on success, non-zero otherwise. 
 *
 * Note that while doing this identification process, we update the values of
 * #mpq_EGalgMCgraph_t::cut, #mpq_EGalgMCgraph_t::cut_sz and #mpq_EGalgMCgraph_t::cut_val,
 * as well as performing the actual shrinking procedure.
 *
 * The original theorem (for local conditions on shrinking) is the following:
 * Let @f$ Z @f$ be a proper subset of @f$ V @f$ (the set of all nodes in the
 * graph), @f$ |Z|\geq2 @f$, and let 
 * @f[ P(Z) = \bigcup\left\{ N(u)\cap N(v):u\neq v, u,v\in Z \right\} @f]
 * where @f$ N(u) @f$ if the set of neighbours of @f$ u @f$. If there exists
 * @f$ Y\subseteq P(Z) @f$ such that for every nonempty proper subset @f$ W
 * @f$ of @f$ Z @f$ and for every @f$ T\subseteq Y @f$ either:
 * -# @f$ w(\delta(W))/2 \leq w(W:(Y-T)+(Z-W)) @f$ or
 * -# @f$ w(\delta(Z-W))/2 \leq w(Z-W:T+W) @f$.
 * Then there exists a minimum cut @f$(X:V-X)@f$ such that either @f$
 * Z\subseteq X @f$ or @f$ X\subseteq Z @f$.
 *
 * And the original theorem (in fact is the corollary 3.5 in the paper) 
 * regarding global conditions for shrinking is the following:
 * Let @f$ u\neq v\in V @f$, and let @f$ q @f$ be an upper bound on the
 * minimum cut value, and @f$ lb_{uv} @f$ be a lower bound in the value of a
 * minimum @f$ u-v @f$ cut, then if @f$ lb_{uv}\geq q @f$ the set 
 * @f$ \{u,v\} @f$ is shrinkable.
 * 
 * The actual tests that we perform (for every edge) are the following:
 * -# If @f$ w(\delta(u)) < @f$ #mpq_EGalgMCgraph_t::cut_val, update the minimum
 * cut value and set.
 * -# If @f$ w_{uv} \geq \min\{w(\delta(u)),w(\delta(v))\}/2 @f$ then we can 
 * safely shrink edge @f$ uv @f$.
 * -# If we have a triangle @f$ uv,\quad vw,\quad wu  @f$, with 
 * @f$ w_{uv} + w_{vw} \geq w(\delta(v))/2 @f$ and  
 * @f$ w_{uw} + w_{vw} \geq w(\delta(w))/2 @f$ then we can safely shrink edge
 * @f$ wv @f$.
 * -# Compute lower bound on the cut that separates the endpoints of the
 * current edge as :
 * @f[ lb_{uv}=w_{uv}+\sum\limits_{w\in N(u)\cap N(v)}\min\{w_{uw},w_{vw}\} @f]
 * If  @f$ lb_{uv} \geq  @f$ #mpq_EGalgMCgraph_t::cut_val , then we can shrink the edge  @f$ uv @f$.
 * -# Consider the edge @f$ uv @f$ and two common neighbours @f$ x,y @f$. If  
 * @f$ w_{ux} + w_{uy} + w_{uv} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{vx} + w_{vy} + w_{vu} \geq w(\delta(v))/2 @f$ and at least one of 
 * @f$ w_{uv} + w_{uy} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{uv} + w_{vx} \geq w(\delta(v))/2 @f$ and at least one of 
 * @f$ w_{uv} + w_{ux} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{uv} + w_{vy} \geq w(\delta(v))/2 @f$ then we can safely shrink edge
 * @f$ uv @f$.
 *
 * We make thiese tests in order, i.e. first we perform all level 1 tests,
 * then level2, and so on, and whenever two nodes are Identify (shrinked) we
 * set the level of the node to 1 (i.e. in the next test we will test the
 * first condition). This is done using an array of (5) lists, where all nodes
 * are distributed. Originally all nodes should be in the first lists (i.e.
 * all nodes should be tested to improve the current best cut by themselves).
 * */
int mpq_EGalgMCidentifyPRedges (mpq_EGalgMCgraph_t * const G,
														mpq_EGalgMCcbk_t * const cb,
														const unsigned int max_lvl);

/* ========================================================================= */
/** @brief Compute a minimum cut on the given graph. 
 * @param max_lvl set a limit on wich tests to perform during the
 * Padberg-Rinaldy shrinking step. for example, if set to
 * 1, only the first and second tests will be carried out.
 * @param G graph over wich we are working. 
 * @param cb call back structure to use (if set to NULL it is not used).
 * @return zero on success, non-zero otherwise. 
 *
 * This function takes as input a graph, and perform the minimum cut algorithm
 * as described in the paper "An Efficient 
 * Algorithm For The Minimum Capacity Cut Problem", Mathematical Programming
 * 47 (1990) pages 19-36. 
 *
 * Note that the graph should have all fields properly initialized.
 * */
int mpq_EGalgMC (mpq_EGalgMCgraph_t * const G,
						 mpq_EGalgMCcbk_t * const cb,
						 const unsigned int max_lvl);

/* ========================================================================= */
/** @} 
 * end mpq_eg_min_cut.h */
#endif
#endif
#endif
#ifdef HAVE_LIBGMP
#if HAVE_LIBGMP
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef mpq___EG_NUMUTIL_H__
#define mpq___EG_NUMUTIL_H__

/* ========================================================================= */
/** @defgroup EGlpNumUtil General Number Utilities
 * Here we put some utilities common for different number types but thaat we
 * want to implement as templates, like permutation sorting, inner product of
 * vectors, and so-on..
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2007-10-08
 *  					- Separate template file and independet file into eg_nummacros.h
 *  					- Move EGabs, EGswap, EGmin and EGmax to this file
 *  - 2005-10-31
 *  					- First implementation.
 * */
/** @{*/
/** @file
 * @brief This file provide the user interface and function definitions for
 * general number utilities.
 * */
/* ========================================================================= */
/** @brief compute the inner product of two arrays.
 * @param arr1 first array.
 * @param arr2 second array.
 * @param length number of entries to consider in both arrays, from zero to
 * length - 1.
 * @param rop where to store the result.
 * */
#define mpq_EGlpNumInnProd(__rop,__arr1,__arr2,__length) mpq___EGlpNumInnProd((&(__rop)),__arr1,__arr2,__length)
/* ========================================================================= */
/** @brief internal version, this is done to avoid using stdc99 and rely on
 * more basic stdc89 */
void mpq___EGlpNumInnProd(mpq_t*rop,mpq_t*const arr1,mpq_t*const arr2, const size_t length);
/* ========================================================================= */
/** @brief Sort (in increasing order) a sub-set of entries in an array using 
 * quicksort, by permutating the order of the elements in the subset rather 
 * than in the whole original array.
 * @param sz length of the permutation array.
 * @param perm array of indices of elements that we want to sort.
 * @param elem array (of length at least max(perm[k]:k=0,...,sz-1)) containing
 * the elements to be sorted.
 * @note The array of elements is not changed by this function.
 * @note This code is based in concorde's implementation of
 * permutation-quick-sort.
 * */
void mpq_EGutilPermSort (const size_t sz,
										 int *const perm,
										 const mpq_t * const elem);

/* ========================================================================= */
/** @brief Sort (in decreasing order) a sub-set of entries in an array using 
 * quicksort, by permutating the order of the elements in the subset rather 
 * than in the whole original array.
 * @param sz length of the permutation array.
 * @param perm array of indices of elements that we want to sort.
 * @param elem array (of length at least max(perm[k]:k=0,...,sz-1)) containing
 * the elements to be sorted.
 * @note The array of elements is not changed by this function.
 * @note This code is based in concorde's implementation of
 * permutation-quick-sort.
 * */
void mpq_EGutilPermSort2 (const size_t sz,
										 int*const perm,
										 const mpq_t*const elem);

/* ========================================================================= */
/** @}*/
#endif
#endif
#endif
#ifdef HAVE_LIBGMP
#if HAVE_LIBGMP
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgDijkstra EGalgDijkstra
 * Dijkstra implementation with 2-heaps
 * */
/** @file
 * @ingroup EGalgDijkstra */
/** @addtogroup EGalgDijkstra */
/** @{ */
/** @example mpq_eg_dijkstra.ex.c */
/* ========================================================================= */
#ifndef mpq___EG_DIJKSTRA_H
#define mpq___EG_DIJKSTRA_H
/* ========================================================================= */
/** @brief Verbosity Level */
#define mpq_DJK_VRBLVL_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define mpq_DJK_DEBUG_ 100

/* ========================================================================= */
/** @brief implement dijkstra.
 * */
int mpq_EGalgDJK (
		int32_t const nnodes,
		int32_t const nedges,
		int32_t const*const ou_d,
		int32_t const*const ou_beg,
		int32_t const*const ou_e,
		mpq_t const*const weight,
		int32_t const s,
		int32_t const nt,
		int32_t const*const t,
		int32_t*const father,
		mpq_t*const dist
		);

/* ========================================================================= */
/** @brief read from a file in .x format (as in the concorde's .x files), the
 * format is as follows:
 * nnodes nedges
 * tail_1 head_1 weight_1
 * ...    ...    ....
 * tail_nnodes head_nnodes weight_nnodes
 * comments are allowed, if they start with % or #.
 * @param input file containing the data
 * @param n where to store the number of nodes
 * @param m where to store the number of edges
 * @param edges pointer to an array where to store the edges, note that memory
 * will be allocated in (*edges)
 * @param weight pointer to the array where we will store the weights, note
 * that this array will be allocated using mpq_EGlpNumAllocArray, and should be
 * deallocated using mpq_EGlpNumFreeArray.
 * @return zero on success, non-zero otherwise 
 * */
int mpq_EGguReadXgraph(
		EGioFile_t*const input,
		int32_t*const n,
		int32_t*const m,
		int32_t**const edges,
		mpq_t**const weight);
/* ========================================================================= */
/** @} 
 * end mpq_eg_dijkstra.h */
#endif

#endif
#endif
#ifdef HAVE_LIBGMP
#if HAVE_LIBGMP
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef mpf___EG_DMATRIX_H__
#define mpf___EG_DMATRIX_H__

/* ========================================================================= */
/** @defgroup EGdMatrix Dense Matrices
 * Here we define a common interface for dense matrices (i.e. a structure), and
 * some common operations over dense matrices. The definition uses EGlpNum as
 * reference number type, this allow for template initializations.
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2005-10-27
 *  					- First implementation.
 * */
/** @{*/
/** @file
 * @brief This file provide the user interface and function definitions for
 * Dense Matrices.
 * */
/** @example mpf_eg_dmatrix.ex.c */
/* ========================================================================= */
/** @brief structure to hold a dense matrix, we choose a row representation
 * of the matrix, and we allow row and column permutations. All actual values 
 * in the matrix are stored in #mpf_EGdMatrix_t::matval, and the rows in
 * #mpf_EGdMatrix_t::matrow. */
typedef struct mpf_EGdMatrix_t
{
	size_t col_sz;		/**< @brief Number of columns in the matrix. */
	size_t row_sz;		/**< @brief Number of rows in the matrix */
	mpf_t **matrow;
										/**< @brief Array of size #mpf_EGdMatrix_t::row_sz containing 
												 all rows of the matrix */
	mpf_t *matval;/**< @brief Values for all entries */
	int *col_ord;			/**< @brief Array of size at least #mpf_EGdMatrix_t::col_sz 
												 containing the order ammong all columns i.e. it is a 
												 permutation of {0,....,col_sz-1} which is how the 
												 matrix is treated internally */
	int *row_ord;			/**< @brief Array of size at least #mpf_EGdMatrix_t::row_sz 
												 containing the order ammong all rows, i.e. it is a 
												 permutation of {0,...,row_sz-1} which is how the 
												 matrix is treated internally */
}
mpf_EGdMatrix_t;

/* ========================================================================= */
/** @brief Initialize (as a dense matrix of dimension 0x0) an #mpf_EGdMatrix_t
 * structure.
 * @param __dmatrix dense matrix structure pointer.
 * */
#define mpf_EGdMatrixInit(__dmatrix) memset(__dmatrix,0,sizeof(mpf_EGdMatrix_t))

/* ========================================================================= */
/** @brief Clear a dense matrix structure, i.e. free all internally allocated
 * data of the structure. Note that no further use of the structure can be made
 * unless it is re-initialized and set to a suitable size.
 * @param __dmatrix dense matrix structure pointer.
 * */
#define mpf_EGdMatrixClear(__dmatrix) do{\
	mpf_EGdMatrix_t*const __EGdm = (__dmatrix);\
	mpf_EGlpNumFreeArray(__EGdm->matval);\
	EGfree(__EGdm->matrow);\
	int_EGlpNumFreeArray(__EGdm->col_ord);\
	int_EGlpNumFreeArray(__EGdm->row_ord);} while(0)

/* ========================================================================= */
/** @brief Set new dimensions for a dense matrix structure.
 * @param __dmatrix dense matrix structure pointer.
 * @param __nnewrows number of rows in the matrix.
 * @param __nnewcols number of columns in the matrix.
 * @note Take care that the values stored in the matrix are not initialized to
 * any particular number. Also the ordering (for both column and row) is reset
 * to the standard ordering 0,....,n.
 * */
#define mpf_EGdMatrixSetDimension(__dmatrix,__nnewrows,__nnewcols) do{\
	mpf_EGdMatrix_t*const __EGdm = (__dmatrix);\
	register int __EGdmi;\
	__EGdm->col_sz = (__nnewcols);\
	__EGdm->row_sz = (__nnewrows);\
	mpf_EGlpNumReallocArray(&(__EGdm->matval),__EGdm->col_sz * __EGdm->row_sz);\
	EGrealloc(__EGdm->matrow,__EGdm->row_sz * sizeof(mpf_t*));\
	int_EGlpNumReallocArray(&(__EGdm->col_ord),__EGdm->col_sz);\
	int_EGlpNumReallocArray(&(__EGdm->row_ord),__EGdm->row_sz);\
	__EGdmi = (int)(__EGdm->col_sz);\
	while(__EGdmi--) __EGdm->col_ord[__EGdmi] = __EGdmi;\
	__EGdmi = (int)(__EGdm->row_sz);\
	while(__EGdmi--) \
		__EGdm->matrow[__EGdmi] = __EGdm->matval + ((size_t)(__EGdmi) * __EGdm->col_sz);\
	__EGdmi = (int)(__EGdm->row_sz);\
	while(__EGdmi--) __EGdm->row_ord[__EGdmi] = __EGdmi;} while(0)

/* ========================================================================= */
/** @brief Display a given #mpf_EGdMatrix_t structure contents.
 * @param __dmatrix dense matrix structure pointer.
 * @param __nat_order if set to one, display the matrix using the natural 
 * internal order, i.e. we discard the order of columns and rows as defined in
 * #mpf_EGdMatrix_t::col_ord and #mpf_EGdMatrix_t::row_ord. Otherwise, use such orders.
 * @param __ofile pointer to a FILE structure where we want the output to be
 * printed.
 * */
#define mpf_EGdMatrixDisplay(__dmatrix,__nat_order,__ofile) do{\
	mpf_EGdMatrix_t*const __EGdm = (__dmatrix);\
	char* __EGdmstr = 0;\
	size_t __EGdmi, __EGdmj;\
	fprintf(__ofile,"Matrix %p\nDimensions: %zd rows, %zd columns\n", (void*)__EGdm, __EGdm->row_sz, __EGdm->col_sz);\
	if(__nat_order){\
		for(__EGdmi = 0 ; __EGdmi < __EGdm->row_sz ; __EGdmi++){\
			for(__EGdmj = 0 ; __EGdmj < __EGdm->col_sz ; __EGdmj++){\
				__EGdmstr = mpf_EGlpNumGetStr(__EGdm->matrow[__EGdmi][__EGdmj]);\
				fprintf(__ofile,"%10s ", __EGdmstr);\
				EGfree(__EGdmstr);\
			}\
			fprintf(__ofile,"\n");}\
	} else {\
		for(__EGdmi = 0 ; __EGdmi < __EGdm->row_sz ; __EGdmi++){\
			for(__EGdmj = 0 ; __EGdmj < __EGdm->col_sz ; __EGdmj++){\
				__EGdmstr = mpf_EGlpNumGetStr(__EGdm->matrow[__EGdm->row_ord[__EGdmi]][__EGdm->col_ord[__EGdmj]]);\
				fprintf(__ofile,"%10s ", __EGdmstr);\
				EGfree(__EGdmstr);\
			}\
			fprintf(__ofile,"\n");}\
	}} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set rows 
 * '__dest' to '__dest' + '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in row '__dest', and note that rows '__orig' and '__dest' should be different.
 * This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the row whose multiple will be added to the '__dest'
 * row.
 * @param '__dest' row to be replaced by '__dest' + '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' row.
 * @note The index of the row are taken as internal index, i.e. if we give row
 * 'k' we will use the row stored in #mpf_EGdMatrix_t::matrow[k], wich does not
 * mean that we will access the k-th row in the matrix (wich would need to use
 * as index the value #mpf_EGdMatrix_t::row_ord[k] instead). Note that we don't
 * test wether the given multiple is zero or not. we always perform the
 * operation.
 * */
#define mpf_EGdMatrixAddRowMultiple(__dmatrix,__dest,__orig,__num) do{\
	mpf_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (size_t)(__dest);\
	const size_t __EGori = (size_t)(__orig);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) \
		mpf_EGlpNumAddInnProdTo(__EGdm->matrow[__EGdest][__EGdmj],\
												__EGdm->matrow[__EGori][__EGdmj],__num);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set rows 
 * '__dest' to '__dest' - '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in row '__dest', and note that rows '__orig' and '__dest' should be different.
 * This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the row whose multiple will be added to the '__dest'
 * row.
 * @param '__dest' row to be replaced by '__dest' - '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' row.
 * @note The index of the row are taken as internal index, i.e. if we give row
 * 'k' we will use the row stored in #mpf_EGdMatrix_t::matrow[k], wich does not
 * mean that we will access the k-th row in the matrix (wich would need to use
 * as index the value #mpf_EGdMatrix_t::row_ord[k] instead). Note that we don't
 * test wether the given multiple is zero or not. we always perform the
 * operation.
 * */
#define mpf_EGdMatrixSubRowMultiple(__dmatrix,__dest,__orig,__num) do{\
	mpf_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (__dest);\
	const size_t __EGori = (__orig);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) \
		mpf_EGlpNumSubInnProdTo(__EGdm->matrow[__EGdest][__EGdmj],\
												__EGdm->matrow[__EGori][__EGdmj],__num);\
	} while(0)
/* ========================================================================= */
/** @brief Given a number and a row, multiply the complete row by the given
 * number. Note that the number MUST_NOT be stored in the row being multiplied,
 * this is because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param row_ind index of the row being multiplied, note that we will multiply
 * the row stored in #mpf_EGdMatrix_t::matrow[row_ind], wich is different to say
 * that we multiply the row in the row_ind-th position in the row ordering (to
 * do that, then row_ind should be #mpf_EGdMatrix_t::row_ord[k]).
 * @param multiple constant to be multiply to the row.
 * */
#define mpf_EGdMatrixMultiplyRow(__dmatrix,row_ind,multiple) do{\
	mpf_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdmi = (row_ind);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) mpf_EGlpNumMultTo(__EGdm->matrow[__EGdmi][__EGdmj],multiple);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set columns 
 * '__dest' to '__dest' + '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in column '__dest', and note that columns '__orig' and '__dest' should be 
 * different. This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the column whose multiple will be added to the '__dest'
 * column.
 * @param '__dest' column to be replaced by '__dest' + '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' column.
 * @note The index of the column are taken as internal index, i.e. if we give 
 * column 'k' we will use the column stored in #mpf_EGdMatrix_t::matrow[*][k], 
 * wich does not mean that we will access the k-th column in the matrix (wich
 * would need to use as index the value #mpf_EGdMatrix_t::row_ord[k] instead). 
 * Note that we don't test wether the given multiple is zero or not. we 
 * always perform the operation.
 * */
#define mpf_EGdMatrixAddColMultiple(__dmatrix,__dest,__orig,__num) do{\
	mpf_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (__dest);\
	const size_t __EGori = (__orig);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) \
		mpf_EGlpNumAddInnProdTo(__EGdm->matrow[__EGdmj][__EGdest],\
												__EGdm->matrow[__EGdmj][__EGori],__num);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set columns 
 * '__dest' to '__dest' - '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in column '__dest', and note that columns '__orig' and '__dest' should be 
 * different. This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the column whose multiple will be added to the '__dest'
 * column.
 * @param '__dest' column to be replaced by '__dest' - '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' column.
 * @note The index of the column are taken as internal index, i.e. if we give 
 * column 'k' we will use the column stored in #mpf_EGdMatrix_t::matrow[*][k], 
 * wich does not mean that we will access the k-th column in the matrix (wich 
 * would need to use as index the value #mpf_EGdMatrix_t::col_ord[k] instead). 
 * Note that we don't test wether the given multiple is zero or not. we 
 * always perform the operation.
 * */
#define mpf_EGdMatrixSubColMultiple(__dmatrix,__dest,__orig,__num) do{\
	mpf_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (size_t)(__dest);\
	const size_t __EGori = (size_t)(__orig);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) \
		mpf_EGlpNumSubInnProdTo(__EGdm->matrow[__EGdmj][__EGdest],\
												__EGdm->matrow[__EGdmj][__EGori],__num);\
	} while(0)
/* ========================================================================= */
/** @brief Given a number and a column, multiply the complete column by the 
 * given number. Note that the number MUST_NOT be stored in the column being 
 * multiplied, this is because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param __colind index of the column being multiplied, note that we will 
 * multiply the column stored in #mpf_EGdMatrix_t::matrow[*][__colind], wich is 
 * different to say that we multiply the column in the __colind-th position in
 * the column ordering (to do that, then __colind should be 
 * #mpf_EGdMatrix_t::col_ord[k]).
 * @param __mult constant to be multiply to the column.
 * */
#define mpf_EGdMatrixMultiplyCol(__dmatrix,__colind,__mult) do{\
	mpf_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdmi = (__colind);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) mpf_EGlpNumMultTo(__EGdm->matrow[__EGdmj][__EGdmi],__mult);\
	} while(0)


/* ========================================================================= */
/** @brief This function performs gaussian elimination to the given matrix,
 * depending on the given options it may do row/columns permutations allong the
 * way to improve numerical stabillity.
 * @param __dmatrix dense matrix structure pointer.
 * @param do_col_perm if set to one, the try columns permutation to improve
 * numericall stabillity, otherwise, not do column permutations at all.
 * @param do_row_perm if set to one, try row permutations to improve numericall
 * stabillity, otherwise, not do row permutations at all.
 * @param status pointer to where return an status, if the procedure finish all
 * the way (i.e. the matrix is full rank), then we return #EG_ALGSTAT_SUCCESS,
 * if the matrix is found to be partial rank, the status is
 * #EG_ALGSTAT_PARTIAL, otherwise, we return #EG_ALGSTAT_NUMERROR, wich means
 * that we stoped because a zero pivot was found (after checking for allowed
 * row/collumns permmutations).
 * @param rank where to return the (proven) rank of the matrix. This number is
 * accurate if the status is #EG_ALGSTAT_SUCCESS, or #EG_ALGSTAT_PARTIAL, but
 * is just a lower bound if the status is #EG_ALGSTAT_NUMERROR
 * @param zero_tol What is the threshold for a value to be considered zero.
 * @return if no error happen, we return zero, otherwise a non-zero valued is
 * returned. Note that the algorithm status is independent of the return value,
 * non zero values araise only if an error happen during execution, wich is
 * different to say that the algorithm didn't finish correctly. */
int mpf_EGdMatrixGaussianElimination (mpf_EGdMatrix_t * const __dmatrix,
																	const unsigned do_col_perm,
																	const unsigned do_row_perm,
																	unsigned *const rank,
																	const mpf_t zero_tol,
																	int *const status);

/* ========================================================================= */
/** @}*/
#endif
#endif
#endif
#ifdef HAVE_LIBGMP
#if HAVE_LIBGMP
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef mpf___EG_DBASIS_REDUCTION__
#define mpf___EG_DBASIS_REDUCTION__
/* ========================================================================= */
/** @defgroup EGdBasisRed LLL Basis Reduction
 * Here we define a common interface for dense matrices (i.e. a structure), and
 * some common operations over dense matrices. The definition uses EGlpNum as
 * reference number type, this allow for template initializations.
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2005-10-28
 *  					- First implementation.
 * */
/**  @{ */
/** @file
 * @brief This file provide the user interface and function definitions for
 * the so-called LLL Basis Reduction Algorithm. This algorithm was first
 * presented in the paper "Factoring polynomials with rational coefficients",
 * Mathematische Annalen 261 (1981), p515-534. and has been extensivelly
 * studied elsewere. for more details just Google-it.
 * */
/** @example mpf_eg_dmatrix.ex.c */
/* ========================================================================= */
/** @brief verbosity level */
#define mpf_EG_DBSRED_VERBOSE 0

/* ========================================================================= */
/** @name Profiling structures and functions for the basis reduction algorithm.
 * */
/* @{ */
/* ========================================================================= */
/** @brief where to hold the profile information */
extern uintmax_t mpf_EGdBsRedStats[10];

/* ========================================================================= */
/** @brief where we store the number of calls to #mpf_EGdBsRed */
#define mpf_EG_BSRED_CALLS 0

/* ========================================================================= */
/** @brief where we store the total number of size reductions performed in 
 * #mpf_EGdBsRed */
#define mpf_EG_BSRED_SZRED 1

/* ========================================================================= */
/** @brief where we store the total number of interchanges performed in 
 * #mpf_EGdBsRed */
#define mpf_EG_BSRED_INTR 2

/* ========================================================================= */
/** @brief where we store the total number of innermost loops performed in 
 * #mpf_EGdBsRed */
#define mpf_EG_BSRED_ITT 3

/* ========================================================================= */
/** @brief Print into the given file stream, the current statistics related
 * to the #mpf_EGdBsRed algorithm. And reset all counters to zero.
 * @param __ofile where we want to print the profile information. */
#define mpf_EGdBsRedProfile(__ofile) do{\
	fprintf(__ofile,"LLL Basis Reduction Statistics:\n");\
	fprintf(__ofile,"\tNumber Calls    : %ju\n", mpf_EGdBsRedStats[mpf_EG_BSRED_CALLS]);\
	fprintf(__ofile,"\tLoops           : %ju\n", mpf_EGdBsRedStats[mpf_EG_BSRED_ITT]);\
	fprintf(__ofile,"\tSize Reductions : %ju\n", mpf_EGdBsRedStats[mpf_EG_BSRED_SZRED]);\
	fprintf(__ofile,"\tInterchanges    : %ju\n", mpf_EGdBsRedStats[mpf_EG_BSRED_INTR]);\
	memset(mpf_EGdBsRedStats,0,sizeof(mpf_EGdBsRedStats));} while(0)

/* @} */

/* ========================================================================= */
/** @brief Value used in condition two of the LLL algorithm, remember that this
 * number should be between \f$(1/4,1)\f$. By default we choose \f$\lambda =
 * \frac{2^{20}-1}{2^{20}} \approx .99999904632568359375 \f$. */
#define mpf_EG_DBSRED_ALPHA 0x7ffffp-20

/* ========================================================================= */
/** @brief structure to hold all necesary data to perform the LLL's basis
 * reduction algorithm. */
typedef struct mpf_EGdBsRed_t
{
	size_t dim;				/**< @brief Number of elements in the basis */
	size_t length;		/**< @brief Length of the vectors in the basis, note that
												 it should be that length >= dim */
	size_t basis_sz;	/**< @brief Actual length of the #mpf_EGdBsRed_t::basis 
												 array */
	mpf_t **basis;/**< @brief array of pointers to arrays containing the 
												 vector basis in extended (including zero coef) form. 
												 The vectors themselves are considered as allocated 
												 outside. everything else is considered as internally
												 allocated. */
	mpf_EGdMatrix_t GM;		/**< @brief Here we store and compute the Gram-Schmidt 
												 needed for the LLL basis reduction algorithm */
}
mpf_EGdBsRed_t;

/* ========================================================================= */
/** @brief Initialize an #mpf_EGdBsRed_t structure, as a basis with zero elements
 * of dimension zero.
 * @param __bsred pointer to an #mpf_EGdBsRed_t structure.
 * */
#define mpf_EGdBsRedInit(__bsred) do{\
	mpf_EGdBsRed_t*const __EGdbs = (__bsred);\
	memset(__EGdbs,0,sizeof(mpf_EGdBsRed_t));\
	mpf_EGdMatrixInit(&(__EGdbs->GM));} while(0)

/* ========================================================================= */
/** @brief Free any internally allocated memory in a #mpf_EGdBsRed_t structure.
 * @param __bsred pointer to an #mpf_EGdBsRed_t structure.
 * */
#define mpf_EGdBsRedClear(__bsred) do{\
	mpf_EGdBsRed_t*const __EGdbs = (__bsred);\
	if(__EGdbs->basis) EGfree(__EGdbs->basis);\
	mpf_EGdMatrixClear(&(__EGdbs->GM));} while(0)

/* ========================================================================= */
/** @brief reset an #mpf_EGdBsRed_t structure as a basis without elements (note
 * that we do not reset the length of the vectors, just the number of vectors 
 * in the basis).
 * @param __bsred pointer to an #mpf_EGdBsRed_t structure.
 * */
#define mpf_EGdBsRedReset(__bsred) ((__bsred)->dim = 0)

/* ========================================================================= */
/** @brief set the length of the vectors used in the basis for an #mpf_EGdBsRed_t
 * structure.
 * @param __bsred pointer to an #mpf_EGdBsRed_t structure.
 * @param __new_length length of the vectors in the basis.
 * */
#define mpf_EGdBsRedSetLength(__bsred,__new_length) ((__bsred)->length = (__new_length))

/* ========================================================================= */
/** @brief add a new vector to the basis.
 * @param __bsred pointer to an #mpf_EGdBsRed_t structure.
 * @param __new_elem new vector to add to the basis.
 * */
#define mpf_EGdBsRedAddElement(__bsred,__new_elem) do{\
	mpf_EGdBsRed_t*const __EGdbs = (__bsred);\
	if(__EGdbs->basis_sz <= __EGdbs->dim){\
		__EGdbs->basis_sz += 10U;\
		EGrealloc(__EGdbs->basis,sizeof(mpf_t*)*__EGdbs->basis_sz);}\
	__EGdbs->basis[__EGdbs->dim++] = (__new_elem);} while(0)

/* ========================================================================= */
/** @brief This function performs the so-called LLL basis reduction algorithm.
 * @param __bsred pointer to an #mpf_EGdBsRed_t structure.
 * @param status where we return the status of the algorithm, if the algorithm
 * finish with non-zero reduced elements, the status is #EG_ALGSTAT_SUCCESS. if
 * the algorithm finish with some zero reduced vector, the status is
 * #EG_ALGSTAT_PARTIAL. if the algorithm stop because of numerical problems,
 * the status is #EG_ALGSTAT_NUMERROR.
 * @param zero_tol threshold for a number to be considered as zero.
 * @param dim pointer to a number where we return the dimension of the basis
 * that the algorithm could prove before running in any numerical problem. If
 * the algorithm stop with status #EG_ALGSTAT_SUCCESS, then this number should
 * be equal to #mpf_EGdBsRed_t::dim. The vectors that we finish reducing are stored
 * in #mpf_EGdMatrix_t::row_ord[0], ... , #mpf_EGdMatrix_t::row_ord[dim], in the
 * #mpf_EGdBsRed_t::GM matrix.
 * @return zero if the algorithm finish, non-zero if an unforeseen error occure
 * during execution. 
 * @par Details:
 * The implementation that we use introduce (as an heuristic step) the sorting
 * of the original basis vectors in increasing order according to their norms,
 * this simple step reduced the total running time of the algorithm, but does
 * not improve the theoretical running time. A second detail is that we only
 * compute the Gram-Schmidth coefficients only once (at the beggining of the
 * program), and then, we only update the changed entries for both operations
 * \a size \a reduction and \a interchange. The advantage of the approach is
 * that we save most Gram-Schmidth computations and also all the recomputations
 * of the inner products of the elements currently in the basis. Again, this
 * are improvements form the practical point of view, but not in practice. The
 * dissadvantage of this approach is that we do accumulate rounding errors in
 * the Gram-Schmidth coefficients allong the way, but if all original vectors
 * coefficients where integer (and not too big), then the error should not grow
 * too much. Still this may happen if the input basis is ill conditioned.
 * */
int mpf_EGdBsRed (mpf_EGdBsRed_t * const __bsred,
							unsigned *const dim,
							const mpf_t zero_tol,
							int *const status);

/* ========================================================================= */
/**  @} */
#endif
#endif
#endif
#ifdef HAVE_LIBGMP
#if HAVE_LIBGMP
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGeHeap EGeHeap
 *
 * Here we define the basic interface for d-heaps as an embeded structure.
 * In this implementation the heap does not grow on the fly, meaning that it 
 * may fills-up during an add call, to avoid that, the user must call 
 * re-allocate when necesary. the heap start as a heap of size zero. 
 * This implementatioon is a minimum-heap implementatiton. Note also that the
 * internal connector array is shifted one position to the left. This is done 
 * so that the first element is in position 1, this also speed-up the 
 * computation of the parent and childrens of a given position.
 *
 * @version 0.0.1
 * @par History:
 * - 2010-09-05
 * 						- mpf_EGeHeapClear will free any internal memory (even if it was
 * 						asked for by the user).
 * - 2005-07-14
 * 						- Add mpf_EGeHeapEmpty to empty the heap (but keep its maximum
 * 							size)
 * 						- Add mpf_EGeHeapIsFull to test wether a heap is full or not.
 * - 2005-07-07
 * 						- First Implementation
 * @note 
 * This implementatiton is designed as a template using as base the types of
 * @ref EGlpNum
 * */
/** @file 
 * @ingroup EGeHeap */
/** @addtogroup EGeHeap */
/** @{ */
/** @example mpf_eg_eheap.ex.c
 * This is a simple example of the usage of heaps using @ref EGeHeap */
/* ========================================================================= */
#ifndef mpf___EG_EHEAP__
#define mpf___EG_EHEAP__
/* ========================================================================= */
/** @brief Debug level for the heap */
#ifndef mpf_EG_EHEAP_DEBUG
#define mpf_EG_EHEAP_DEBUG 1000
#endif

/* ========================================================================= */
/** @name Test macros, enabled only if debug level is high enough. */
/** @{ */
#if mpf_EG_EHEAP_DEBUG <= DEBUG
#define mpf_EGeHeapCHECK_CN(__hp2,__hcn2) EXIT(__hcn2->pos>=__hp2->sz,"Heap Connector possition %d out of range [0,%d]",__hcn2->pos,__hp2->sz)
#define mpf_EGeHeapCHECK_NF(__hp2) EXIT(__hp2->sz >= __hp2->max_sz,"Heap "#__hp2" Is full, can't add an element")
#else
#define mpf_EGeHeapCHECK_CN(__hp,__hcn) 
#define mpf_EGeHeapCHECK_NF(__hp) 
#endif
/** @} */
/* ========================================================================= */
/** @brief Structure to store the information relevant to an element in the
 * heap. */
typedef struct 
{
	mpf_t val;		/**< Value of this node in the heap */
	unsigned int pos;	/**< Position in the heap array for this node, if set to
												 #mpf_EG_EHEAP_POISON, then the connector is not in any 
												 heap.*/
}
mpf_EGeHeapCn_t;

/* ========================================================================= */
/** @brief Poison position for heap connector not in a heap. */
#define mpf_EG_EHEAP_POISON UINT_MAX

/* ========================================================================= */
/** @brief Initialize a heap conector structure. This function will allocate any
 * interal memory not allocated by the user, it should be called only once, or
 * after a clear function call.
 * @param __hcn conector to initialize.
 * */
#define mpf_EGeHeapCnInit(__hcn) ({mpf_EGlpNumInitVar((__hcn)->val);(__hcn)->pos = mpf_EG_EHEAP_POISON;})

/* ========================================================================= */
/** @brief Reset a heap conector to the same state as after an init call, this
 * function is provided only for completness.
 * @param __hcn conector to reset
 * */
#define mpf_EGeHeapCnReset(__hcn) ((__hcn)->pos = mpf_EG_EHEAP_POISON)

/* ========================================================================= */
/** @brief Free all internal memory used by this structured not allocated by the
 * user. This function should be called after an init call, and only once.
 * @param __hcn conector to clear.
 * */
#define mpf_EGeHeapCnClear(__hcn) mpf_EGlpNumClearVar((__hcn)->val)

/* ========================================================================= */
/** @brief Structure to hold a whole heap structure, this structure is designed
 * so that it can grow on the fly with a low cost */
typedef struct 
{
	mpf_EGeHeapCn_t **cn;
	unsigned int d;
	unsigned int sz;
	unsigned int max_sz;
}
mpf_EGeHeap_t;

/* ========================================================================= */
/** @brief Return one if the heap is full, zero otherwise.
 * @param __hp heat to check */
#define mpf_EGeHeapIsFull(__hp) ({mpf_EGeHeap_t*const __EGehp = (__hp); __EGehp->sz == __EGehp->max_sz;})

/* ========================================================================= */
/** @brief set the number of elements in hte heap to zero.
 * @param __hp heap to empty.
 * */
#define mpf_EGeHeapEmpty(__hp) ((__hp)->sz = 0)

/* ========================================================================= */
/** @brief Initialize a heap as an empty heap (with no space for conectors).
 * @param __hp heap to initialize.
 * */
#define mpf_EGeHeapInit(__hp) (*(__hp) = (mpf_EGeHeap_t){0,0,0,0})

/* ========================================================================= */
/** @brief Reset the given heap as an empty heap (just as returned by the init
 * call.
 * @param __hp heap to reset 
 * */
#define mpf_EGeHepReset(__hp) mpf_EGeHeapResize(__hp,0)

/* ========================================================================= */
/** @brief Clear a heap structure, and free any internal memory (not allocated
 * by the user).
 * @param __hp heap to clear.
 * */
#define mpf_EGeHeapClear(__hp) mpf_EGeHeapResize(__hp,0)

/* ========================================================================= */
/** @brief get the minimum value in the heap.
 * @param __hp heap where we are working.
 * @param number where to store the result
 * @return zero on success, non-zero otherwise.
 * */
#define mpf_EGeHeapGetMinVal(__hp,number) ({\
	mpf_EGeHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? (mpf_EGlpNumCopy(number,__EGehp->cn[0]->val),0):1;})

/* ========================================================================= */
/** @brief get the minimum conector in the heap, if the heap is empty, return
 * NULL.
 * @param __hp eap where we are working.
 * @return pointer to the minimum element in the heap.
 * */
#define mpf_EGeHeapGetMin(__hp) ({\
	mpf_EGeHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? __EGehp->cn[0] : 0;})

/* ========================================================================= */
/** @brief resize the heap cn array to the given size, if the new size is zero,
 * it is equivalent to free the internal memory, and left the heap as an empty
 * heap with zero space.
 * @param __hp heap where we are working.
 * @param new_sz new size for the  cn array .
 * */
#define mpf_EGeHeapResize(__hp,new_sz) ({\
	mpf_EGeHeap_t*const __EGehp = (__hp);\
	const size_t __EGehp_nsz = (size_t)(new_sz);\
	__EGehp->cn = EGrealloc((__EGehp->cn), __EGehp_nsz * sizeof(mpf_EGeHeapCn_t*));\
	__EGehp->max_sz = (unsigned int)(__EGehp_nsz);})

/* ========================================================================= */
/** @brief return the index of the father of the given index.
 * @param __d breadth of the heap.
 * @param __id position in the array to wich we want to compute it's father.
 * */
#define mpf_EGeHeapFatherId(__d,__id) ((__id)?(((__id)-1)/(__d)):0)

/* ========================================================================= */
/** @brief move an element in the heap up in the heap (position 0 is the top,
 * this kind of move is neded whenever we decrease the value in a heap element).
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * */
#define mpf_EGeHeapSiftUp(__hp,__hcn) ({\
	mpf_EGeHeap_t*const __EGehp = (__hp);\
	mpf_EGeHeapCn_t*const __EGecn = (__hcn);\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfpos = mpf_EGeHeapFatherId(__EGehp->d,__EGcpos);\
	mpf_EGeHeapCn_t*__EGfcn = __EGehp->cn[__EGfpos];\
	mpf_EGeHeapCHECK_CN(__EHehp,__EGecn);\
	while(__EGcpos && \
				mpf_EGlpNumIsLess(__EGecn->val,__EGfcn->val))\
	{\
		__EGfcn->pos = __EGcpos;\
		__EGehp->cn[__EGcpos] = __EGfcn;\
		__EGcpos = __EGfpos;\
		__EGfpos = mpf_EGeHeapFatherId(__EGehp->d,__EGcpos);\
		__EGfcn = __EGehp->cn[__EGfpos];\
	}\
	__EGecn->pos = __EGcpos;\
	__EGehp->cn[__EGcpos] = __EGecn;\
	0;})

/* ========================================================================= */
/** @brief Add an element to the heap
 * @param __hp heap where to add the element.
 * @param __hcn element to be added.
 * @return zero on success, non-zero otherwise.
 * */
#define mpf_EGeHeapAdd(__hp,__hcn) ({\
	mpf_EGeHeap_t*const __EGlhp = (__hp);\
	mpf_EGeHeapCn_t*const __EGlcn = (__hcn);\
	mpf_EGeHeapCHECK_NF(__EGlhp);\
	__EGlcn->pos = __EGlhp->sz, \
	__EGlhp->cn[__EGlhp->sz] = __EGlcn;\
	__EGlhp->sz +=1, \
	mpf_EGeHeapSiftUp(__EGlhp,__EGlcn), 0;})

/* ========================================================================= */
/** @brief Give the first child for a given position.
 * @param __id position that we want to get the first child.
 * @param __d breath of the heap. */
#define mpf_EGeHeapFirstChildId(__d,__id) ((__d)*(__id)+1)

/* ========================================================================= */
/** @brief Move an element down in the heap (position 0 is the
 * top), this kind of operation is needed whenever we increase the value in a
 * heap element.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define mpf_EGeHeapSiftDown(__hp,__hcn) ({\
	mpf_EGeHeap_t*const __EGehp = (__hp);\
	mpf_EGeHeapCn_t*const __EGecn = (__hcn);\
	const unsigned int __EGhsz = __EGehp->sz;\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfchd = mpf_EGeHeapFirstChildId(__EGehp->d,__EGcpos);\
	unsigned int __EGlchd = __EGfchd + __EGehp->d;\
	mpf_EGeHeapCn_t*__EGcchd = 0;\
	register unsigned int __EGehi = 0;\
	mpf_EGeHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGfchd < __EGhsz)\
	{\
		/* detect the minimum child */\
		__EGcchd = __EGehp->cn[__EGfchd];\
		for(__EGehi = __EGlchd > __EGhsz ? __EGhsz-1 : __EGlchd-1 ;\
			__EGehi > __EGfchd ; __EGehi--)\
			if(mpf_EGlpNumIsLess(__EGehp->cn[__EGehi]->val,__EGcchd->val))\
				__EGcchd = __EGehp->cn[__EGehi];\
		/* if the minimum child is less than the current position, move the minimum\
		 * child to the position of the current element */\
		if(mpf_EGlpNumIsLess(__EGcchd->val,__EGecn->val))\
		{\
			__EGfchd = __EGcchd->pos;\
			__EGcchd->pos = __EGcpos;\
			__EGehp->cn[__EGcpos] = __EGcchd;\
			__EGecn->pos = __EGcpos = __EGfchd;\
			__EGehp->cn[__EGcpos] = __EGecn;\
			__EGfchd = mpf_EGeHeapFirstChildId(__EGehp->d,__EGcpos);\
			__EGlchd = __EGfchd + __EGehp->d;\
		}\
		/* else we exit the main loop */\
		else __EGfchd = UINT_MAX;\
	}\
	0;})

/* ========================================================================= */
/** @brief Change the value of an element in the heap.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap that we are going to change it's value.
 * @param __new_val new value for the element.
 * @return zero on success, non-zero otherwise.
 * */
#define mpf_EGeHeapChangeVal(__hp,__hcn,__new_val) ({\
	(mpf_EGlpNumIsLess(__new_val,(__hcn)->val)) ? (mpf_EGlpNumCopy((__hcn)->val,__new_val),mpf_EGeHeapSiftUp(__hp,__hcn)) : (mpf_EGlpNumCopy((__hcn)->val,__new_val),mpf_EGeHeapSiftDown(__hp,__hcn));})

/* ========================================================================= */
/** @brief Eliminate an element from the heap, note that the position stored in
 * the eliminated element is reset to zero.
 * @param __hp heap where we are working.
 * @param __hcn element to eliminate from the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define mpf_EGeHeapDel(__hp,__hcn) ({\
	mpf_EGeHeap_t*const __EGlhp = (__hp);\
	mpf_EGeHeapCn_t*const __EGlhpcn = (__hcn);\
	unsigned int const __EGlcn = __EGlhpcn->pos;\
	unsigned int const __EGlhsz = __EGlhp->sz - 1;\
	__EGlhpcn->pos = mpf_EG_EHEAP_POISON;\
	__EGlhp->sz = __EGlhsz;\
	if(__EGlhsz && __EGlhsz != __EGlcn){\
		__EGlhp->cn[__EGlcn] = __EGlhp->cn[__EGlhp->sz];\
		__EGlhp->cn[__EGlcn]->pos = __EGlcn;\
		mpf_EGeHeapSiftDown(__EGlhp,__EGlhp->cn[__EGlcn]);}\
	__EGlhp->cn[__EGlhp->sz] = 0;})

/* ========================================================================= */
/** @brief Check the integrity of the given heap.
 * @param __hp heap to check.
 * @return zero on success, non-zero otherwise.
 * */
#if mpf_EG_EHEAP_DEBUG <= DEBUG
#define mpf_EGeHeapCheck(__hp) ({\
	mpf_EGeHeap_t*const __EGehp = (__hp);\
	register unsigned int __EGehi = __EGehp->sz;\
	if(__EGehi)\
		while(--__EGehi)\
			if(__EGehp->cn[__EGehi]->pos != __EGehi || mpf_EGlpNumIsLess( __EGehp->cn[\
				 __EGehi]->val,__EGehp->cn[mpf_EGeHeapFatherId(__EGehp->d,__EGehi)]->val))\
			{\
				MESSAGE(mpf_EG_EHEAP_DEBUG,"Element %u is wrong, pos %u val [%lf,%lf]"\
							 ,__EGehi, __EGehp->cn[__EGehi]->pos, \
							 mpf_EGlpNumToLf(__EGehp->cn[__EGehi]->val), \
							 mpf_EGlpNumToLf(__EGehp->cn[mpf_EGeHeapFatherId(__EGehp->d,__EGehi)]->val));\
				break;\
			}\
	__EGehi;})
#else
#define mpf_EGeHeapCheck(__hp) 0
#endif

/* ========================================================================= */
/** @brief set the breath of the heap, this function must be called only when
 * the heap is empty.
 * @param __hp heap to set breath.
 * @param __width new with for the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define mpf_EGeHeapChangeD(__hp,__width) ({\
	mpf_EGeHeap_t*const __EGehp = (__hp);\
	EXIT((__width)<2,"Width should be at least 2 for heaps");\
	__EGehp->sz ? 1 : (__EGehp->d = (__width), 0);})

/* ========================================================================= */
/** @} */
/* end of mpf_eg_eheap.h */
#endif
#endif
#endif
#ifdef HAVE_LIBGMP
#if HAVE_LIBGMP
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGeKHeap EGeKHeap
 *
 * Here we define the basic interface for d-heaps with an array of values with
 * the lexicographic order for vectors as an embeded structure.
 * In this implementation the heap does not grow on the fly, meaning that it 
 * may fill-up during an add call, to avoid that, the user must call 
 * re-allocate when necesary. the heap start as a heap of size zero. 
 * This implementatioon is a minimum-heap implementatiton. Note also that the
 * internal connector array is shifted one position to the left. This is done 
 * so that the first element is in position 1, this also speed-up the 
 * computation of the parent and childrens of a given position.
 *
 * @version 0.0.1
 * @par History:
 * - 2010-09-05
 * 						- Change implementation of mpf_EGeKHeapClear to free all internal
 * 						memory, including the one asked for the user during a
 * 						mpf_EGeKHeapResize call.
 * - 2008-07-30
 * 						- First implementation
 * @note 
 * This implementatiton is designed as a template using as base the types of
 * @ref EGlpNum
 * */
/** @file 
 * @ingroup EGeKHeap */
/** @addtogroup EGeKHeap */
/** @{ */
/** @example mpf_eg_ekheap.ex.c
 * This is a simple example of the usage of heaps using @ref EGeKHeap */
/* ========================================================================= */
#ifndef mpf___EG_EKHEAP__
#define mpf___EG_EKHEAP__
/* ========================================================================= */
/** @brief Debug level for the heap */
#ifndef mpf_EG_EKHEAP_DEBUG
#define mpf_EG_EKHEAP_DEBUG 100
#endif

/* ========================================================================= */
/** @name Test macros, enabled only if debug level is high enough. */
/** @{ */
#if mpf_EG_EKHEAP_DEBUG <= DEBUG
#define mpf_EGeKHeapCHECK_CN(__hp2,__hcn2) EXIT(__hcn2->pos>=__hp2->sz,"Heap Connector possition %d out of range [0,%d]",__hcn2->pos,__hp2->sz)
#define mpf_EGeKHeapCHECK_NF(__hp2) EXIT(__hp2->sz >= __hp2->max_sz,"Heap "#__hp2" Is full, can't add an element")
#else
#define mpf_EGeKHeapCHECK_CN(__hp,__hcn) 
#define mpf_EGeKHeapCHECK_NF(__hp) 
#endif
/** @} */
/* ========================================================================= */
/** @brief number of maximum entries in the vector values */
#ifndef mpf_EG_EKHEAP_ENTRY
#define mpf_EG_EKHEAP_ENTRY 3
#endif
/* ========================================================================= */
/** @brief Structure to store the information relevant to an element in the
 * heap. */
typedef struct
{
	mpf_t val[mpf_EG_EKHEAP_ENTRY];/**< Value of this node in the heap */
	unsigned int pos;	/**< Position in the heap array for this node, if set to
												 #mpf_EG_EKHEAP_POISON, then the connector is not in any 
												 heap.*/
}
mpf_EGeKHeapCn_t;

/* ========================================================================= */
/** @brief Poison position for heap connector not in a heap. */
#define mpf_EG_EKHEAP_POISON UINT_MAX

/* ========================================================================= */
/** @brief Initialize a heap conector structure. This function will allocate any
 * interal memory not allocated by the user, it should be called only once, or
 * after a clear function call.
 * @param __hcn conector to initialize.
 * */
#define mpf_EGeKHeapCnInit(__hcn) do{\
	mpf_EGeKHeapCn_t*const __EKHcn = (__hcn);\
	int __EKHi = mpf_EG_EKHEAP_ENTRY;\
	memset(__EKHcn,0,sizeof(mpf_EGeKHeapCn_t));\
	for( ; __EKHi-- ; ){mpf_EGlpNumInitVar(__EKHcn->val[__EKHi]);}\
	__EKHcn->pos = mpf_EG_EKHEAP_POISON;}while(0)

/* ========================================================================= */
/** @brief Reset a heap conector to the same state as after an init call, this
 * function is provided only for completness.
 * @param __hcn conector to reset
 * */
#define mpf_EGeKHeapCnReset(__hcn) ((__hcn)->pos = mpf_EG_EKHEAP_POISON)

/* ========================================================================= */
/** @brief Free all internal memory used by this structured not allocated by the
 * user. This function should be called after an init call, and only once.
 * @param __hcn conector to clear.
 * */
#define mpf_EGeKHeapCnClear(__hcn) do{\
	mpf_EGeKHeapCn_t*const __EKHcn = (__hcn);\
	int __EKHi = mpf_EG_EKHEAP_ENTRY;\
	for( ; __EKHi-- ; ){mpf_EGlpNumClearVar(__EKHcn->val[__EKHi]);}}while(0)

/* ========================================================================= */
/** @brief Structure to hold a whole heap structure, this structure is designed
 * so that it can grow on the fly with a low cost */
typedef struct
{
	mpf_EGeKHeapCn_t **cn;
	unsigned int d;
	unsigned int sz;
	unsigned int max_sz;
}
mpf_EGeKHeap_t;

/* ========================================================================= */
/** @brief Return one if the heap is full, zero otherwise.
 * @param __hp heat to check */
#define mpf_EGeKHeapIsFull(__hp) ({mpf_EGeKHeap_t*const __EGekhp = (__hp); __EGekhp->sz == __EGekhp->max_sz;})

/* ========================================================================= */
/** @brief set the number of elements in hte heap to zero.
 * @param __hp heap to empty.
 * */
#define mpf_EGeKHeapEmpty(__hp) ((__hp)->sz = 0)

/* ========================================================================= */
/** @brief Initialize a heap as an empty heap (with no space for conectors).
 * @param __hp heap to initialize.
 * */
#define mpf_EGeKHeapInit(__hp) (*(__hp) = (mpf_EGeKHeap_t){0,0,0,0})

/* ========================================================================= */
/** @brief Reset the given heap as an empty heap (just as returned by the init
 * call.
 * @param __hp heap to reset 
 * */
#define mpf_EGeKHepReset(__hp) mpf_EGeKHeapResize(__hp,0)

/* ========================================================================= */
/** @brief Clear a heap structure, and free any internal memory (not allocated
 * by the user).
 * @param __hp heap to clear.
 * */
#define mpf_EGeKHeapClear(__hp) mpf_EGeKHeapResize(__hp,0)

/* ========================================================================= */
/** @brief get the minimum value in the heap, note that since we are dealing
 * with a vector of values sorted lexicographically, the value is the value in
 * the first coordinate, other values can be accesses through
 * mpf_EGeKHeapGetMinKVal function.
 * @param __hp heap where we are working.
 * @param __number where to store the result
 * @return zero on success, non-zero otherwise.
 * */
#define mpf_EGeKHeapGetMinVal(__hp,__number) ({\
	mpf_EGeKHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? (mpf_EGlpNumCopy(__number,__EGehp->cn[0]->val[0]),0):1;})

/* ========================================================================= */
/** @brief get the k-th value of the first element in the heap.
 * @param __hp heap where we are working.
 * @param __number where to store the result.
 * @param __k which value to get (between 0 and mpf_EG_EKHEAP_ENTRY.
 * @return zero on success, non-zero otherwise.
 * */
#define mpf_EGeKHeapGetMinKVal(__hp,__k,__number) ({\
	mpf_EGeKHeap_t*const __EGehp = (__hp);\
	const int __EGki = (__k);\
	EXITL(mpf_EG_EKHEAP_DEBUG,(__EGki >= mpf_EG_EKHEAP_ENTRY) || (__EGki <0),\
				"K=%d out of range in mpf_EGeKHeapGetMinKVal", __EGki);\
	__EGehp->sz ? (mpf_EGlpNumCopy(__number,__EGehp->cn[0]->val[__EGki]),0):1;})

/* ========================================================================= */
/** @brief get the minimum conector in the heap, if the heap is empty, return
 * NULL.
 * @param __hp eap where we are working.
 * @return pointer to the minimum element in the heap.
 * */
#define mpf_EGeKHeapGetMin(__hp) ({\
	mpf_EGeKHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? __EGehp->cn[0] : 0;})

/* ========================================================================= */
/** @brief resize the heap cn array to the given size, if the new size is zero,
 * it is equivalent to free the internal memory, and left the heap as an empty
 * heap with zero space.
 * @param __hp heap where we are working.
 * @param __new_sz new size for the  cn array .
 * */
#define mpf_EGeKHeapResize(__hp,__new_sz) ({\
	mpf_EGeKHeap_t*const __EGehp = (__hp);\
	const size_t __EGehp_nsz = (size_t)(__new_sz);\
	__EGehp->cn = EGrealloc((__EGehp->cn), __EGehp_nsz * sizeof(mpf_EGeKHeapCn_t*));\
	__EGehp->max_sz = (unsigned int)(__EGehp_nsz);})

/* ========================================================================= */
/** @brief return the index of the father of the given index.
 * @param __d breadth of the heap.
 * @param __id position in the array to wich we want to compute it's father.
 * */
#define mpf_EGeKHeapFatherId(__d,__id) ((__id)?(((__id)-1)/(__d)):0)

/* ========================================================================= */
/** @brief given two heap connectors, return one if the first is less than the
 * second (in  lexicographic order).
 * @param __hcn1 first vector array.
 * @param __hcn2 second vector array.
 * @return one if __hcn1 <_LEX __hcn2 */
#define mpf_EGeKHeapIsLess(__hcn1,__hcn2) ({\
	mpf_t*const __EGEKH1 = (__hcn1);\
	mpf_t*const __EGEKH2 = (__hcn2);\
	int __EGEKHj = 0, __EGEKHrval = 0;\
	for( ; __EGEKHj < mpf_EG_EKHEAP_ENTRY ; __EGEKHj++)\
	{\
		if(mpf_EGlpNumIsLess(__EGEKH1[__EGEKHj], __EGEKH2[__EGEKHj])){\
			__EGEKHrval = 1; break;}\
		else if (mpf_EGlpNumIsNeq(__EGEKH1[__EGEKHj], __EGEKH2[__EGEKHj],mpf_epsLpNum)){\
			__EGEKHrval = 0; break;}\
	}\
	__EGEKHrval;})

/* ========================================================================= */
/** @brief copy two vector of values (only  mpf_EG_EKHEAP_ENTRY positions) from the
 * rource to the destination.
 * @param src mpf_source array.
 * @param dst destination array.
 * */
void mpf_EGeKHeapCopyVal(mpf_t*const dst, const mpf_t*const src);

/* ========================================================================= */
/** @brief move an element in the heap up in the heap (position 0 is the top,
 * this kind of move is neded whenever we decrease the value in a heap element).
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define mpf_EGeKHeapSiftUp(__hp,__hcn) ({\
	mpf_EGeKHeap_t*const __EGehp = (__hp);\
	mpf_EGeKHeapCn_t*const __EGecn = (__hcn);\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfpos = mpf_EGeKHeapFatherId(__EGehp->d,__EGcpos);\
	mpf_EGeKHeapCn_t*__EGfcn = __EGehp->cn[__EGfpos];\
	mpf_EGeKHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGcpos && \
				mpf_EGeKHeapIsLess(__EGecn->val,__EGfcn->val))\
	{\
		__EGfcn->pos = __EGcpos;\
		__EGehp->cn[__EGcpos] = __EGfcn;\
		__EGcpos = __EGfpos;\
		__EGfpos = mpf_EGeKHeapFatherId(__EGehp->d,__EGcpos);\
		__EGfcn = __EGehp->cn[__EGfpos];\
	}\
	__EGecn->pos = __EGcpos;\
	__EGehp->cn[__EGcpos] = __EGecn;\
	0;})

/* ========================================================================= */
/** @brief Add an element to the heap
 * @param __hp heap where to add the element.
 * @param __hcn element to be added.
 * @return zero on success, non-zero otherwise.
 * */
#define mpf_EGeKHeapAdd(__hp,__hcn) ({\
	mpf_EGeKHeap_t*const __EGlhp = (__hp);\
	mpf_EGeKHeapCn_t*const __EGlcn = (__hcn);\
	mpf_EGeKHeapCHECK_NF(__EGlhp);\
	__EGlcn->pos = __EGlhp->sz, \
	__EGlhp->cn[__EGlhp->sz] = __EGlcn, \
	__EGlhp->sz +=1, \
	mpf_EGeKHeapSiftUp(__EGlhp,__EGlcn), 0;})

/* ========================================================================= */
/** @brief Give the first child for a given position.
 * @param __id position that we want to get the first child.
 * @param __d breath of the heap. */
#define mpf_EGeKHeapFirstChildId(__d,__id) ((__d)*(__id)+1)

/* ========================================================================= */
/** @brief Move an element down in the heap (position 0 is the
 * top), this kind of operation is needed whenever we increase the value in a
 * heap element.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define mpf_EGeKHeapSiftDown(__hp,__hcn) ({\
	mpf_EGeKHeap_t*const __EGehp = (__hp);\
	mpf_EGeKHeapCn_t*const __EGecn = (__hcn);\
	const unsigned int __EGhsz = __EGehp->sz;\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfchd = mpf_EGeKHeapFirstChildId(__EGehp->d,__EGcpos);\
	unsigned int __EGlchd = __EGfchd + __EGehp->d;\
	mpf_EGeKHeapCn_t*__EGcchd = 0;\
	register unsigned int __EGehi = 0;\
	mpf_EGeKHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGfchd < __EGhsz)\
	{\
		/* detect the minimum child */\
		__EGcchd = __EGehp->cn[__EGfchd];\
		for(__EGehi = __EGlchd > __EGhsz ? __EGhsz-1 : __EGlchd-1 ;\
			__EGehi > __EGfchd ; __EGehi--)\
			if(mpf_EGeKHeapIsLess(__EGehp->cn[__EGehi]->val,__EGcchd->val))\
				__EGcchd = __EGehp->cn[__EGehi];\
		/* if the minimum child is less than the current position, move the minimum\
		 * child to the position of the current element */\
		if(mpf_EGeKHeapIsLess(__EGcchd->val,__EGecn->val))\
		{\
			__EGfchd = __EGcchd->pos;\
			__EGcchd->pos = __EGcpos;\
			__EGehp->cn[__EGcpos] = __EGcchd;\
			__EGecn->pos = __EGcpos = __EGfchd;\
			__EGehp->cn[__EGcpos] = __EGecn;\
			__EGfchd = mpf_EGeKHeapFirstChildId(__EGehp->d,__EGcpos);\
			__EGlchd = __EGfchd + __EGehp->d;\
		}\
		/* else we exit the main loop */\
		else __EGfchd = UINT_MAX;\
	}\
	0;})

/* ========================================================================= */
/** @brief Change the value of an element in the heap.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap that we are going to change it's value.
 * @param __new_val new value for the element (note this is an array of size at
 * least mpf_EG_EKHEAP_ENTRY.
 * @return zero on success, non-zero otherwise.
 * */
#define mpf_EGeKHeapChangeVal(__hp,__hcn,__new_val) ({\
	mpf_EGeKHeapCn_t*const __EGEKHcn = (__hcn);\
	(mpf_EGeKHeapIsLess(__new_val,(__EGEKHcn)->val)) ? (mpf_EGeKHeapCopyVal((__EGEKHcn)->val,__new_val),mpf_EGeKHeapSiftUp(__hp,__EGEKHcn)) : (mpf_EGeKHeapCopyVal((__EGEKHcn)->val,__new_val),mpf_EGeKHeapSiftDown(__hp,__EGEKHcn));})

/* ========================================================================= */
/** @brief Eliminate an element from the heap, note that the position stored in
 * the eliminated element is reset to zero.
 * @param __hp heap where we are working.
 * @param __hcn element to eliminate from the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define mpf_EGeKHeapDel(__hp,__hcn) ({\
	mpf_EGeKHeap_t*const __EGlhp = (__hp);\
	mpf_EGeKHeapCn_t*const __EGlhpcn = (__hcn);\
	unsigned int const __EGlcn = __EGlhpcn->pos;\
	unsigned int const __EGlhsz = __EGlhp->sz - 1;\
	__EGlhpcn->pos = mpf_EG_EKHEAP_POISON;\
	__EGlhp->sz = __EGlhsz;\
	if(__EGlhsz && __EGlhsz != __EGlcn){\
		__EGlhp->cn[__EGlcn] = __EGlhp->cn[__EGlhp->sz];\
		__EGlhp->cn[__EGlcn]->pos = __EGlcn;\
		mpf_EGeKHeapSiftDown(__EGlhp,__EGlhp->cn[__EGlcn]);}\
	__EGlhp->cn[__EGlhp->sz] = 0;})

/* ========================================================================= */
/** @brief Check the integrity of the given heap.
 * @param __hp heap to check.
 * @return zero on success, non-zero otherwise.
 * */
#if mpf_EG_EKHEAP_DEBUG <= DEBUG
#define mpf_EGeKHeapCheck(__hp) ({\
	mpf_EGeKHeap_t*const __EGehp = (__hp);\
	register unsigned int __EGehi = __EGehp->sz;\
	if(__EGehi)\
		while(--__EGehi)\
			if(__EGehp->cn[__EGehi]->pos != __EGehi || \
				mpf_EGeKHeapIsLess( __EGehp->cn[__EGehi]->val,\
												__EGehp->cn[mpf_EGeKHeapFatherId(__EGehp->d,__EGehi)]->val))\
			{\
				MESSAGE(mpf_EG_EKHEAP_DEBUG,"Element %u is wrong, pos %u val [%lf,%lf]"\
							 ,__EGehi, __EGehp->cn[__EGehi]->pos, \
							 mpf_EGlpNumToLf(__EGehp->cn[__EGehi]->val[0]), \
							 mpf_EGlpNumToLf(__EGehp->cn[mpf_EGeKHeapFatherId(__EGehp->d,__EGehi)]->val[0]));\
				break;\
			}\
	__EGehi;})
#else
#define mpf_EGeKHeapCheck(__hp) 0
#endif

/* ========================================================================= */
/** @brief set the breath of the heap, this function must be called only when
 * the heap is empty.
 * @param __hp heap to set breath.
 * @param __width new with for the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define mpf_EGeKHeapChangeD(__hp,__width) ({\
	mpf_EGeKHeap_t*const __EGehp = (__hp);\
	EXIT((__width)<2,"Width should be at least 2 for heaps");\
	__EGehp->sz ? 1 : (__EGehp->d = (__width), 0);})

/* ========================================================================= */
/** @} */
/* end of mpf_eg_ekheap.h */
#endif
#endif
#endif
#ifdef HAVE_LIBGMP
#if HAVE_LIBGMP
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGsrkGraph EGsrkGraph
 * This is a group of functions, macros and types designed to work with
 * graphs that are shrinkable, meaning that we can take two nodes in the
 * (current) graph, and shrink them into a single node, and at the same time
 * collapse all edges that become loops and if two edges are parallel, keep
 * just one (but keep a reference to the collapsed edge). At the same time the
 * shrunken nodes keep a list to the nodes 'embeded' or 'shrunken' into the
 * given node. More details in the structure definition and in the example.
 * Note that this implementation only support undirected graphs with actual
 * weights on the edges, the weights must be of type mpf_t, and their
 * values are updated during the shrinking procedure, so if anyone want to
 * have the original values omewere else, they will have to keep an extra copy
 * outside. Most of the ideas used in this implementation come from CONCORDE.
 * 
 * @version 0.0.1
 * @par History:
 * - 2005-06-01
 * 						- First Implementation.
 * */
/** @file
 * @ingroup EGsrkGraph */
/** @addtogroup EGsrkGraph */
/** @{ */
/** @example mpf_eg_shrink_graph.ex.c */
/* ========================================================================= */

#ifndef mpf__EGshrinkGraph_h__
#define mpf__EGshrinkGraph_h__
#ifndef mpf_EG_SRK_DEBUG
/* ========================================================================= */
/** @brief debuigging level, the lower the more debugging is carried out */
#define mpf_EG_SRK_DEBUG 100
#endif

/* ========================================================================= */
/** @brief Edge structure for shrinkable graphs */
typedef struct mpf_EGsrkEdge_t
{
	EGeUgraphEdge_t edge;	/**< Actual edge structure for the graph */
	EGeList_t members;		/**< list of other edges shrunken within this edge */
	unsigned int mmb_sz;	/**< length of the members list (without including the 
														 edge itsself */
	mpf_t weight;			/**< Weight for the edge */
}
mpf_EGsrkEdge_t;

/* ========================================================================= */
/** @brief Node structure for shrinkable graphs */
typedef struct mpf_EGsrkNode_t
{
	EGeUgraphNode_t node;	/**< actual node structure for the graph */
	EGeList_t members;		/**< list of other nodes shrunken with this node */
	unsigned int mmb_sz;	/**< length of the members list (without including the
														 node itself */
	EGes_t parent;				/**< If this node is the representant for its class, 
														 then this is a 'parent' node, otherwise, is a 
														 shrunken node */
	mpf_t weight;			/**< Weight of the @f$\delta(n)@f$ edges for this node
														 (in the shrunken graph), this should be 
														 initialized by the user. */
	mpf_EGsrkEdge_t *hit;			/**< used for internal purposes, in particular, while 
														 merging two adjacency lists, this field is used 
														 to store the first edge touching this node, and 
														 then used to retrieve that information. When we 
														 call #mpf_EGsrkIdentifyNodes this field is assumed 
														 to be NULL */
}
mpf_EGsrkNode_t;

/* ========================================================================= */
/** @brief Graph structure for shrinkable graphs */
typedef struct mpf_EGsrkGraph_t
{
	EGeUgraph_t G;					/**< Actual graph structure. */
	unsigned n_onodes;			/**< Number of original nodes */
	unsigned n_oedges;			/**< Number of original edges */
}
mpf_EGsrkGraph_t;

/* ========================================================================= */
/** @brief Initialize an edge structure.
 * @param e_edge */
#define mpf_EGsrkEdgeInit(e_edge) ({\
	mpf_EGsrkEdge_t*const _EGsrkE = (e_edge);\
	EGeUgraphEdgeInit(&(_EGsrkE->edge));\
	EGeListInit(&(_EGsrkE->members));\
	_EGsrkE->mmb_sz = 0;\
	mpf_EGlpNumInitVar(_EGsrkE->weight);\
	mpf_EGlpNumZero(_EGsrkE->weight);})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of an edge
 * structure.
 * @param e_edge */
#define mpf_EGsrkEdgeClear(e_edge) ({\
	EGeUgraphEdgeClear(&((e_edge)->edge));\
	mpf_EGlpNumClearVar((e_edge)->weight);})

/* ========================================================================= */
/** @brief Initialize a graph structure 
 * @param graph graph to be initialized */
#define mpf_EGsrkGraphInit(graph) ({\
	mpf_EGsrkGraph_t*const _EGsrkG = (graph);\
	EGeUgraphInit(&(_EGsrkG->G));\
	_EGsrkG->n_onodes = _EGsrkG->n_oedges = 0;})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a graph
 * structure.
 * @param graph */
#define mpf_EGsrkGraphClear(graph) EGeUgraphClear(&((graph)->G))

/* ========================================================================= */
/** @brief Initialize a node structure.
 * @param e_node node to be initialized */
#define mpf_EGsrkNodeInit(e_node) ({\
	mpf_EGsrkNode_t*const _EGsrkN = (e_node);\
	EGeUgraphNodeInit(&(_EGsrkN->node));\
	EGeListInit(&(_EGsrkN->members));\
	_EGsrkN->mmb_sz = 0;\
	_EGsrkN->hit = 0;\
	EGesInit(&(_EGsrkN->parent));\
	mpf_EGlpNumInitVar(_EGsrkN->weight);\
	mpf_EGlpNumZero(_EGsrkN->weight);})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a node
 * structure.
 * @param e_node */
#define mpf_EGsrkNodeClear(e_node) ({\
	EGeUgraphNodeClear(&((e_node)->node));\
	mpf_EGlpNumClearVar((e_node)->weight);})

/* ========================================================================= */
/** @brief Add a #mpf_EGsrkNode_t node to a #mpf_EGsrkGraph_t graph.
 * @param graph graph were to add the node.
 * @param N node to add to the graph.
 * @return zero on success, non-zero otherwise.
 * */
#define mpf_EGsrkAddNode(graph,N) EGeUgraphAddNode(&((graph)->G),&((N)->node))

/* ========================================================================= */
/** @brief Add a #mpf_EGsrkEdge_t edge to a #mpf_EGsrkGraph_t graph.
 * @param lG graph were to add the edge.
 * @param head_pt head node of the edge.
 * @param tail_pt tail node of the edge.
 * @param E edge to be added with end-points head_pt and tail_pt.
 * Note that this function will update the accumulated weight of both
 * endpoints of the newly added edge according to the value stored in the
 * #mpf_EGsrkEdge_t::weight field.
 * */
#define mpf_EGsrkAddEdge(lG,head_pt,tail_pt,E) ({\
	mpf_EGsrkNode_t*const _EGsrkH = (head_pt);\
	mpf_EGsrkNode_t*const _EGsrkT = (tail_pt);\
	mpf_EGsrkEdge_t*const _EGsrkE = (E);\
	mpf_EGlpNumAddTo(_EGsrkH->weight,_EGsrkE->weight);\
	mpf_EGlpNumAddTo(_EGsrkT->weight,_EGsrkE->weight);\
	EGeUgraphAddEdge(&((lG)->G),&(_EGsrkH->node),&(_EGsrkT->node),&(_EGsrkE->edge));})

/* ========================================================================= */
/** @brief Given two nodes in the current shrunken graph, shrunk them into one 
 * node.
 * @param G pointer to the graph where we are working
 * @param base first node.
 * @param srkN second node.
 * @return pointer to the new representing node.
 * @note We assume that the field mpf_EGsrkNode_t::hit is identically NULL for all
 * nodes currently in the shrunken graph (including base and srkN). 
 * @note We allways assume that N1 will be the representing node.
 * @note Take note that this structure can't get back the pointer to the srkN
 * node, the user should take care of that if needed.
 * */
mpf_EGsrkNode_t *mpf_EGsrkIdentifyNodes (mpf_EGsrkGraph_t * const G,
																 mpf_EGsrkNode_t * const base,
																 mpf_EGsrkNode_t * const srkN);

/* ========================================================================= */
/** @} 
 * end of mpf_eg_shrink_graph.h */
#endif
#endif
#endif
#ifdef HAVE_LIBGMP
#if HAVE_LIBGMP
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgPushRelabel EGalgPushRelabel
 *
 * Here we implement the push-relabel algorithm as defined in the book "Network 
 * Flows" by Magnanti et. all, in chapter 6,7 and 8. Using the variant
 * "Highest-label preflow-push algorithm" (described on page 230) wich choose
 * the active node from wich to push from as the one with highest distance
 * label. This variant has running time @f$ \mathcal{O}(n^2\sqrt{m}) @f$ where
 * @a n is the number of nodes in the graph, and @a m the number of edges in it.
 * Note that the call to #mpf_EGalgPRminSTcut produces a maximum @b pre_flow, to 
 * obtain a flow you should call the #mpf_EGalgPRmaxSTflow that takes the graph 
 * produced by #mpf_EGalgPRminSTcut and convert the preflow into a real flow. We
 * also choose to use to register the number of nodes with distance labels
 * @f$k,\quad\forall k=1,\ldots,n@f$ where @a n is the number of nodes in the
 * network. This is done because whenever the number of nodes with distance
 * labels @a k is zero, then all nodes with distance labels above @a k can be
 * set to @a n (and thus be added to the partially computed cut-set). This is an
 * (inportant) empirical speed-up, but does not affect the worst case complexity
 * analysis.
 * @version 1.0.0
 * @par History:
 * - 2010-05-07
 * 						- Add implementation using eg_adgraph.h
 * - 2005-06-01
 * 						- Add globla relabeling heuristic.
 * - 2005-05-30
 * 						- Final test results on the TSP x-files, all should be right now.
 * - 2005-05-26
 * 						- First Implementation.
 * @note This algorithm is implemented the embedded structures approach. I will
 * give further details on what this implies.
 *
 * @note It is important to note that this algorithm (as implemented here) 
 * @b WILL @b FAIL if an edge has infinite capacities. To handle that case
 * either we must re-program it, or you can put capacities suficiently large on
 * them (for example 2 times the sum of all bounded capacities) for this
 * algorithm to work.
 *
 * @note This implementation does use global relabeling, namelly, the
 * strategy when once in a while (for example every @a n or @a m relabeling
 * operations) we recompute
 * the exact distance labels. The use of this heuristic (together with the gap
 * heuristic) have been reported to be the most successfull in practice (see "On
 * Implementing Push-Relabel Method For The Maximum FLow Problem" from Boris V.
 * Cherkassy and Andrew V. Goldberg.) and also in the test that we have
 * performed on the fractional solutions of TSP's instances from the TSPLIB set
 * of problems using CONCORDE.
 * */
/** @file 
 * @ingroup EGalgPushRelabel */
/** @addtogroup EGalgPushRelabel */
/** @{ */
/** @example mpf_eg_push_relabel.ex.c
 * This is a complete example for the min-cut max-flow problem using the
 * push/relabel implementation offered in EGalgPR. */
#ifndef mpf___EG_PUSH_RELABEL_H__
#define mpf___EG_PUSH_RELABEL_H__
/* ========================================================================= */

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define mpf___PR_DEBUGL__ 100

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define mpf___PR_TEST_VERBOSE__ 100

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define mpf___PR_VERBOSE__ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define mpf___PR_PROFILE__ 100

/* ========================================================================= */
/** @brief If profiling is enable (i.e. #mpf___PR_PROFILE__ <= DEBUG), print 
 * some profiling information of the min s-t cut used up to now, and reset 
 * all internal counters to zero, if profiling is not enabled, nothing 
 * happen. */
/** @{ */
void mpf_EGalgPRprofile(void);
/** @} */
/* ========================================================================= */
/** @brief If set to non-zero, use the global relabeling heuristic (to be called
 * every @a n number of relabel operations performed. if set to zero, it won't
 * use this heuristic. Note thought that it has been shown that this is a very
 * efficient heuristic to reduce the total running time, specially in the
 * #mpf_EGalgPRminSTcut function call. */
#define mpf_EG_PR_RELABEL 1

/* ========================================================================= */
/** @brief If #mpf_EG_PR_RELABEL is set to one, then this initeger controls how
 * often we perform the global relabeling heuristic (in multiples of number of
 * nodes), the default value is 1. */
#define mpf_EG_PR_RELABEL_FREC 1U

/* ========================================================================= */
/** @brief Node structure neede to run Push-Relabel algorithm on a network.
 * @note Notice that the directed graph part is embeded in this structure as
 * well. Note  that we could define internally space for  LVL_list, 
 * but for the sake of speed we include them in the node structure. */
typedef struct mpf_EGalgPRnode_t
{
	EGeDgraphNode_t v;		/**< Actual node structure to work with (EGeDgraph) */
	EGeList_t LVL_list;		/**< Used to store the BFS list used for the first 
														 computations of the exact label distances, and 
														 then to store this node in it's current level list 
														 (this is used to implement the Highest-Label 
														 variant of the Preflow-Push algorithm) */
	EGeList_t T_cut;			/**< Used to speed-up the 'hole' heuristic, it is seted
														 once we enter the algorithm, so their value is 
														 non-important outside the function (but it's 
														 contents will be lost once we enter 
														 #mpf_EGalgPRminSTcut). */
	unsigned int d;				/**< Exact label distance for this node. Note that 
														 nodes with distance lables @f$ \geq n @f$ (where 
														 @a n is the number of nodes in the graph) define 
														 the minimum @f$ s-t@f$ cut that we are looking 
														 for. */
	mpf_t e;					/**< Exess flow in the node. Note that in particular 
														 the excess on node @a t (once #mpf_EGalgPRminSTcut 
														 finish) correspond to the minimum cut value. */
}
mpf_EGalgPRnode_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an mpf_EGalgPRnode_t structure */
#define mpf_EGalgPRnodeInit(node_pt) ({\
	mpf_EGalgPRnode_t*const __EGalgPR_in = (node_pt);\
	mpf_EGlpNumInitVar(__EGalgPR_in->e);\
	EGeDgraphNodeInit(&(__EGalgPR_in->v));})

/* ========================================================================= */
/** @brief Reset the given node pointer (as if it were new).
 * @param node_pt pointer to the node to reset.
 * 
 * This function set the node as an empty node not linked with any graph.
 * */
#define mpf_EGalgPRnodeReset(node_pt) EGeDgraphNodeReset(&((node_pt)->v))

/* ========================================================================= */
/** @brief clear a pointer to an mpf_EGalgPRnode_t structure, and let it ready to be
 * freed if necesary. */
#define mpf_EGalgPRnodeClear(node_pt) ({\
	mpf_EGlpNumClearVar((node_pt)->e);\
	EGeDgraphNodeClear(&((node_pt)->v));})

/* ========================================================================= */
/** @brief capacitated edge structure with forward/backward information. */
typedef struct mpf_EGalgPRse_t
{
	EGeDgraphEdge_t e;	/**< actual edge information. */
	mpf_t r;				/**< residual capacity of the edge. */
	mpf_t u;				/**< maximum capacity on the edge. */
	unsigned char type;	/**< type of edge (0 for forward and 1 for backward */
}
mpf_EGalgPRse_t;

/* ========================================================================= */
/** @brief Edge Structure needed to run Push-Relabel algorithm on a network.
 * @note Notice that the this edge actually has actually two capacited edge
  substructures, one for forward edges and one for backward edge, it is assumed
 * that fw.type == 0 and bw.type == 1. This is needed because the algorithm 
 * asumes that both
 * edges exists (althought one may have zero capacity). Moreover, while
 * computing the residual capacities we need to access both edges e_ij and e_ji
 * at the same time, thus our choice to represent both edges in just one
 * structure. We also assume that the lower bound on the flow of all edges is
 * zero. Note that we don't need to keep explicitly the flow on the edges,
 * because given the residual capacity and the capacity on the edge we have that
 * @f$ x_{ij} - x_{ji} = u_{ij} - r_{ij} @f$ and thus we can set @f$ x_{ij} =
 * (u_{ij}-r_{ij})_+ @f$ and @f$ x_{ji} = (r_{ij}-u_{ij})_+ @f$.
 * if we have computed the maximal flow. */
typedef struct mpf_EGalgPRedge_t
{
	mpf_EGalgPRse_t fw;		/**< forward edge, we assum that fw.type = 0 */
	mpf_EGalgPRse_t bw;		/**< backward edge, we assume that bw.type = 1 */
}
mpf_EGalgPRedge_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an mpf_EGalgPRedge_t structure */
#define mpf_EGalgPRedgeInit(edge_pt) ({\
	mpf_EGalgPRedge_t*const __EGalgPR_ie = (edge_pt);\
	mpf_EGlpNumInitVar(__EGalgPR_ie->fw.r);\
	mpf_EGlpNumInitVar(__EGalgPR_ie->fw.u);\
	mpf_EGlpNumInitVar(__EGalgPR_ie->bw.r);\
	mpf_EGlpNumInitVar(__EGalgPR_ie->bw.u);\
	EGeDgraphEdgeInit(&(__EGalgPR_ie->fw.e));\
	EGeDgraphEdgeInit(&(__EGalgPR_ie->bw.e));\
	__EGalgPR_ie->bw.type = 1;\
	__EGalgPR_ie->fw.type = 0;})

/* ========================================================================= */
/** @brief Reset the given edge pointer (as if it were new).
 * @param edge_pt pointer to the node to reset.
 * 
 * This function set the edge as an empty edge not linked with any graph.
 * */
#define mpf_EGalgPRedgeReset(edge_pt) ({\
	mpf_EGalgPRedge_t*const __EGalgPR_ie = (edge_pt);\
	EGeDgraphEdgeReset(&(__EGalgPR_ie->fw.e));\
	EGeDgraphEdgeReset(&(__EGalgPR_ie->bw.e));\
	__EGalgPR_ie->bw.type = 1;\
	__EGalgPR_ie->fw.type = 0;})


/* ========================================================================= */
/** @brief clear a pointer to an mpf_EGalgPRedge_t structure, and let it ready to be
 * freed if necesary. */
#define mpf_EGalgPRedgeClear(edge_pt) ({\
	mpf_EGlpNumClearVar((edge_pt)->fw.r);\
	mpf_EGlpNumClearVar((edge_pt)->fw.u);\
	mpf_EGlpNumClearVar((edge_pt)->bw.r);\
	mpf_EGlpNumClearVar((edge_pt)->bw.u);\
	EGeDgraphEdgeClear(&((edge_pt)->fw.e));\
	EGeDgraphEdgeClear(&((edge_pt)->bw.e));})

/* ========================================================================= */
/** @brief Graph structure needed to run Push-Relabel algorithm (with highest
 * label node selection rule). */
typedef struct mpf_EGalgPRgraph_t
{
	EGeDgraph_t G;				/**< EGeDgraph structure holding the graph 
														 information. */
}
mpf_EGalgPRgraph_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an mpf_EGalgPRgraph_t structure */
#define mpf_EGalgPRgraphInit(graph_pt) EGeDgraphInit(&((graph_pt)->G))

/* ========================================================================= */
/** @brief Reset the given graph pointer (as if it were new).
 * @param graph_pt pointer to the node to reset.
 * 
 * This function set the graph as an empty graph.
 * */
#define mpf_EGalgPRgraphReset(graph_pt) EGeDgraphReset(&((graph_pt)->G))

/* ========================================================================= */
/** @brief clear a pointer to an mpf_EGalgPRgraph_t structure, and let it ready 
 * to be freed if necesary. */
#define mpf_EGalgPRgraphClear(graph_pt) EGeDgraphClear(&((graph_pt)->G))

/* ========================================================================= */
/** @brief Compute a minimum @f$s-t@f$ cut.
 * @param s pointer to the mpf_source node.
 * @param t pointer to the mpf_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the mpf_EGalgPRgraph_t* in wich we will work.
 * @return zero on success, non-zero otherwise.
 * @par Description:
 * When this funcion finish (successfully) all nodes with field
 * #mpf_EGalgPRnode_t::d bigger than or equal to @a n (the number of nodes in the
 * graph) bellong to the @a s cut, while nodes with value strictly less than @a
 * n will bellong to the @a t cut. The residual capacities imply a maximum
 * pre-flow in the network, to get an acutal maximum flow you should run 
 * #mpf_EGalgPRmaxSTflow function with imput the output graph of this function 
 * (for an example look at the file mpf_eg_push_relabel.ex.c ).
 * @note This implementation uses the @a gap and @a global @a relabeling
 * heuristics to speed-up the computations.
 * */
int mpf_EGalgPRminSTcut (mpf_EGalgPRgraph_t * const G,
										 mpf_EGalgPRnode_t * const s,
										 mpf_EGalgPRnode_t * const t);

/* ========================================================================= */
/** @brief Compute a maximum @f$s-t@f$ flow from the ouput produced by
 * EGalgPRminCur.
 * @param s pointer to the mpf_EGalgPRnode_t* mpf_source node in the network.
 * @param t pointer to the mpf_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the mpf_EGalgPRgraph_t* in wich we will work.
 * @return zero on success, non-zero otherwise.
 * @par Description:
 * We assume that our input graph is the (unaltered) result of a 
 * call to #mpf_EGalgPRminSTcut. Also, note that while computing the actual 
 * max @a s-@a t flow, we don't need to look for @a gap in the array of 
 * distances.
 * Also note that once you call this function, the information in
 * #mpf_EGalgPRnode_t::d don't correspond any more to the cut as defined in
 * #mpf_EGalgPRminSTcut.
 * */
int mpf_EGalgPRmaxSTflow (mpf_EGalgPRgraph_t * const G,
											mpf_EGalgPRnode_t * const s,
											mpf_EGalgPRnode_t * const t);

/* ========================================================================= */
/** @brief Check if the given input graph (with it's residual capacities)
 * represent an optimal solution to the maximum @f$ s-t @f$ flow / minimum
 * capacity @f$ s-t @f$ cut.
 * @param s pointer to the mpf_EGalgPRnode_t* mpf_source node in the network.
 * @param t pointer to the mpf_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the mpf_EGalgPRgraph_t* in wich we will work.
 * @param error worst error while checking for optimality conditions.
 * @return zero if all discrepancies are under the #mpf_epsLpNum threshold, 
 * otherwise, return the number of conditions that don't hold within that
 * threshold, and report in error the worst error found in any condition.
 * @note The input for this function should be the graph as returned by
 * #mpf_EGalgPRmaxSTflow .
 * */
int mpf_EGalgPRoptimalityTest (mpf_EGalgPRgraph_t * const G,
													 mpf_EGalgPRnode_t * const s,
													 mpf_EGalgPRnode_t * const t,
													 mpf_t * error);

/* ========================================================================= */
/* @} */
/* end of mpf_eg_push_relabel.h */
#endif
#endif
#endif
#ifdef HAVE_LIBGMP
#if HAVE_LIBGMP
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgMinCut EGalgMinCut
 *
 * Here we implement the min-cut algorithm based on the srinking
 * pre-processing of Padberg And Rinaldi in the paper "An Efficient 
 * Algorithm For The Minimum Capacity Cut Problem", Mathematical Programming
 * 47 (1990) pages 19-36. But using as minimum s-t cut code the Push-Relabel
 * max flow algorithm as implemented in the @ref EGalgPushRelabel module. This 
 * implies that we only support positive edge-weights.
 *
 * This implementation allows uses of diferent numbers as supported by
 * @ref EGlpNum module. And follows the philosophy of embeded structures as in
 * @ref EGalgPushRelabel module. Also, much of the approach used in this 
 * implementation come from CONCORDE's implementation.
 *
 * It is usually the case that the Minimum Cut Problem is just a sub-problem
 * of some larger problem, is for that reason that we implement (just as in
 * CONCORDE) a callback function that is called whenever an improving solution
 * is found, so that the user can do something with the given node-cutset and
 * value. for more details see the definition of #mpf_EGalgMCcbk_t .
 *
 * @note 
 * If run with types like EGfp20_t, if the arithmetic produces an overflow,
 * then we are in big trouble, note that the numbers involved in the algorithm
 * may range up to \f$\sum(w_e:e\in E(G))\f$.
 *
 * @version 0.0.1
 * @par History:
 * - 2005-08-19
 * 						- While computing a minimum S-T cut, choose S randomly. and T
 * 							as a node at maximum distance (number of edges) from S.
 * 						- Fix small problem with shrinking level 4
 * - 2005-06-20
 * 						- First Implementation.
 * */
/** @file
 * @ingroup EGalgMinCut */
/** @addtogroup EGalgMinCut */
/** @{ */
/** @example mpf_eg_min_cut.ex.c */
/* ========================================================================= */
#ifndef mpf__EG_MIN_CUT_H
#define mpf__EG_MIN_CUT_H
/* ========================================================================= */
/** @brief Verbosity Level */
#define mpf___MC_VRBLVL_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define mpf___MC_DEBUG_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define mpf___MC_PROFILE_ 0

/* ========================================================================= */
/** If profiling is enable (i.e. #mpf___MC_PROFILE_ <= DEBUG), print 
 * some profiling information of the min cut used up to now, and reset 
 * all internal counters to zero, if profiling is not enabled, nothing 
 * happen. */
/** @{ */
void mpf_EGalgMCprofile(void);
/** @} */

/* ========================================================================= */
/** @brief Call-back function, it receives as input the weight of the cut, the
 * size of the newly found cut, an array containing the cut (of length at
 * least the number of elements in the cut) as integers (as defined by the 
 * #mpf_EGalgMCnode_t::id field), and a pointer to some internal
 * data (as stored in #mpf_EGalgMCcbk_t::param). The function should return zero
 * on success, and non-zero if an error ocours, this error will be propagated
 * through the calling functions. */
typedef int (*mpf_EGalgMCdo_f) (mpf_t,
														const unsigned int,
														const unsigned int *const,
														void *);

/* ========================================================================= */
/** @brief Call-back structure for use when an improving minimum cut is found.
 * */
typedef struct mpf_EGalgMCcbk_t
{
	mpf_t cutoff;	/**< maximum value for the newly found minimum cut, for 
												 the function to be called. */
	void *param;			/**< external parameter needed by the function */
	mpf_EGalgMCdo_f do_fn;/**< actual function to be called if the cut-off condition 
												 holds */
}
mpf_EGalgMCcbk_t;

/* ========================================================================= */
/** @brief Initialize a call-back structure.
 * @param cb call-back to be initialized. */
#define mpf_EGalgMCcbkInit(cb) ({\
	mpf_EGalgMCcbk_t*const _EGalgMCcb = (cb);\
	mpf_EGlpNumInitVar(_EGalgMCcb->cutoff);\
	_EGalgMCcb->param = 0;\
	_EGalgMCcb->do_fn = 0;})

/* ========================================================================= */
/** @brief Free all internal memory asociated with this structure (not
 * allocated by the user).
 * @param cb call-back strucure to be cleared */
#define mpf_EGalgMCcbkClear(cb) mpf_EGlpNumClearVar((cb)->cutoff)

/* ========================================================================= */
/** @brief Node structure for Minimum Cut */
typedef struct mpf_EGalgMCnode_t
{
	mpf_EGsrkNode_t node;		/**< Actual shrinkable node */
	unsigned int id;		/**< External Identifier for the node */
	EGeList_t lvl_cn;		/**< Connector for the level list */
	unsigned int mpf_lvl;		/**< Current node level test to be performed */
	unsigned int new_id;/**< internal data, it's values can be discarded */
	mpf_EGsrkEdge_t *hit;		/**< Used to speed-up the Padberg-Rinaldi tests. */
}
mpf_EGalgMCnode_t;

/* ========================================================================= */
/** @brief Initialize a node structure for use.
 * @param N node to be initialized */
#define mpf_EGalgMCnodeInit(N) ({\
	mpf_EGalgMCnode_t*const _EGalgMCn = (N);\
	mpf_EGsrkNodeInit(&(_EGalgMCn->node));\
	_EGalgMCn->lvl_cn = (EGeList_t){0,0};\
	_EGalgMCn->mpf_lvl = 0;\
	_EGalgMCn->id = UINT_MAX;\
	_EGalgMCn->new_id = UINT_MAX;\
	_EGalgMCn->hit = 0;})

/* ========================================================================= */
/** @brief Clear any internal memory (not allocated by the user) used by this
 * structure.
 * @param N node to be cleared */
#define mpf_EGalgMCnodeClear(N) mpf_EGsrkNodeClear(&((N)->node))

/* ========================================================================= */
/** @brief Edge structure for the Minimum Cut */
typedef struct mpf_EGalgMCedge_t
{
	mpf_EGsrkEdge_t edge;	/**< Actual shrinkable edge */
	unsigned int id;	/**< External Identifier for the edge */
}
mpf_EGalgMCedge_t;

/* ========================================================================= */
/** @brief Initialize an edge structure for use.
 * @param E edge to be initialized */
#define mpf_EGalgMCedgeInit(E) ({\
	mpf_EGalgMCedge_t*const _EGalgMCe = (E);\
	mpf_EGsrkEdgeInit(&(_EGalgMCe->edge));\
	_EGalgMCe->id = UINT_MAX;})

/* ========================================================================= */
/** @brief Clear any internal memory (not allocated by the user) used by this
 * structure.
 * @param E node to be cleared */
#define mpf_EGalgMCedgeClear(E) mpf_EGsrkEdgeClear(&((E)->edge))

/* ========================================================================= */
/** @brief Graph Structure for Minimum Cut.
 *
 * Note that this structure also holds some parameters as the epsilon to use
  in the comparisons, the current best cut found (or bound), and the current
 * cut found so-far. As well as an array containing all edges and nodes in
 * thee graph (remember that when we Identify two nodes, we loose any
 * reference to the shrinked node in the graph structure as discussed in
 * #mpf_EGsrkIdentifyNodes ) 
 * */
typedef struct mpf_EGalgMCgraph_t
{
	mpf_EGsrkGraph_t G;						/**< Actual shrinking graph used */
	mpf_t epsilon;				/**< error tolerance used for equality testing */
	mpf_t cut_val;				/**< if #mpf_EGalgMCgraph_t::cut_sz is not zero, then 
																 this is the value of the (currenlty) best 
																 minimum cut found so far. otherwise is a bound 
																 on the value of the minimum cut (note that this
																 value should be set before actually computing 
																 the minimum cut, and can be set to the value 
																 of @f$\delta(v)@f$ for some node @a v in the 
																 graph. */
	unsigned int cut_sz;			/**< number of nodes in the current best cut, if 
																 set to zero, then no cut has been found 
																 (so far) */
	EGeList_t lvl_list[5];		/**< List of nodes in different levels of tests */
	unsigned int *cut;				/**< Array  storing the current cut, the size of 
																 this array should be at least 
																 #mpf_EGsrkGraph_t::n_onodes */
	mpf_EGalgMCnode_t *all_nodes;	/**< Array containing all nodes of the graph. */
	mpf_EGalgMCedge_t *all_edges;	/**< Array containing all edges of the graph. */
}
mpf_EGalgMCgraph_t;

/* ========================================================================= */
/** @brief Initialize a graph structure for use.
 * @param Graph graph to be initialized */
#define mpf_EGalgMCgraphInit(Graph) ({\
	mpf_EGalgMCgraph_t*const _EGalgMCg = (Graph);\
	mpf_EGsrkGraphInit(&(_EGalgMCg->G));\
	mpf_EGlpNumInitVar(_EGalgMCg->epsilon);\
	mpf_EGlpNumZero(_EGalgMCg->epsilon);\
	mpf_EGlpNumInitVar(_EGalgMCg->cut_val);\
	mpf_EGlpNumZero(_EGalgMCg->cut_val);\
	_EGalgMCg->cut_sz = 0;\
	EGeListInit(_EGalgMCg->lvl_list);\
	EGeListInit(_EGalgMCg->lvl_list+1);\
	EGeListInit(_EGalgMCg->lvl_list+2);\
	EGeListInit(_EGalgMCg->lvl_list+3);\
	EGeListInit(_EGalgMCg->lvl_list+4);\
	_EGalgMCg->cut = 0;\
	_EGalgMCg->all_nodes = 0;\
	_EGalgMCg->all_edges = 0;})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a graph
 * structure.
 * @param Graph graph to be cleared. */
#define mpf_EGalgMCgraphClear(Graph) ({\
	mpf_EGsrkGraphClear(&((Graph)->G));\
	mpf_EGlpNumClearVar((Graph)->epsilon);\
	mpf_EGlpNumClearVar((Graph)->cut_val);})

/* ========================================================================= */
/** @brief Shrink two nodes in the graph, and update internal structures.
 * @param Graph current graph.
 * @param N node to keep in graph.
 * @param M node to shrink within N. */
#define mpf_EGalgMCidentifyNodes(Graph,N,M) ({\
	mpf_EGalgMCgraph_t*const _EGalgMCg = (Graph);\
	mpf_EGalgMCnode_t*const _EGalgMCn = (N), *const _EGalgMCm = (M);\
	MESSAGE(mpf___MC_DEBUG_,"Shrinking nodes with weight %lf %lf", \
					mpf_EGlpNumToLf(_EGalgMCn->node.weight), \
					mpf_EGlpNumToLf(_EGalgMCm->node.weight));\
	mpf_EGsrkIdentifyNodes(&(_EGalgMCg->G), &(_EGalgMCn->node), &(_EGalgMCm->node));\
	if(_EGalgMCn->mpf_lvl < 5)\
	{\
		EGeListDel(&(_EGalgMCm->lvl_cn));\
		EGeListMoveAfter(&(_EGalgMCn->lvl_cn), _EGalgMCg->lvl_list);\
	}\
	else EGeListAddAfter(&(_EGalgMCn->lvl_cn), _EGalgMCg->lvl_list);\
	_EGalgMCn->mpf_lvl = 0;})

/* ========================================================================= */
/** @brief Identify all Padberg and Rinaldy edges. i.e. shrink all edges that
 * satisfy the conditions in their paper. we choose to make tests over pair of
 * nodes linked by an edge. 
 * @param max_lvl set a limit on wich tests to perform. for example, if set to
 * 1, only the first and second tests will be carried out.
 * @param G graph over wich we are working. 
 * @param cb call back structure to use (if set to NULL it is not used).
 * @return zero on success, non-zero otherwise. 
 *
 * Note that while doing this identification process, we update the values of
 * #mpf_EGalgMCgraph_t::cut, #mpf_EGalgMCgraph_t::cut_sz and #mpf_EGalgMCgraph_t::cut_val,
 * as well as performing the actual shrinking procedure.
 *
 * The original theorem (for local conditions on shrinking) is the following:
 * Let @f$ Z @f$ be a proper subset of @f$ V @f$ (the set of all nodes in the
 * graph), @f$ |Z|\geq2 @f$, and let 
 * @f[ P(Z) = \bigcup\left\{ N(u)\cap N(v):u\neq v, u,v\in Z \right\} @f]
 * where @f$ N(u) @f$ if the set of neighbours of @f$ u @f$. If there exists
 * @f$ Y\subseteq P(Z) @f$ such that for every nonempty proper subset @f$ W
 * @f$ of @f$ Z @f$ and for every @f$ T\subseteq Y @f$ either:
 * -# @f$ w(\delta(W))/2 \leq w(W:(Y-T)+(Z-W)) @f$ or
 * -# @f$ w(\delta(Z-W))/2 \leq w(Z-W:T+W) @f$.
 * Then there exists a minimum cut @f$(X:V-X)@f$ such that either @f$
 * Z\subseteq X @f$ or @f$ X\subseteq Z @f$.
 *
 * And the original theorem (in fact is the corollary 3.5 in the paper) 
 * regarding global conditions for shrinking is the following:
 * Let @f$ u\neq v\in V @f$, and let @f$ q @f$ be an upper bound on the
 * minimum cut value, and @f$ lb_{uv} @f$ be a lower bound in the value of a
 * minimum @f$ u-v @f$ cut, then if @f$ lb_{uv}\geq q @f$ the set 
 * @f$ \{u,v\} @f$ is shrinkable.
 * 
 * The actual tests that we perform (for every edge) are the following:
 * -# If @f$ w(\delta(u)) < @f$ #mpf_EGalgMCgraph_t::cut_val, update the minimum
 * cut value and set.
 * -# If @f$ w_{uv} \geq \min\{w(\delta(u)),w(\delta(v))\}/2 @f$ then we can 
 * safely shrink edge @f$ uv @f$.
 * -# If we have a triangle @f$ uv,\quad vw,\quad wu  @f$, with 
 * @f$ w_{uv} + w_{vw} \geq w(\delta(v))/2 @f$ and  
 * @f$ w_{uw} + w_{vw} \geq w(\delta(w))/2 @f$ then we can safely shrink edge
 * @f$ wv @f$.
 * -# Compute lower bound on the cut that separates the endpoints of the
 * current edge as :
 * @f[ lb_{uv}=w_{uv}+\sum\limits_{w\in N(u)\cap N(v)}\min\{w_{uw},w_{vw}\} @f]
 * If  @f$ lb_{uv} \geq  @f$ #mpf_EGalgMCgraph_t::cut_val , then we can shrink the edge  @f$ uv @f$.
 * -# Consider the edge @f$ uv @f$ and two common neighbours @f$ x,y @f$. If  
 * @f$ w_{ux} + w_{uy} + w_{uv} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{vx} + w_{vy} + w_{vu} \geq w(\delta(v))/2 @f$ and at least one of 
 * @f$ w_{uv} + w_{uy} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{uv} + w_{vx} \geq w(\delta(v))/2 @f$ and at least one of 
 * @f$ w_{uv} + w_{ux} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{uv} + w_{vy} \geq w(\delta(v))/2 @f$ then we can safely shrink edge
 * @f$ uv @f$.
 *
 * We make thiese tests in order, i.e. first we perform all level 1 tests,
 * then level2, and so on, and whenever two nodes are Identify (shrinked) we
 * set the level of the node to 1 (i.e. in the next test we will test the
 * first condition). This is done using an array of (5) lists, where all nodes
 * are distributed. Originally all nodes should be in the first lists (i.e.
 * all nodes should be tested to improve the current best cut by themselves).
 * */
int mpf_EGalgMCidentifyPRedges (mpf_EGalgMCgraph_t * const G,
														mpf_EGalgMCcbk_t * const cb,
														const unsigned int max_lvl);

/* ========================================================================= */
/** @brief Compute a minimum cut on the given graph. 
 * @param max_lvl set a limit on wich tests to perform during the
 * Padberg-Rinaldy shrinking step. for example, if set to
 * 1, only the first and second tests will be carried out.
 * @param G graph over wich we are working. 
 * @param cb call back structure to use (if set to NULL it is not used).
 * @return zero on success, non-zero otherwise. 
 *
 * This function takes as input a graph, and perform the minimum cut algorithm
 * as described in the paper "An Efficient 
 * Algorithm For The Minimum Capacity Cut Problem", Mathematical Programming
 * 47 (1990) pages 19-36. 
 *
 * Note that the graph should have all fields properly initialized.
 * */
int mpf_EGalgMC (mpf_EGalgMCgraph_t * const G,
						 mpf_EGalgMCcbk_t * const cb,
						 const unsigned int max_lvl);

/* ========================================================================= */
/** @} 
 * end mpf_eg_min_cut.h */
#endif
#endif
#endif
#ifdef HAVE_LIBGMP
#if HAVE_LIBGMP
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef mpf___EG_NUMUTIL_H__
#define mpf___EG_NUMUTIL_H__

/* ========================================================================= */
/** @defgroup EGlpNumUtil General Number Utilities
 * Here we put some utilities common for different number types but thaat we
 * want to implement as templates, like permutation sorting, inner product of
 * vectors, and so-on..
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2007-10-08
 *  					- Separate template file and independet file into eg_nummacros.h
 *  					- Move EGabs, EGswap, EGmin and EGmax to this file
 *  - 2005-10-31
 *  					- First implementation.
 * */
/** @{*/
/** @file
 * @brief This file provide the user interface and function definitions for
 * general number utilities.
 * */
/* ========================================================================= */
/** @brief compute the inner product of two arrays.
 * @param arr1 first array.
 * @param arr2 second array.
 * @param length number of entries to consider in both arrays, from zero to
 * length - 1.
 * @param rop where to store the result.
 * */
#define mpf_EGlpNumInnProd(__rop,__arr1,__arr2,__length) mpf___EGlpNumInnProd((&(__rop)),__arr1,__arr2,__length)
/* ========================================================================= */
/** @brief internal version, this is done to avoid using stdc99 and rely on
 * more basic stdc89 */
void mpf___EGlpNumInnProd(mpf_t*rop,mpf_t*const arr1,mpf_t*const arr2, const size_t length);
/* ========================================================================= */
/** @brief Sort (in increasing order) a sub-set of entries in an array using 
 * quicksort, by permutating the order of the elements in the subset rather 
 * than in the whole original array.
 * @param sz length of the permutation array.
 * @param perm array of indices of elements that we want to sort.
 * @param elem array (of length at least max(perm[k]:k=0,...,sz-1)) containing
 * the elements to be sorted.
 * @note The array of elements is not changed by this function.
 * @note This code is based in concorde's implementation of
 * permutation-quick-sort.
 * */
void mpf_EGutilPermSort (const size_t sz,
										 int *const perm,
										 const mpf_t * const elem);

/* ========================================================================= */
/** @brief Sort (in decreasing order) a sub-set of entries in an array using 
 * quicksort, by permutating the order of the elements in the subset rather 
 * than in the whole original array.
 * @param sz length of the permutation array.
 * @param perm array of indices of elements that we want to sort.
 * @param elem array (of length at least max(perm[k]:k=0,...,sz-1)) containing
 * the elements to be sorted.
 * @note The array of elements is not changed by this function.
 * @note This code is based in concorde's implementation of
 * permutation-quick-sort.
 * */
void mpf_EGutilPermSort2 (const size_t sz,
										 int*const perm,
										 const mpf_t*const elem);

/* ========================================================================= */
/** @}*/
#endif
#endif
#endif
#ifdef HAVE_LIBGMP
#if HAVE_LIBGMP
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgDijkstra EGalgDijkstra
 * Dijkstra implementation with 2-heaps
 * */
/** @file
 * @ingroup EGalgDijkstra */
/** @addtogroup EGalgDijkstra */
/** @{ */
/** @example mpf_eg_dijkstra.ex.c */
/* ========================================================================= */
#ifndef mpf___EG_DIJKSTRA_H
#define mpf___EG_DIJKSTRA_H
/* ========================================================================= */
/** @brief Verbosity Level */
#define mpf_DJK_VRBLVL_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define mpf_DJK_DEBUG_ 100

/* ========================================================================= */
/** @brief implement dijkstra.
 * */
int mpf_EGalgDJK (
		int32_t const nnodes,
		int32_t const nedges,
		int32_t const*const ou_d,
		int32_t const*const ou_beg,
		int32_t const*const ou_e,
		mpf_t const*const weight,
		int32_t const s,
		int32_t const nt,
		int32_t const*const t,
		int32_t*const father,
		mpf_t*const dist
		);

/* ========================================================================= */
/** @brief read from a file in .x format (as in the concorde's .x files), the
 * format is as follows:
 * nnodes nedges
 * tail_1 head_1 weight_1
 * ...    ...    ....
 * tail_nnodes head_nnodes weight_nnodes
 * comments are allowed, if they start with % or #.
 * @param input file containing the data
 * @param n where to store the number of nodes
 * @param m where to store the number of edges
 * @param edges pointer to an array where to store the edges, note that memory
 * will be allocated in (*edges)
 * @param weight pointer to the array where we will store the weights, note
 * that this array will be allocated using mpf_EGlpNumAllocArray, and should be
 * deallocated using mpf_EGlpNumFreeArray.
 * @return zero on success, non-zero otherwise 
 * */
int mpf_EGguReadXgraph(
		EGioFile_t*const input,
		int32_t*const n,
		int32_t*const m,
		int32_t**const edges,
		mpf_t**const weight);
/* ========================================================================= */
/** @} 
 * end mpf_eg_dijkstra.h */
#endif

#endif
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005,2006,2007,2008,2009,2010,2011 Daniel Espinoza.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGmemSlab EGmemSlab
 *
 * This is a basic interface for slab pool managment. The idea comes from Slabs
 * as defined in both Linux and Solaris (see "The Slab Allocator: An
 * Object-Caching Kernel Memory Allocator", by Jeff Bonwick, Sun Microsystems),
 * the basic idea is
 * to provide pool for a specific type of object, and to store them in an
 * initialized state, so that initialization and destruction only is done while
 * growing/freeing the memory slabs, thus this approach should provide greater
 * advantages for complitated to initialize structures. and in theory
 * (althought not yet implemented) this structure can be managed so as to
 * provide a shrinkable memory managment on the fly.
 *
 * In this implementation we only allow small caches (i.e. objects must be
 * smaller than EG_SLAB_ULIMIT and internally we don't allocate objects smaller
 * than EG_SLAB_LLIMIT), 
 * within a unique memory page. We could allow in the future for more flexible
 * slabs. This implementation also uses colored slabs (see the paper for
 * further details).
 *
 * Here we can see a schematic drawing of the slab allocator structure and
 * functions:
 *
 * @version 0.9.0
 * @par History:
 * - 2011-03-01
 * 						- Make EGms_t thread-safe, i.e. a single memory pool can serve
 * 							several threads. This makes the default memory manager for GMP
 * 							thread safe as well
 * - 2010-12-27
 * 						- Add short-hand names for functions
 * - 2008-10-06
 * 						- Second implementation
 * - 2005-07-30
 * 						- First Implpementation.
 * */
/** @file
 * @ingroup EGmemSlab */
/** @addtogroup EGmemSlab */
/**  @{  */
/** @example eg_memslab.ex.c */
/* ========================================================================= */
#ifndef __EG_MEM_SLAB_H__
#define __EG_MEM_SLAB_H__

/* ========================================================================= */
/** @name EGmemSlab Parameters
 * @brief parameters for controling slab pool allocation */
/* @{ */
/** @brief control the handle of empty slabs, if set to non-zero, free unused
 * slabs as they become unused, if set to zero, keep all unused slabs until
 * #EGmemSlabPoolShrink is called */
#define EG_MSLBP_FREEFREE 1
/* @} */
/* ========================================================================= */
/* declare the slab pool structure */
struct EGmemSlabPool_t;

/* ========================================================================= */
/** @brief maximum size of the objects that can be allocated via slab. */
#define EG_SLAB_ULIMIT ((size_t)1023)
#define EG_SLAB_LLIMIT ((size_t)16)

/* ========================================================================= */
/** @brief size of the memory slabs (in bytes ) */
#define EG_SLAB_SIZE ((size_t)0x1000)

/* ========================================================================= */
/** @brief mask to detect the position of a piece of memory within a slab */
#define EG_SLAB_MASK (~(EG_SLAB_SIZE-1))

/* ========================================================================= */
/** @brief address used to check consistency if enabled */
#define EG_SLAB_POISON ((size_t)0xdeadbeef)

/* ========================================================================= */
/** @brief if set to one, enable profiling for the slab allocator */
#define EG_SLAB_PROFILE 1000

/* ========================================================================= */
/** @brief local verbose level for the slab allocator, the lower the level, the
 * more information will be printed on screen. */
#define EG_SLAB_VERBOSE 1000

/* ========================================================================= */
/** @brief local debug level for the slab allocator, the lower the level, the
 * more testing will be done. */
#define EG_SLAB_DEBUG 1000

/* ========================================================================= */
/** @brief end of list marker, note that this can not be more than 255 */
#define EG_SLAB_ENDMARK ((uint8_t)255U)

#ifndef EG_SLAB_REDUCE_TO_MALLOC
/* ========================================================================= */
/** @brief if set to one, reduce the slab pool allocator to a simple malloc
 * call */
#define EG_SLAB_REDUCE_TO_MALLOC 0
#endif


/* ========================================================================= */
/** @brief Given a pointer, return a pointer to the beginning of the containing
 * page. */
#define EG_SLAB_PAGE(__ptr) (((size_t)__ptr)&EG_SLAB_MASK)

/* ========================================================================= */
/** @brief structure that holds the information relevant to each slab
 * */
typedef struct
{
	char*base;								/**< @brief Where the data-payload start */
	size_t elem_sz;						/**< @brief byte-size of each element */
	size_t n_elem;						/**< @brief number of used elements */
	EGeList_t slab_cn;				/**< @brief Connector into the list of slabs*/
	struct EGmemSlabPool_t *pool;	/**< Pointer to the slab pool structure */
	size_t next;							/**< @brief next free element */
} EGmsbControl_t;
typedef struct
{
	EGmsbControl_t control;	/**< @brief comon base structure for slabs */
	uint8_t next_list[];		/**< @brief list of free elements, the next 
																element is next_list[0], whenever we reach a
																value of 255, it is the end of the free-list.
																*/
} EGmemSlab_t;

/* ========================================================================= */
/** @brief structure used to store a slab memory pool */
typedef struct EGmemSlabPool_t
{
	EGeList_t half;					/**< Head of the list for half-full slabs */
	EGeList_t empty;				/**< Head of the list for non used slabs */
	EGeList_t full;					/**< Head of the list for fully used slabs*/
	EGconstructor_f constr;	/**< Constructor for the local elements */
	EGdestructor_f dest;		/**< Destructor for the local elements */
	uint16_t elem_sz;				/**< Size of the elements in the slab, including 
															 extra space for pointer to next. */
	uint8_t n_elem;					/**< Total number of elements in each slab */
	uint8_t c_color;				/**< Last used color while creating slabs. */
	uint8_t max_color;			/**< Maximum valid value for colors in this pool */
	uint8_t freefree:1;			/**< if non-zero, free non-used slabs */
	uint8_t pad1:7;					/**< padding */
	uint16_t pad2;					/**< padding */
	char const *file;				/**< File where the structure was initialized */
	char const *func;				/**< Function where the structure was initialized */
	int line;								/**< Line where the structure was initialized */
	uint64_t real_sz;				/**< Actual size of the elements asked by the user */
	uint64_t n_slabs;				/**< Number of slabs */
	uint64_t n_tot;					/**< Total number of elements in use by the user */
	uint64_t max_tot;				/**< Maximum number of elements allocated */
	uint64_t max_slabs;			/**< Maximum number of slabs used */
	uint64_t ncals;					/**< number to alloc calls */
	uint64_t n_allocs;			/**< number slab alloc calls */
	#if HAVE_EG_THREAD
	pthread_mutex_t mt;			/**< mutex for memory slab manager */
	#endif
}
EGmemSlabPool_t;

/* ========================================================================= */
/** @brief slab lock/unlock macros */
#if HAVE_EG_THREAD
#define __EGmspLock(__slab) pthread_mutex_lock(&(__slab->mt))
#define __EGmspUnlock(__slab) pthread_mutex_unlock(&(__slab->mt))
#else
#define __EGmspLock(__slab)
#define __EGmspUnlock(__slab)
#endif
/* ========================================================================= */
/** @brief display given slab structure 
 * @param slab what to display
 * @param stream where to print it
 * */
void EGmemSlabDisplay(const EGmemSlab_t*const slab, FILE*stream);

/* ========================================================================= */
/** @brief display given pool structure
 * @param pool what to display
 * @param stream where to print it
 * */
void EGmemSlabPoolDisplay(const EGmemSlabPool_t*const pool, FILE*stream);

/* ========================================================================= */
/** @brief given a piece of memory that should be within a slab, return the
 * pointer to the related slab structure, remember that the slab structure is
 * at the beggining of the page. */
#define EGmemSlabGetSlab(__ptr) \
		((EGmemSlab_t*)(EG_SLAB_PAGE(__ptr)))

/* ========================================================================= */
/** @brief initialize a slab structure. This include calling the constructor
 * for all elements in the slab. Note that this function asumes that all memory
 * has been previously set to NULL. It will also place this slab in the list 
 * of empty slabs in the given pool.
 * @param slab pointer within the memory range of the slab to be initialized.
 * @param __Pool Slab __Pool where this slab will bellong from. The slab pool
 * should be initialized (i.e. should have a constructor and destructor, and an
 * element size set.
 * */
void __EGmemSlabInit( EGmemSlab_t*const slab,
										EGmemSlabPool_t*const __Pool);
/* ========================================================================= */
/** @brief given an initialized slab, clear all internally allocated memory,
 * and leave the slab ready to be freed by 'free', this include calling the
 * destructor for all elements in the slab.
 * @param slab pointer to an area of the slab memory to be clear.
 * @note If debugging is enabled, then all fields will be poisoned so that
 * subsequent use of this structure will fail (but for the free call). Also, if
 * debugging is enabled, we will check that the slab has no element in use.
 * */
void EGmemSlabClear( EGmemSlab_t*const slab);

/* ========================================================================= */
/** @brief Given a non-full slab, extract a pointer to the next unused element
 * in the slab, and update all internal data. and if it becomes full, then move
 * it to the full list within the pool. Also, if debugging, poison the pointer
 * to the enext element in the returned element. If the slab is not full, and
 * the number of active elements is one, then move the slab to the half-full
 * slab list in the pool.
 * @param slab pointer within a slab memory.
 * @return pointer to a void* of initialized memory by the given contructor in
 * the slab pool.
 * */
#define EGmemSlabPopElement(slab) ({\
	EGmemSlab_t*const _EGmSlb = EGmemSlabGetSlab(slab);\
	EGmemSlabPool_t*const _EGPlRf = _EGmSlb->control.pool;\
	const size_t _EGmSlb_esz = _EGmSlb->control.elem_sz;\
	const size_t _EGmSlb_ne = _EGmSlb->control.next;\
	const size_t _EGmSlb_nn = _EGmSlb->next_list[_EGmSlb_ne];\
	void*const _EGelem = (void*)(_EGmSlb_ne*_EGmSlb_esz + _EGmSlb->control.base);\
	/* now update the slab */\
	_EGmSlb->control.n_elem++;\
	_EGmSlb->control.next = _EGmSlb_nn;\
	EXITL(EG_SLAB_DEBUG,_EGmSlb_ne == EG_SLAB_ENDMARK, "Allocating from full slab");\
	/* if the slab is full, move it to full list */\
	if(_EGmSlb_nn == EG_SLAB_ENDMARK){\
		EGeListMoveAfter(&(_EGmSlb->control.slab_cn),&(_EGPlRf->full));}\
	/* if the slab is first-time used, move to half list */\
	else if(_EGmSlb->control.n_elem == 1U){\
		EGeListMoveAfter(&(_EGmSlb->control.slab_cn),&(_EGPlRf->half));}\
	/* return the element */\
	_EGelem;})

/* ========================================================================= */
/** @brief Given an used object within a slab, give it back to the slab for
 * future use.
 * @param __ptr pointer to the element to be given back to its containing slab.
 * */
#define EGmemSlabPushElement(__ptr) do{\
	char*const _EGmsbPtr = (char*)(__ptr);\
	EGmemSlab_t*const _EGmSlb = EGmemSlabGetSlab(_EGmsbPtr);\
	EGmemSlabPool_t*const _EGPlRf = _EGmSlb->control.pool;\
	__EGmspLock(_EGPlRf);{\
	const size_t _EGmSlb_esz = _EGmSlb->control.elem_sz;\
	const size_t _EGmSlb_ne = _EGmSlb->control.next;\
	const size_t _EGmSlb_nn = ((_EGmsbPtr) - _EGmSlb->control.base)/_EGmSlb_esz;\
	/* if debugging, check for poison in the pointer to the next element in the \
	 * given element */\
	EXITL(EG_SLAB_DEBUG, !_EGmSlb->control.n_elem, "freeing from an empty slab");\
	/* now actually put the element into the slab */\
	_EGmSlb->control.n_elem--;\
	_EGmSlb->control.next = _EGmSlb_nn;\
	_EGmSlb->next_list[_EGmSlb_nn] = _EGmSlb_ne;\
	__EGmsbUPD2(_EGPlRf);\
	/* if the slab is now not being used, update accordingly */\
	if(_EGmSlb_ne == EG_SLAB_ENDMARK){\
		EGeListMoveAfter(&(_EGmSlb->control.slab_cn),&(_EGPlRf->half));}\
	else if(!_EGmSlb->control.n_elem){\
		if(_EGPlRf->freefree){\
			EGmemSlabClear(_EGmSlb);\
			free((void*)_EGmSlb);}\
		else{\
			EGeListMoveAfter(&(_EGmSlb->control.slab_cn),&(_EGPlRf->empty));}}}\
	__EGmspUnlock(_EGPlRf);\
	}while(0)

/* ========================================================================= */
/** @brief initialize a slab pool as an empty pool for elements of the given
 * size, and with te given constructor and destructors. 
 * @param constr_fn constructor fnctioin for the elements to be stored in the
 * pool.
 * @param dest_fn destructor function for the elements to be stored in the
 * pool.
 * @param pool pointer to the slab pool to initialize.
 * @param sz (real) size (in bytes) of the elements to be hold. in the pool.
 * This means that sz is the result of sizeof(TYPE), where TYPE is the
 * structure to be pooled. */
#define EGmemSlabPoolInit(pool, sz, constr_fn, dest_fn) \
				__EGmemSlabPoolInit(pool, sz, constr_fn, dest_fn, \
														__FILE__, __func__, __LINE__)
void __EGmemSlabPoolInit( EGmemSlabPool_t*const pool,
													const size_t sz,
													EGconstructor_f constr_fn,
													EGdestructor_f dest_fn,
													const char*const file,
													const char*const func,
													const int line);
/* ========================================================================= */
/** @brief clear a slab pool and all internal sub-structures and data, no
 * further calls to this structure are posible after this (but for freeing the
 * memory containing this data, or to re-initialize it).
 * @param __Pool slab pool to be cleared.
 * */
void EGmemSlabPoolClear(EGmemSlabPool_t*const __Pool);
/* ========================================================================= */
/** @brief add one to the given pointer, if profiling is enabled, otherwise, do
 * nothing */
#if EG_SLAB_PROFILE <= DEBUG
#define __EGmsbUPD1(__pool) do{\
	__pool->ncals++;\
	__pool->n_tot++;\
	if(__pool->max_tot < __pool->n_tot) __pool->max_tot = __pool->n_tot;}while(0)
#define __EGmsbUPD2(__pool) __pool->n_tot--
#else
#define __EGmsbUPD1(__pool)
#define __EGmsbUPD2(__pool)
#endif

/* ========================================================================= */
/** @brief Given a slab pool, return an element from the pool. 
 * @param __Pool slab pool from where we will get the memory. 
 * @return pointer to an initialize element. */
#if EG_SLAB_REDUCE_TO_MALLOC
#define EGmemSlabPoolAlloc(__Pool) ({\
	EGmemSlabPool_t*const _EGmPl = (__Pool);\
	void*_EGmb = EGmalloc(_EGmPl->elem_sz+sizeof(void*));\
	void**_EGpt = (void**)_EGmb;\
	__EGmsbUPD1(_EGmPl);\
	(*_EGpt) = _EGmPl;\
	_EGmb=((void*)(_EGpt+1));\
	if(_EGmPl->constr) _EGmPl->constr(_EGmb);\
	_EGmb;})
#else
#define EGmemSlabPoolAlloc(__Pool) ({\
	EGmemSlabPool_t*const _EGmPl = (__Pool);\
	void* _EGSmbRf = 0;\
	void* _EGrptr = 0;\
	int __EGmPlerr=0;\
	__EGmspLock(_EGmPl);\
	__EGmsbUPD1(_EGmPl);\
	if(!EGeListIsEmpty(&(_EGmPl->half))){ _EGSmbRf = _EGmPl->half.next;}\
	else if(!EGeListIsEmpty(&(_EGmPl->empty))){ _EGSmbRf = _EGmPl->empty.next;}\
	else{\
		if((__EGmPlerr=posix_memalign(&_EGSmbRf,EG_SLAB_SIZE,EG_SLAB_SIZE))){\
			EXIT(1,"posix_memalign falied with code %d, error %s",__EGmPlerr,\
					strerror(__EGmPlerr));}\
		__EGmemSlabInit(_EGSmbRf,_EGmPl);}\
	_EGrptr = EGmemSlabPopElement(_EGSmbRf);\
	MESSAGE(EG_SLAB_VERBOSE,"Returning %p",_EGrptr);\
	__EGmspUnlock(_EGmPl);\
	_EGrptr;})
#endif

/* ========================================================================= */
/** @brief Given a pointer to an element allocated through a slab pool, give it
 * back to the pool.
 * @param __ptr pointer to be returned to the pool.
 * */
#if EG_SLAB_REDUCE_TO_MALLOC
#define EGmemSlabPoolFree(__ptr) ({\
	void**_EGptr = ((void**)(__ptr))-1;\
	EGmemSlabPool_t*const _EGmPl = (EGmemSlabPool_t*)(*_EGptr);\
	__EGmsbUPD2(_EGmPl);\
	if(_EGmPl->dest) _EGmPl->dest(((void*)(_EGptr+1)));\
	EGfree(_EGptr);})
#else
#define EGmemSlabPoolFree(__ptr) EGmemSlabPushElement(__ptr)
#endif

/* ========================================================================= */
/** @brief Given a slab pool, free all unused slabs 
 * @param pool slab pool to be shrinked. */
void EGmemSlabPoolShrink(EGmemSlabPool_t*const pool);

/* ========================================================================= */
/** @brief set parameters for a slab pool */
int EGmemSlabPoolSetParam(EGmemSlabPool_t*const pool,
													const int param,
													const int val);
/* ========================================================================= */
/** @brief short names for common functions */
#define EGmsAlloc  EGmemSlabPoolAlloc
#define EGmsFree   EGmemSlabPoolFree
#define EGmsInit   EGmemSlabPoolInit
#define EGmsClear  EGmemSlabPoolClear
#define EGms_t     EGmemSlabPool_t
#define EGmsShrink EGmemSlabPoolShrink
/* ========================================================================= */
/* end of eg_memslab.h */
/**  @}  */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/* ========================================================================= */
/** @defgroup EGsimula EGsimula
 *
 * Here we define a simple network simulator, the idea is to simulate process
 * through a network, where each node is either a generator of events, a sink
 * (or final node) of events, or a FIFO queue composed of \f$k\f$ identical 
 * servers. And where the events leave a node to the next node depending on the
 * probability on the outgoing edges (the sum of the probabilities on the
 * outgoing edges should be one).
 *
 * @par History:
 * - 2006-08-14
 * 		- First implementation 
 * - 2008-03-22
 * 		- Add suport for variable rate poisson process
 * 		- Change interface for random variables
 *
 * */
/** @file 
 * @ingroup EGsimula */
/** @addtogroup EGsimula */
/** @{ 
 * @example eg_simula.ex.c
 * This is a simple example of the usage of this simulator
 * @ref EGsimula */
#ifndef __EG_SIMULA_H__
#define __EG_SIMULA_H__

/* ========================================================================= */
/** @brief verbose level */
#define EG_SIM_VERBOSE 1000
/* ========================================================================= */
/** @brief debug level */
#define EG_SIM_DEBUG 10000
/* ========================================================================= */
/** @brief strcture that holds an edge (with probability weight). */
typedef struct 
{
	double p;	/**< @brief Probability that we will use this (outgoing) edge. */
	EGeDgraphEdge_t edge;	/**< @brief Actual underlying edge */
} EGsimEdge_t;
/* ========================================================================= */
/** @brief all types of availables nodes */
typedef enum 
{
	EGsimG, /**< @brief Type of generator nodes */
	EGsimT, /**< @brief Type of sink nodes */
	EGsimN  /**< @brief Type of normal nodes */
} EGsimNodeType_t;
/* ========================================================================= */
/** @brief all types of random variables */
typedef enum
{
	EGsimRV_novar=0,/**< @brief no random variable */
	EGsimRV_2param,	/**< @brief 2-parameter random variables */
	EGsimRV_VRP			/**< @brief variable rate poisson process */
} EGsimRandomType_t;
/* ========================================================================= */
/** @brief structure to hold a variable rate poisson process. The idea is to 
 * be able to simulate a variable rate poison process whose rate changes a
 * finite number of times, and the changes are cyclic in time. i.e. 
 * \f$ \lambda(t) = \lambda(t\mathrm{mod} t_max) \f$ */
typedef struct
{
	size_t nint;			/**< @brief number of rate changes */ 
	double*interval;	/**< @brief length of the interval */
	double*rate;			/**< @brief variable rate for the corresponding interval */
	double*weight; 		/**< @brief the value of 
												 \f$\int_{0}^{t_i}\lambda_ie^{\lambda_it}dt\f$*/
	EGrandState_t g;	/**< @brief random state to use for this variable */
	double max_t;			/**< @brief sum of time intervals */
	size_t* ngen;
	double* sumxi;
} EGsimVRPoisson_t;
/* ========================================================================= */
/** @brief initialize an #EGsimVRPoisson_t structure */
#define EGsimVRPInit(__VRP) do{\
	EGsimVRPoisson_t*const __EGVRP = (__VRP);\
	memset(__EGVRP,0,sizeof(EGsimVRPoisson_t));\
	EGrandInit(&(__EGVRP->g));}while(0)
/* ========================================================================= */
/** @brief display statistics for #EGsimVRPoisson_t */
#if EG_SIM_DEBUG <= DEBUG
#define EGsimVRPStats(__EGvrp) do{\
	size_t __EGvrpi = 0;\
	fprintf(stderr,"stats for %p:\n",__EGvrp);\
	for( ; __EGvrpi < __EGvrp->nint ; __EGvrpi++){\
		fprintf(stderr,"l %.2lf rate %.2lf n %6zu avg %.5lf\n",\
						__EGvrp->interval[__EGvrpi], __EGvrp->rate[__EGvrpi],\
						__EGvrp->ngen[__EGvrpi], \
						__EGvrp->sumxi[__EGvrpi]/__EGvrp->ngen[__EGvrpi]);}\
	EGfree(__EGvrp->ngen);\
	EGfree(__EGvrp->sumxi);}while(0)
#else
#define EGsimVRPStats(__EGvrp)
#endif
/* ========================================================================= */
/** @brief clear an #EGsimVRPoisson_t structure */
#define EGsimVRPClear(__VRP) do{\
	EGsimVRPoisson_t*const __EGVRP = (__VRP);\
	EGsimVRPStats(__EGVRP);\
	EGfree(__EGVRP->interval);\
	EGfree(__EGVRP->rate);\
	EGfree(__EGVRP->weight);}while(0)
/* ========================================================================= */
/** @brief structure to hold data for random variables on two parameters */
typedef struct
{
	double a;					/**< @brief first parameter */
	double b;					/**< @brief second parameter */
	EGrandState_t g;	/**< @brief Random number generator for the node */
	size_t ngen;
	double sumxi;
} EGsimRData_t;
/* ========================================================================= */
/** @brief load interval description from file, the format of the file is the
 * following:
 * nintervals
 * interval_length_i rate_interval_i
 * @param file from where we will read the description
 * @param data where to store the information
 * @return zero on success, non-zero otherwise.
 * */
int EGsimVRPLoadFile(EGsimVRPoisson_t*const data,FILE*file);
/* ========================================================================= */
/** @brief Initialize an #EGsimRData_t structure */
#define EGsimRDInit(__RD) do{\
	EGsimRData_t*const __EGRD = (__RD);\
	memset(__EGRD,0,sizeof(EGsimRData_t));\
	EGrandInit(&(__EGRD->g));}while(0)
/* ========================================================================= */
/** @brief display statistics for #EGsimRData_t */
#if EG_SIM_DEBUG <= DEBUG
#define EGsimRDStats(__EGrd) do{\
	fprintf(stderr,"stats for %p:\n",__EGrd);\
		fprintf(stderr,"n %6zu avg %.5lf\n",\
						__EGrd->ngen, __EGrd->sumxi/__EGrd->ngen);}while(0)
#else
#define EGsimRDStats(__EGrd)
#endif
/* ========================================================================= */
/** @brief clear an #EGsimRData_t structure */
#define EGsimRDClear(__RD) do{\
	EGsimRData_t*const __EGRD = (__RD);\
	EGsimRDStats(__EGRD);\
	memset(__EGRD,0,sizeof(EGsimRData_t));\
	}while(0)
/* ========================================================================= */
/** @brief type of distribution functions, the first and second parameters are
 * double values, and the third parameter is the random seed to be used */
typedef double (*EGsimDist_f) (const double,void*const);
/* ========================================================================= */
/** @brief Exponential distribution function .
 * @param t time (unused)
 * @param data pointer to an #EGsimRData_t structure */
double EGsimExp(const double t,void*const data);
/* ========================================================================= */
/** @brief Uniform distribution function 
 * @param t time (unused)
 * @param data pointer to an #EGsimRData_t structure */
double EGsimUniform(const double t,void*const data);
/* ========================================================================= */
/** @brief Normal distribution function 
 * @param t time (unused)
 * @param data pointer to an #EGsimRData_t structure */
double EGsimNormal(const double t, void*const data);
/* ========================================================================= */
/** @brief variable rate poisson process
 * @param t defining the rate to start with.
 * @param data pointer to an #EGsimVRPoisson_t structure */
double EGsimVRPoisson(const double t, void*const data);
/* ========================================================================= */
/** @brief structure that holds a node in the network */
typedef struct 
{
	EGeDgraphNode_t node;	/**< @brief Actual node storing the network information */
	EGrandState_t g;			/**< @brief random state variable for edge/selection */
	EGeList_t queue;			/**< @brief Head of the incomming queue */
	double start_time;		/**< @brief Time of first agent entering this node */
	double last_time;			/**< @brief Last time statistics where updated */
	double avg_cycle;			/**< @brief Average cycle time of served agents */
	double avg_queue;			/**< @brief Average queue length (up to last update time, 
															and starting from #EGsimNode_t::start_time ) */
	double avg_usage;			/**< @brief Average percentage of used time */
	double avg_q5;				/**< @brief Average time of queue with 5 or more clients*/
	double avg_wtime;			/**< @brief Average waiting time on queue */
	EGsimDist_f gen;			/**< @brief Distribution function for the process time */
	void*data;						/**< @brief asociated data for generator */
	EGsimRandomType_t rtype;/**< @brief random variable type */
	EGsimNodeType_t type;	/**< @brief Type of the node */
	unsigned tot_serv;		/**< @brief servers available at the node */
	unsigned ava_serv;		/**< @brief Total available servers in current time */
	unsigned queue_sz;		/**< @brief Current length of the input queue */	
	unsigned num;					/**< @brief Number of agents that have pass through the
															node */
} EGsimNode_t;
/* ========================================================================= */
/** @brief structure that holds an agent going trough the network */
typedef struct 
{
	dbl_EGeHeapCn_t heap_cn;/**< connector in the heap containing the agent */
	EGeList_t queue_cn;		/**< Connector in the queue holding it */
	EGsimNode_t* node;		/**< Node where this agent is being served or queue */
	double queue_time;		/**< Time spend waiting on queue */
	double service_time;	/**< Time spend being serviced on the network */
	double last_time;			/**< Last time when statistics where updated */
} EGsimAgent_t;
/* ========================================================================= */
/** @brief structure holding the network being simulated as well as the heap
 * containing the events to be provessed */
typedef struct 
{
	EGeDgraph_t G;		/**< Actual network being simulated */
	dbl_EGeHeap_t hp;	/**< Heap containing events to be processed */
	unsigned agent_sz;/**< Number of agents (currently) traversing the network */
	unsigned agent_tot;/**< Agents that traversed the network */
	double cur_time;	/**< Current time on the system */
	double max_time;	/**< Horizon where to stop the simulation */
	EGmemSlabPool_t mp;/**< Memory pool holding the agents in the system */
	EGsimNode_t*all_nodes;/**< array containing all nodes in the network */
	EGsimEdge_t*all_edges;/**< array containing all edges in the network */
} EGsim_t;
/* ========================================================================= */
/** @brief Read a file describing a simulation network.
 * @param sim #EGsim_t structure where we will load the network, #EGsimInit
 * should have been called before.
 * @param file from where we should read the graph.
 * @return zero on success, non-zero otherwise 
 * @note The random state will be taken from the global seed also, each node
 * has an independent random stream that is 2^128 steps away from the random
 * stream of the previous node. 
 * */
int EGsimLoadFile(EGsim_t*const sim,FILE*file); 
/* ========================================================================= */
/** @brief Given a simulation network, run the simulation from
 * #EGsim_t::cur_time until #EGsim_t::max_time
 * @param sim #EGsim_t structure where we will run the simulation.
 * @return zero on success, non-zero otherwise.
 * @note The random state will be taken from the global seed also, each node
 * has an independent random stream that is 2^128 steps away from the random
 * stream of the previous node. 
 * */
int EGsim(EGsim_t*const sim);
/* ========================================================================= */
/** @brief initialize an agent as a new agent starting at c_time.
 * @param c_time time when this agent is being born 
 * @param agent agent to set */
#define EGsimSetAgent(agent,c_time) ({\
	EGsimAgent_t*const __EGsimA = (agent);\
	__EGsimA->last_time = (c_time);\
	dbl_EGeHeapCnInit(&(__EGsimA->heap_cn));\
	EGeListInit(&(__EGsimA->queue_cn));\
	__EGsimA->node = 0;\
	__EGsimA->queue_time = __EGsimA->service_time = 0.0;})
/* ========================================================================= */
/** @brief Clear a structure of type #EGsim_t
 * @param sim structure to initialize */
#define EGsimClear(sim) do{\
	EGsim_t*const __EGsim = (sim);\
	dbl_EGeHeapCn_t* __EGsimHcn;\
	unsigned __EGsimi = __EGsim->G.n_nodes;\
	while((__EGsimHcn = dbl_EGeHeapGetMin(&(__EGsim->hp)))){\
		dbl_EGeHeapDel(&(__EGsim->hp),__EGsimHcn);\
		EGmemSlabPoolFree(__EGsimHcn);}\
	dbl_EGeHeapResize(&(__EGsim->hp),0);\
	while(__EGsimi--){EGsimNodeClear(__EGsim->all_nodes+__EGsimi);}\
	EGeDgraphClear(&(__EGsim->G));\
	EGfree(__EGsim->all_nodes);\
	EGfree(__EGsim->all_edges);\
	EGmemSlabPoolClear(&(__EGsim->mp));}while(0)
/* ========================================================================= */
/** @brief Initialize a structure of type #EGsim_t 
 * @param sim structure to initialize */
#define EGsimInit(sim) do{\
	EGsim_t*const __EGsim = (sim);\
	EGeDgraphInit(&(__EGsim->G));\
	dbl_EGeHeapInit(&(__EGsim->hp));\
	__EGsim->hp.d = 2;\
	dbl_EGeHeapResize(&(__EGsim->hp),1024);\
	__EGsim->agent_sz = __EGsim->agent_tot = 0;\
	__EGsim->cur_time = __EGsim->max_time = 0.0;\
	__EGsim->all_nodes = 0;\
	__EGsim->all_edges = 0;\
	EGmemSlabPoolInit(&(__EGsim->mp),sizeof(EGsimAgent_t), 0, 0);}while(0)
/* ========================================================================= */
/** @brief Intialize a structure of type #EGsimEdge_t
 * @param e pointer to the structure to initialize */
#define EGsimEdgeInit(e) do{\
	EGsimEdge_t*const __EGsimE = (e);\
	EGeDgraphEdgeInit(&(__EGsimE->edge));}while(0)
/* ========================================================================= */
/** @brief Clear a structure of type #EGsimEdge_t
 * @param e pointer to the structure to clear */
#define EGsimEdgeClear(e) do{\
	EGsimEdge_t*const __EGsimE = (e);\
	EGeDgraphEdgeClear(&(__EGsimE->edge));}while(0)
/* ========================================================================= */
/** @brief Initialize a structure of type #EGsimNode_t
 * @param nod pointer to the structure */
#define EGsimNodeInit(nod) do{\
	EGsimNode_t*const __EGsimN = (nod);\
	EGeDgraphNodeInit(&(__EGsimN->node));\
	EGeListInit(&(__EGsimN->queue));\
	__EGsimN->start_time = __EGsimN->last_time = __EGsimN->avg_cycle = __EGsimN->avg_queue = __EGsimN->avg_usage = __EGsimN->avg_q5 = __EGsimN->avg_wtime =  0.0 ;\
	__EGsimN->tot_serv= __EGsimN->ava_serv= __EGsimN->queue_sz = __EGsimN->num = 0;\
	__EGsimN->type = EGsimT;\
	__EGsimN->rtype = EGsimRV_novar;\
	__EGsimN->data=0;\
	EGrandInit(&(__EGsimN->g));\
	__EGsimN->gen=0;}while(0)
/* ========================================================================= */
/** @brief Clear a structure of type #EGsimNode_t
 * @param __nod pointer to the structure */
#define EGsimNodeClear(__nod) do{\
	EGsimNode_t*const __EGsimN = (__nod);\
	switch(__EGsimN->rtype){\
		case EGsimRV_novar:\
			break;\
		case EGsimRV_2param:\
			EGsimRDClear((__EGsimN->data));\
			EGfree(__EGsimN->data);\
			break;\
		case EGsimRV_VRP:\
			EGsimVRPClear((__EGsimN->data));\
			EGfree(__EGsimN->data);\
			break;\
		default:\
			EXIT(1,"Unknown random variable type %d!",__EGsimN->rtype);\
			break;}\
	EGeDgraphNodeClear(&(__EGsimN->node));}while(0)
/* ========================================================================= */
/** @} */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/* ========================================================================= */
/** @defgroup EGslin_kern Simple Lin-Kernigham 
 *
 * Here we define a simple implementation of the lin-kernighan k-opt heuristic
 * for the TSP. The ideas were taken from ``Finding Tours in the TSP'' of
 * Applegate et al.
 *
 * For simplicity we choose to implement the array structure for managing
 * <code>flips</code>, with the reverse bit version.
 *
 * @version 0.0.1
 * @par History:
 * - 2006-09-06
 * 						- First implementation.
 * */
/** @file
 * @ingroup EGslin_kern */
/** @addtogroup EGslin_kern */
/** @{ 
 * @example eg_slk.ex.c
 * This is a simple example of the usage of this simulator
 * @ref EGsimula */
/* ========================================================================= */
#ifndef __EG_SLK_H__
#define __EG_SLK_H__
/* ========================================================================= */
/** @brief structure to hold a (sub-)tour that allow flip operations. */
typedef struct EGflipper_t
{
	int* tour;	/**< hold the order (or reverse order) of the elements in this 
									 tour, from zero to #EGflipper_t::sz - 1  */
	int* inv;		/**< hold the inverse of the ordering, the values range from zero 
									 to #EGflipper_t::sz */
	int* map;		/**< map the internal id (from zero to #EGflipper_t::sz - 1) to 
									 their external numbering. */ 
	size_t sz;	/**< number of elements in this sub-tour */
	unsigned reverse;/**< if set to zero, then the tour has the real ordering, otherwise, it has the reverse ordering of the tour. */ 
	size_t max_sz;	/**< size of the arrays #EGflipper_t::tour, #EGflipper_t::inv and #EGflipper_t::map */
} EGflipper_t;

/* ========================================================================= */
/** @brief debug level */
#define EG_SLK_DEBUG 100

/* ========================================================================= */
/** @brief verbosity level */
#define EG_SLK_VERB 100

/* ========================================================================= */
/** @brief if non-zero, then do a full neighbour search, otherwise, do a first
 * improvement search. */
#define EG_SLK_FULL_SEARCH 0
/* ========================================================================= */
/** @brief structure holding the data related to our instance. It mainly store
 * the cost function. */
typedef struct EGslkData_t
{
	size_t dim; 		/**< Number of cities in the problem */
	int **cost;			/**< double array containing costs of all edges. */
	int *best_tour;	/**< best tour seen so-far */
	int *curr_tour;	/**< Tour that we are using to work */
	int best_val;		/**< value of the best tour */
	int capacity;		/**< Capacity of the trucks */
	int depot;			/**< Depot for the problem */
	int *demand;		/**< Demand on each node */
	double* x;			/**< X-position of the nodes */
	double* y;			/**< Y-position of the nodes */
} EGslkData_t;

/* ========================================================================= */
/** @brief initialize an #EGslkData_t structure.
 * @param data pointer to the structure to initialize */
#define EGslkDataInit(data) (memset(data,0,sizeof(EGslkData_t)))

/* ========================================================================= */
/** @brief clear an #EGslkData_t structure, and free all internal memory.
 * @param data pointer to the structure to initialize */
void EGslkDataClear(EGslkData_t*const data);

/* ========================================================================= */
/** @brief load a TSPLIB95 file format into a EGslkData_t structure
 * @param data pointer to the structure to initialize 
 * @param input pointer from where we will read the data.
 * @return zero on success, non-zero otherwise. */
int EGslkDataLoadTSPLIB95(EGslkData_t*const data,EGioFile_t*input);

/* ========================================================================= */
/** @brief Given two nodes (in #EGslkData_t numbering), and a data structure,
 * return the cost of the edge between the two nodes.
 * @param a tail of the edge.
 * @param b head of the edge.
 * @param data pointer to the data.
 * @return cost of the requested edge.
 * */
int EGslkEdgeCost(EGslkData_t*const data,const int a,const int b);

/* ========================================================================= */
/** @brief Given an initialized flipper structure, and a global data structure,
 * perform a 2-opt run.
 * @param data pointer to the problem data.
 * @param flip pointer to the flipper structure holding the tour.
 * @return zero on success, non-zero otherwise.
 * @note Note that a local-2-opt-optimum is returned in the given flipper, and
 * the original tour stored in the flipper is lost.
 * */
int EGslk2opt(EGslkData_t*const data,EGflipper_t*const flip);

/* ========================================================================= */
/** @brief, given a tour, compute its value 
 * @param tour array containing the tour.
 * @param sz length of the tour.
 * @param data pointer to the problem data.
 * @return the value of the given tour.
 * */
int EGslkTourValue(EGslkData_t*const data,const int*const tour,const size_t sz);

/* ========================================================================= */
/** @brief given an element in the tour (in internal numbering) it return the 
 * next element in the tour (in internal numbering).
 * @param node id of the node from which we want its successor.
 * @param flip structure to initialize 
 * @return the next element in the tour from node 
 * */
int EGslkGetNext(EGflipper_t*const flip,const int node);

/* ========================================================================= */
/** @brief given an element in the tour (in internal numbering) it return the 
 * previous element in the tour (in internal numbering).
 * @param node id of the node from which we want its predecesor.
 * @param flip structure to initialize
 * @return the previous element in the tour from node
 * */
int EGslkGetPrev(EGflipper_t*const flip,const int node);

/* ========================================================================= */
/** @brief given a #EGflipper_t structure, and two nodes a,b in the structure,
 * flip the segment a,b in the tour.
 * @param a id of the begin of the segment to flip.
 * @param b id of the end of the segment to flip.
 * @param flip structure holding the tour.
 * @return zero on success, non-zero otherwise.
 * @note that EGslkFlip(flip,a,b) is different from EGslkFlip(flip,b,a) .
 * */
int EGslkFlip(EGflipper_t*const flip,const int a, const int b);

/* ========================================================================= */
/** @brief Load a tour into a #EGflipper_t structure.
 * @param sz length of the tour.
 * @param tour array of length sz that we want to load.
 * @param flip strucutre where we will load the tour.
 * @return zero on success, non-zero otherwise.
 * @note this function will resize automatically the #EGflipper_t structure if
 * necesary.
 * */
int EGflipperLoadTour(EGflipper_t*const flip,const int*const tour,size_t const sz);

/* ========================================================================= */
/** @brief Load from a #EGflipper_t structure to an array the implicit tour.
 * @param tour array where we will load the tour.
 * @param flip strucutre holding the tour.
 * @return zero on success, non-zero otherwise.
 * */
int EGflipperGetTour(EGflipper_t*const flip,int*const tour);

/* ========================================================================= */
/** @brief Return the cost of the tour stored in the flipper structure.
 * @param flip strucutre holding the tour.
 * @param data pointer structure. 
 * @return zero on success, non-zero otherwise.
 * */
int EGflipperGetCost(EGslkData_t*const data,EGflipper_t*const flip);

/* ========================================================================= */
/** @brief Display a flipper structure to the given file.
 * @param flip strucutre holding the tour.
 * @param out where to print the structure
 * @return zero on success, non-zero otherwise.
 * */
int EGflipperDisplay(EGflipper_t*const flip,EGioFile_t* out);

/* ========================================================================= */
/** @brief Given a flip, kick it, to obtain a different starting point for
 * lin-kernighan. This idea, and the special kick we use is due to  Martin,
 * Otto and Felten (1991,1992). The kick that we are using is a so-called
 * double bridge.
 * @param flip strucutre holding the tour.
 * @return zero on success, non-zero otherwise.
 * */
int EGslkKick(EGflipper_t*const flip);

/* ========================================================================= */
/** @brief Initialize a #EGflipper_t structure (with no space for storing
 * tours). 
 * @param flip structure to initialize */
#define EGflipperInit(flip) (memset((flip),0,sizeof(EGflipper_t)))

/* ========================================================================= */
/** @brief Leave a #EGflipper_t structure as returned by #EGflipperInit
 * function, but freeing any internal memory if needed 
 * @param flip structure to initialize */
#define EGflipperClear(flip) ({\
	EGflipper_t*const __EGslkflip = (flip);\
	if(__EGslkflip->tour) EGfree(__EGslkflip->tour);\
	if(__EGslkflip->inv) EGfree(__EGslkflip->inv);\
	if(__EGslkflip->map) EGfree(__EGslkflip->map);\
	memset(__EGslkflip,0,sizeof(EGflipper_t));})

/* ========================================================================= */
/** @brief resize the maximum capacity of a #EGflipper_t structure 
 * @note Note that if the new size is smaller than the current size of the
 * stored tour, then the stored tour is lost, and the internal size will be
 * reset to zero.
 * @param new_sz new size for the internal arrays.
 * @param flip structure to initialize */
void EGflipperResize(EGflipper_t*const flip,const size_t new_sz);

/* ========================================================================= */
/** @brief remove an element from the flipper structure.
 * @param node internal ID of the element to remove.
 * @param flip structure containing a route.
 * @return zero on success, non-zero otherwise. */
int EGflipperRemoveNode(EGflipper_t*const flip,const int node);

/* ========================================================================= */
/** @brief add an element from the flipper structure.
 * @param node external ID of the element to add.
 * @param flip structure containing a route.
 * @return zero on success, non-zero otherwise. */
int EGflipperAddNode(EGflipper_t*const flip,const int node);

/* ========================================================================= */
/** @brief Copy a flipper structure to another */
void EGflipperCopy(const EGflipper_t*const src,EGflipper_t*const dst);

/* ========================================================================= */
/** @} */
/* end of eg_slk.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGpermIt All Permutations Iterator
 *
 * Here we define an implementation of knuth'__EGs plain changes iterator  for
 * permutations of \f$n\f$ different elements as defined in 
 * ``The Art of Computer Programming, Chapter 7.2.1.2''.
 * We use an algorithms that perform single swaps in each step, the last
 * position of the swap is stored.
 * */
/** @file 
 * @ingroup EGpermIt */
/** @addtogroup EGpermIt */
/** @{ */
/** @example eg_perm_it.ex.c
 * This is a simple example of the usage of heaps using @ref EGpermIt */
/* ========================================================================= */
#ifndef __EG_PERMIT__
#define __EG_PERMIT__
/* ========================================================================= */
/** @brief Debug level for the heap */
#define EG_PERMIT_DBG 0

/* ========================================================================= */
/** @brief Structure to store the information relevant to the permutation 
 * iterator. */
typedef struct EGpermIt_t
{
	int sz;					/**< @brief Number of elements to permute */
	int changed_pos;/**< @brief position of the last bit changed */
	int*tuple;			/**< @brief Current binary tuple being visited */
	int*c_focus;		/**< @brief Internal information */
	int*o_focus;		/**< @brief Internal information */
}
EGpermIt_t;

/* ========================================================================= */
/** @brief Reset an initialized permutation iterator to the zero position.
 * @param __gc pointer to a permutation iterator structure (#EGpermIt_t) 
 * */
#define EGpermItReset(__gc) do{\
	EGpermIt_t*const __EGgcit2 = (__gc);\
	register int __EGgci = __EGgcit2->sz;\
	while(__EGgci--){__EGgcit2->tuple[__EGgci] = __EGgci;\
	__EGgcit2->o_focus[__EGgci]=1;\
	__EGgcit2->c_focus[__EGgci]=0;}\
	__EGgcit2->changed_pos=0;}while(0)

/* ========================================================================= */
/** @brief Initialize a binary permutation iterator, and set the iterator to the
 * zero position.
 * @param __gc pointer to a permutation iterator structure (#EGpermIt_t) 
 * @param __sz number of bits to be used in the iterator.
 * */
#define EGpermItInit(__gc,__sz) do{\
	EGpermIt_t*const __EGgcit = (__gc);\
	const int __EGgcsz = __EGgcit->sz = ((int)(__sz));\
	__EGgcit->tuple = EGsMalloc(int,__EGgcsz);\
	__EGgcit->o_focus = EGsMalloc(int,__EGgcsz);\
	__EGgcit->c_focus = EGsMalloc(int,__EGgcsz);\
	EGpermItReset(__EGgcit);}while(0)

/* ========================================================================= */
/** @brief free all internally allocated memory for the given #EGpermIt_t
 * structure.
 * @param __gc pointer to a permutation iterator structure (#EGpermIt_t) 
 * */
#define EGpermItClear(__gc) do{\
	EGpermIt_t*const __EGgcit = (__gc);\
	EGfree(__EGgcit->tuple);\
	EGfree(__EGgcit->o_focus);\
	EGfree(__EGgcit->c_focus);\
	memset(__EGgcit,0,sizeof(EGpermIt_t));}while(0)

/* ========================================================================= */
/** @brief Return the number of bits for the given permutation iterator 
 * @param __gc pointer to a permutation iterator structure (#EGpermIt_t) 
 * @return number of bits for the iterator
 * */
#define EGpermItGetSize(__gc) ((const int)((__gc)->sz))

/* ========================================================================= */
/** @brief Return a constant pointer to the current tuple 
 * @param __gc pointer to a permutation iterator structure (#EGpermIt_t) 
 * @return pointer to an array containing the current tuple */
#define EGpermItGetTuple(__gc) ((const int*const)((__gc)->tuple))

/* ========================================================================= */
/** @brief return which position in the permutation changed in the last
 * iteration.
 * @param __gc pointer to a permutation iterator structure (#EGpermIt_t) 
 * */
#define EGpermItGetChange(__gc) ((const int)((__gc)->changed_pos))

/* ========================================================================= */
/** @brief choose a macro or function definition of #EGpermItNext */
#define __PERM_IT_NO_INLINE__ 0
/* ========================================================================= */
/** @brief move to the next permutation, if no next string exists (i.e. we
 * finish the loop), return 0, otherwise return 1.
 * @param __EGprit pointer to a permutation iterator structure (#EGpermIt_t) 
 * @return zero if no next string exists, otherwise 1.
 * */
#if __PERM_IT_NO_INLINE__
int EGpermItNext(EGpermIt_t*const __EGprit);
#else
#define EGpermItNext(__prit) ({\
	EGpermIt_t*const __EGprit = (__prit);\
	int*const __EGc = __EGprit->c_focus;\
	int*const __EGo = __EGprit->o_focus;\
	int*const __EGtuple = __EGprit->tuple;\
	int __EGitmp, __EGj=__EGprit->sz-1, __EGs=0, __EGpos=0;\
	int  __EGq=__EGc[__EGj]+__EGo[__EGj];\
	int __EGrval = 1;\
	/* find where we should make the following switch */\
	while(__EGq<0 || __EGq>__EGj)\
	{\
		if(__EGq>__EGj)\
		{\
			if (!__EGj){\
				__EGrval= 0;\
				break;}\
			__EGs+=1;\
		}\
		__EGo[__EGj]=-__EGo[__EGj];\
		__EGj-=1;\
		__EGq=__EGc[__EGj]+__EGo[__EGj];\
	}\
	/* now we just switch positions __EGj-c_j+__EGs and __EGj-__EGq+__EGs */\
	if(__EGrval){\
		__EGprit->changed_pos = __EGpos = __EGc[__EGj] > __EGq ? __EGj-__EGc[__EGj]+__EGs:__EGj-__EGq+__EGs;\
		__EGc[__EGj] = __EGq;\
		__EGitmp = __EGtuple[__EGpos];\
		__EGtuple[__EGpos] = __EGtuple[__EGpos+1];\
		__EGtuple[__EGpos+1] = __EGitmp;\
	}\
	/* and we are done */\
	__EGrval;})
#endif
	
/* ========================================================================= */
/** @} */
/* end of eg_gcit.h */
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef __EG_LPNUM_MPF__
#define __EG_LPNUM_MPF__
#ifdef HAVE_LIBGMP
/** @file
 * @ingroup EGlpNum */
/** @addtogroup EGlpNum */
/** @{ */
/* ========================================================================= */
/** @brief This is the smallest difference (with the current precision) that can
 * be distinguished betwen 1.0 and it's clossest representable number, in some
 * sense it is the absolute minimum epsilon for comparisons */
extern mpf_t mpf_eps;

/* ========================================================================= */
/** extern definitions of constaants for different set-ups */
extern const mpf_t __zeroLpNum_mpf__;
extern const mpf_t __oneLpNum_mpf__;
extern const mpf_t __MaxLpNum_mpf__;
extern const mpf_t __MinLpNum_mpf__;
#define mpf_zeroLpNum __zeroLpNum_mpf__
#define mpf_oneLpNum  __oneLpNum_mpf__
#define mpf_epsLpNum  mpf_eps
#define mpf_MaxLpNum  __MaxLpNum_mpf__
#define mpf_MinLpNum  __MinLpNum_mpf__

/* ========================================================================= */
/** @brief Given a double exp, compute \f$ e^{exp} \f$ and store it in the given
 * mpf_t number.
 * @param exp double exponent to be used.
 * @param num mpf_t number where to store the result.
 * */
#define mpf_EGlpNumEpow(num,exp) ({\
	unsigned int __i = 0;\
	int __lsgn = (exp)<0 ? 1:0;\
	mpf_t __ntmp,__res,__lexp,__err;\
	mpf_init_set_d(__lexp,exp);\
	if(__lsgn) mpf_neg(__lexp,__lexp);\
	mpf_init_set_ui(__ntmp,(unsigned long int)1);\
	mpf_init_set_ui(__res,(unsigned long int)1);\
	mpf_init(__err);\
	mpf_div(__err,__ntmp,__res);\
	while(mpf_cmp(__err,mpf_eps)>0)\
	{\
		mpf_mul(__ntmp,__ntmp,__lexp);\
		mpf_div_ui(__ntmp,__ntmp,(unsigned long int)(++__i));\
		mpf_add(__res,__res,__ntmp);\
		mpf_div(__err,__ntmp,__res);\
	}\
	if(__lsgn) mpf_ui_div(num,(unsigned long int)1,__res);\
	else mpf_set(num,__res);\
	mpf_clear(__ntmp);\
	mpf_clear(__res);\
	mpf_clear(__err);\
	mpf_clear(__lexp);})

/* ========================================================================= */
/** @brief Read from a string a number and store it in the given mpf_t, 
 * @return the number of chars readed from the input string */
#define mpf_EGlpNumReadStr(a,str) ({\
	int __i =0;\
	char __lpstr__[4096];\
	mp_exp_t __lexp;\
	mpf_set_str(a,str,10);\
	mpf_get_str(__lpstr__,&__lexp,10,(size_t)0,a);\
	__i = strlen(__lpstr__);\
	__i;})

/* ========================================================================= */
/** @brief given a mpf_t, write it to a string (to be allocated internally), 
 * and return it. */
#define mpf_EGlpNumGetStr(a) ({\
	char *__out= 0;\
	mp_exp_t __lexp = 0;\
	size_t __pos = 0,__lo = (mpf_cmp_ui(a,(unsigned long)0) < 0) ? 1:0;\
	char __lpstr__[4096];\
	mpf_get_str(__lpstr__,&__lexp,10,(size_t)25,a);\
	__pos = strlen(__lpstr__) + ((size_t)(__lo + 2));\
	__out = EGsMalloc(char,__pos+((size_t)15));\
	if(__lo) sprintf(__out,"-0.");\
	else sprintf(__out,"0.");\
	sprintf(__out+__lo+2,__lpstr__+__lo);\
	if(__pos == 2) __out[1] = '\0';\
	else if(__lexp != 0)\
	{\
		__out[__pos-__lo] = 'e';\
		snprintf(__out+__pos+1-__lo,(size_t)(12-__lo),"%d",(int)__lexp);\
	}\
	__out;})

/* ========================================================================= */
/** @brief given an array of type mpf_t, free it, if the pointer is NULL
 * nothing happen. */
#define mpf_EGlpNumFreeArray(ea) ({\
	size_t __sz = __EGlpNumArraySize(ea);\
	mpf_t* __ptr__ = (ea);\
	while(__sz--) mpf_clear(__ptr__[__sz]);\
	__EGlpNumFreeArray(ea);})


/* ========================================================================= */
/** @brief Reallocate and initialize (if needed) 'size' elements of type 
 * mpf_t and return it, if no more memory, exit(1) */
#define mpf_EGlpNumReallocArray(lptr, lsize) ({ \
	mpf_t** __ptr__ = (lptr); \
	size_t __sz__ = (lsize); \
	size_t *__ntmp__ = (size_t *) *__ptr__; \
	size_t __psz__; \
	/* if no memory allocated before we just call the regular allocator */ \
	if (!*__ptr__) *__ptr__ = mpf_EGlpNumAllocArray (__sz__); \
	else \
	{ \
		/* first check that the previous size is not larger than the current */ \
		__ntmp__--; \
		__psz__ = __ntmp__[0]; \
		if (__psz__ < __sz__) \
		{ \
			/* now we have to do the reallocation */ \
			*__ptr__ = (mpf_t *) __ntmp__; \
			*__ptr__ = EGrealloc(*__ptr__, sizeof(mpf_t) * __sz__ +sizeof(size_t));\
			__ntmp__ = (size_t *) *__ptr__; \
			__ntmp__[0] = __sz__; \
			__ntmp__++; \
			*__ptr__ = (mpf_t *) __ntmp__; \
			for (; __psz__ < __sz__; __psz__++) mpf_init ((*__ptr__)[__psz__]); \
		} \
	} \
})

/* ========================================================================= */
/** @brief Allocate and initialize (if needed) 'size' elements of type mpf_t
 * and return it, if no more memory, exit(1) */
#define mpf_EGlpNumAllocArray(size) ({\
	size_t __i__ = (size);\
	mpf_t *__res = __EGlpNumAllocArray(mpf_t,__i__);\
	while(__i__--) mpf_init(__res[__i__]);\
	__res;})

/* ========================================================================= */
/** @brief set the given number pointer, set its value to the given double.
 * @param var mpf_t where we will store the double value.
 * @param dbl double value to be stored in 'var'.
 * @par Description:
 * This function is intended to set initial values to variables; note that the
 * double is a number and not a pointer to that value, be carefull with this
 * detail. Also, due to implementation details this function can't deal with
 * numbers above 1e158 or smaller than 1e-158. Note also that if the number is
 * writen in the form \f$x=\bar{x}\cdot 2^e\f$ with \f$0.5<|\bar{x}|<1\f$, 
 * then \f$\left|x-\frac{p}{q}\right|<2^{e-64}\f$.
 * */
#define mpf_EGlpNumSet(var, dbl) mpf_set_d(var,(double)(dbl))

/* ========================================================================= */
/** @brief Stores in the first number the ceil value of the second number, i.e.
 * EGlpNumCeil(a,b) <==> a= ceil(b) */
#define mpf_EGlpNumCeil(a, b) mpf_ceil(a,b)

/* ========================================================================= */
/** @brief Stores in the first number the floor value of the second number, i.e.
 * EGlpNumFloor(a,b) <==> a= floor(b) */
#define mpf_EGlpNumFloor(a, b) mpf_floor(a,b)

/* ========================================================================= */
/** @brief store the (multiplicative) inverse of a number to itself, i.e.
 * implement a = 1/a.
 * @param a the number to be inverted. */
#define mpf_EGlpNumInv(a) mpf_ui_div(a,(unsigned long int)1,a)

/* ========================================================================= */
/** @brief Compare if two numbers are equal within a maximum __error.
 * @param a mpf_t first number to compare.
 * @param b mpf_t second number to compare.
 * @return int one in success, zero oterwise.
 * @par Description:
 * Given two numbers 'a','b' return 1 if a == b, otherwise it return 0
 * */
#define mpf_EGlpNumIsEqqual(a,b) (mpf_cmp(a,b) == 0)

/* ========================================================================= */
/** @brief Compare if two numbers are equal within a maximum __error.
 * @param a mpf_t first number to compare.
 * @param b mpf_t second number to compare.
 * @param __error mpf_t maximum difference allowed between both
 * numbers.
 * @return int one in success, zero oterwise.
 * @par Description:
 * Given two numbers 'a','b' and a tolerance '__error',
 * return 1 if |a-b|<= __error, otherwise it return 0.
 * */
#define mpf_EGlpNumIsEqual(a,b,__error) ({\
	mpf_t __lpnum__;int __res__=0;mpf_init(__lpnum__);\
	mpf_sub (__lpnum__, a, b);\
	mpf_abs (__lpnum__, __lpnum__);\
	__res__=(mpf_cmp (__lpnum__, __error) <= 0);\
	mpf_clear(__lpnum__);\
	__res__;\
})

#define mpf_EGlpNumIsNeq(a,b,__error) ({\
	mpf_t __lpnum__;int __res__=0;mpf_init(__lpnum__);\
	mpf_sub (__lpnum__, a, b);\
	mpf_abs (__lpnum__, __lpnum__);\
	__res__=(mpf_cmp (__lpnum__, __error) > 0);\
	mpf_clear(__lpnum__);\
	__res__;\
})

#define mpf_EGlpNumIsNeqZero(a,__error) ({\
	mpf_t __lpnum__;int __res__=0;mpf_init(__lpnum__);\
	mpf_abs (__lpnum__, a);\
	__res__=(mpf_cmp (__lpnum__, __error) > 0);\
	mpf_clear(__lpnum__);\
	__res__;\
})

#define mpf_EGlpNumIsNeqqZero(a)     	(mpf_sgn(a))
#define mpf_EGlpNumIsNeqq(a,b)        (mpf_cmp(a,b)!=0)

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a mpf_t the first number.
 * @param b mpf_t the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a < b, zero
 * otherwise.
 * */
#define mpf_EGlpNumIsLess(a,b) (mpf_cmp(a,b) < 0)

/* ========================================================================= */
/** @brief test if a given number is greater than zero
 * @param a number to test
 * @return int one if success, zero otherwise.
 * */
#define mpf_EGlpNumIsGreatZero(a) (mpf_sgn(a) > 0)

/* ========================================================================= */
/** @brief test if a given number is less than zero
 * @param a number to test
 * @return int one if success, zero otherwise.
 * */
#define mpf_EGlpNumIsLessZero(a) (mpf_sgn(a) < 0)

/* ========================================================================= */
/** @brief test if the sum of the first two numbers is less thatn the third
 * number.
 * @param a mpf_t the first number.
 * @param b mpf_t the second number
 * @param c mpf_t the third number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given a,b, and c, return nonzero if (a + b < c), zero toherwise.
 * */
#define mpf_EGlpNumIsSumLess(a, b, c) ({\
	mpf_t __lpnum__;int __res__=0;mpf_init(__lpnum__);\
	mpf_add (__lpnum__, a, b);\
	__res__=(mpf_cmp (__lpnum__, c) < 0);\
	mpf_clear(__lpnum__);\
	__res__;\
})

/* ========================================================================= */
/** @brief test if the diference of the first two numbers is less thatn the 
 * third number.
 * @param a mpf_t the first number.
 * @param b mpf_t the second number
 * @param c mpf_t the third number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given a,b, and c, return nonzero if (a - b < c), zero toherwise.
 * */
#define mpf_EGlpNumIsDiffLess(a, b, c) ({\
	mpf_t __lpnum__;int __res__=0;mpf_init(__lpnum__);\
	mpf_sub (__lpnum__, a, b);\
	__res__=(mpf_cmp (__lpnum__, c) < 0);\
	mpf_clear(__lpnum__);\
	__res__;\
})

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a mpf_t the first number.
 * @param b double the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a < b, zero
 * otherwise.
 * */
#define mpf_EGlpNumIsLessDbl(a,b) (mpf_cmp_d(a,((double)(b))) < 0)

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a mpf_t the first number.
 * @param b double the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a > b, zero
 * otherwise.
 * */
#define mpf_EGlpNumIsGreaDbl(a,b) (mpf_cmp_d(a,((double)(b))) > 0)

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a mpf_t the first number.
 * @param b mpf_t the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a <= b, zero
 * otherwise.
 * */
#define mpf_EGlpNumIsLeq(a,b) (mpf_cmp(a,b) <= 0)

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param a mpf_t source number (it won't change value).
 * @param b mpf_t source number (it won't change value).
 * @param c mpf_t denominator of the difference (it won't change value).
 * @param d mpf_t where to store the value .
 * @par Description:
 * Set @f$a = \frac{b - c}{d} @f$ */
#define mpf_EGlpNumCopyDiffRatio(a, b, c, d) ({\
	mpf_sub (a, b, c);\
	mpf_div (a, a, d);\
})

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param a mpf_t source number (it won't change value).
 * @param b mpf_t source number (it won't change value).
 * @param dest mpf_t where to store the value stored in 'orig'.
 * @par Description:
 * Set dest = a - b */
#define mpf_EGlpNumCopyDiff(dest,a,b) mpf_sub(dest,a,b)

/* ========================================================================= */
/** @brief copy the value of the sum of the second and third parameter
 * @param a mpf_t source number (it won't change value).
 * @param b mpf_t source number (it won't change value).
 * @param dest mpf_t where to store the sum.
 * @par Description:
 * Set dest = a + b */
#define mpf_EGlpNumCopySum(dest,a,b) mpf_add(dest,a,b)

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param orig mpf_t source number (it won't change value).
 * @param dest mpf_t where to store the value stored in 'orig'.
 * @par Description:
 * Given two numbers copy the values in 'orig', into 'dest'.
 * */
#define mpf_EGlpNumCopy(dest,orig) mpf_set(dest,orig)

/* ========================================================================= */
/** @brief change the fist number to the maximum between itself and the 
 * absolute value of the second.
 * @param orig mpf_t source number (it won't change value).
 * @param dest mpf_t where to store the value stored in 'orig'.
 * @par Description:
 * implement dest = max(dest,abs(orig))
 * */
#define mpf_EGlpNumSetToMaxAbs(dest, orig) ({\
	mpf_t __lpnum__;mpf_init(__lpnum__);\
	mpf_abs (__lpnum__, orig);\
	if (mpf_cmp (dest, __lpnum__) < 0) mpf_set (dest, __lpnum__);\
	mpf_clear(__lpnum__);})

#define mpf_EGlpNumSetToMinAbs(dest, orig) ({\
	mpf_t __lpnum__;mpf_init(__lpnum__);\
	mpf_abs (__lpnum__, orig);\
	if (mpf_cmp (dest, __lpnum__) > 0) mpf_set (dest, __lpnum__);\
	mpf_clear(__lpnum__);})

/* ========================================================================= */
/** @brief copy the square of the second argument, divided by the third 
 * argument into the first argument.
 * @param dest mpf_t where to store the result
 * @param orig mpf_t second parameter
 * @param den mpf_t third parameter
 * @par Description:
 * compute dest = (orig*orig)/den
 * */
#define mpf_EGlpNumCopySqrOver(dest, orig, den) ({\
	mpf_mul (dest, orig, orig);\
	mpf_div (dest, dest, den);\
})

/* ========================================================================= */
/** @brief copy the value of the absolute value of the second parameter to the 
 * first parameter.
 * @param orig mpf_t source number (it won't change value).
 * @param dest mpf_t where to store the absolute value stored
 * in 'orig'.
 * @par Description:
 * Given a number 'orig', copy its absolute value to 'dest'. i.e.
 * dest = |orig|
 * */
#define mpf_EGlpNumCopyAbs(dest,orig) mpf_abs(dest,orig)

/* ========================================================================= */
/** @brief copy minus the value of the second parameter to the 
 * first parameter.
 * @param orig mpf_t the source number (it won't change value).
 * @param dest mpf_t where to store minus the value stored
 * in 'orig'.
 * @par Description:
 * Given a number 'orig', copy minus the value to 'dest'. i.e.
 * dest = -orig
 * */
#define mpf_EGlpNumCopyNeg(dest,orig) mpf_neg(dest,orig)

/* ========================================================================= */
/** @brief Set des = op1/op2.
 * @param dest mpf_t where we will store the result.
 * @param op1 mpf_t numerator of the fraction (possibly non an integer)
 * @param op2 mpf_t denominator of the fraction (possibly non an integer)
 * @par Description:
 *  Set des = op1/op2
 * */
#define mpf_EGlpNumCopyFrac(dest,op1,op2) mpf_div(dest,op1,op2)

/* ========================================================================= */
/** @brief copy the first 'size' values in the second array to the first array.
 * @param orig mpf_t* pointer to the array from where we will copy the
 * values (it won't change value).
 * @param dest mpf_t* pointer to where to store the first 'size' values 
 * stored in 'orig'.
 * @param size unsigned int specifying how many values of 'orig' will be copied
 * onto 'dest'
 * @par Description:
 * This function is provided to (possible) make fast copies of arrays of
 * numbers, the arrays should be of length at least 'size', and the resulting
 * copy is absolutely independent froom the original, any change in one vale of
 * one array won't change values on the other array.
 * */
#define mpf_EGlpNumCopyArray(dest,orig,size) {\
	register unsigned int __i__ = (size);\
	for(;__i__--;)\
	{\
		mpf_set(dest[__i__],orig[__i__]);\
	}\
}

/* ========================================================================= */
/** @brief Sub to a given number the product of two numbers.
 * @param a mpf_t the number that we are going to Sub to.
 * @param b mpf_t value to be multiplyed.
 * @param c mpf_t value to be multiplyed.
 * @par Description:
 * This function implements a = a - b*c, and clearly don't change the value
 * stored in 'b' nor in 'c'.
 * */
#define mpf_EGlpNumSubInnProdTo(a, b, c) ({\
	mpf_t __lpnum__;mpf_init(__lpnum__);\
	mpf_mul (__lpnum__, b, c);\
	mpf_sub (a, a, __lpnum__);\
	mpf_clear(__lpnum__);\
})

/* ========================================================================= */
/** @brief Add to a given number the product of two numbers.
 * @param a mpf_t the number that we are going to add to.
 * @param b mpf_t value to be multiplyed.
 * @param c mpf_t value to be multiplyed.
 * @par Description:
 * This function implements a = a + b*c, and clearly don't change the value
 * stored in 'b' nor in 'c'.
 * */
#define mpf_EGlpNumAddInnProdTo(a, b, c) ({\
	mpf_t __lpnum__;mpf_init(__lpnum__);\
	mpf_mul (__lpnum__, b, c);\
	mpf_add (a, a, __lpnum__);\
	mpf_clear(__lpnum__);\
})

/* ========================================================================= */
/** @brief Substract to a given number the value of the second number.
 * @param a mpf_t the number that we are going to substract to.
 * @param b unsigned int value to be substracted to 'a'.
 * @par Description:
 * This function implements a = a - b, and clearly don't change the value
 * stored in 'b'.
 * */
#define mpf_EGlpNumSubUiTo(a,b) mpf_sub_ui(a,a,((unsigned long)(b)))

/* ========================================================================= */
/** @brief Add to a given number the value of the second number.
 * @param a mpf_t the number that we are going to add to.
 * @param b unsigned int value to be added to 'a'.
 * @par Description:
 * This function implements a = a + b, and clearly don't change the value
 * stored in 'b'.
 * */
#define mpf_EGlpNumAddUiTo(a,b) mpf_add_ui(a,a,((unsigned long)(b)))

/* ========================================================================= */
/** @brief Add to a given number the value of the second number.
 * @param a mpf_t the number that we are going to add to.
 * @param b mpf_t value to be added to 'a'.
 * @par Description:
 * This function implements a = a + b, and clearly don't change the value
 * stored in 'b'.
 * */
#define mpf_EGlpNumAddTo(a,b) mpf_add(a,a,b)

/* ========================================================================= */
/** @brief Substract to a given number the value of the second number.
 * @param a mpf_t the number that we are going to substract
 * from.
 * @param b mpf_t value to be substracted to 'a'.
 * @par Description:
 * This function implements a = a - b, and clearly don't change the value
 * stored in 'b'.
 * */
#define mpf_EGlpNumSubTo(a,b) mpf_sub(a,a,b)

/* ========================================================================= */
/** @brief Multiply a given number by the value of the second number.
 * @param a mpf_t the number that we are going to multiply by
 * the second number and store the result.
 * @param b mpf_t value to be multyply to 'a'.
 * @par Description:
 * This function implements a = a * b, and clearly don't change the value
 * stored in 'b'.
 * */
#define mpf_EGlpNumMultTo(a,b) mpf_mul(a,a,b)

/* ========================================================================= */
/** @brief Divide a given number by the value of the second number.
 * @param a mpf_t the number that we are going to divide by
 * the second number and store the result.
 * @param b mpf_t value to be divide to 'a'.
 * @par Description:
 * This function implements a = a / b, and clearly don't change the value
 * stored in 'b'.
 * */
#define mpf_EGlpNumDivTo(a,b) mpf_div(a,a,b)

/* ========================================================================= */
/** @brief Divide a given number by the value of the second number.
 * @param a mpf_t the number that we are going to divide by
 * the second number and store the result.
 * @param b unsigned int value to be divided to 'a'.
 * @par Description:
 * This function implements a = a / b, and don't change the value
 * stored in 'b'.
 * */
#define mpf_EGlpNumDivUiTo(a,b) mpf_div_ui(a,a,((unsigned long)(b)))

/* ========================================================================= */
/** @brief Multiply a given number by the value of the second number.
 * @param a mpf_t the number that we are going to multiply by
 * the second number and store the result.
 * @param b unsigned int value to be multyply to 'a'.
 * @par Description:
 * This function implements a = a * b, and clearly don't change the value
 * stored in 'b'.
 * */
#define mpf_EGlpNumMultUiTo(a,b) mpf_mul_ui(a,a,((unsigned long)(b)))

/* ========================================================================= */
/** @brief Reset the value of the pointed number to zero.
 * @param a mpf_t the value to be set to zero.
 * @par Descrpition:
 * Reset a to zero, i.e. implements a = 0;
 * */
#define mpf_EGlpNumZero(a) mpf_set_ui(a,(unsigned long)0)

/* ========================================================================= */
/** @brief Reset the value of the pointed number to one.
 * @param a mpf_t value to be set to one.
 * @par Descrpition:
 * Reset a to zero, i.e. implements a = 1;
 * */
#define mpf_EGlpNumOne(a) mpf_set_ui(a,(unsigned long)1)

/* ========================================================================= */
/** @brief Change the sign of the number.
 * @param a mpf_t number we will change sign.
 * @par Descrpition:
 * Change the sign of the given number, i.e. implements a = -a
 * */
#define mpf_EGlpNumSign(a) mpf_neg(a,a)

/* ========================================================================= */
/** @brief return the closest double value of the given pointer number.
 * @param a mpf_t number that we will be transformed to double.
 * @return double the closest double representation of the given number.
 * par Description:
 * return the double number closest in value to the value stored in a.
 * */
#define mpf_EGlpNumToLf(a) mpf_get_d(a)

/* ========================================================================= */
/** @brief initialize the internal memory of a given variable */
#define mpf_EGlpNumInitVar(a) mpf_init(a)

/* ========================================================================= */
/** @brief free the internal memory of a given variable */
#define mpf_EGlpNumClearVar(a) mpf_clear(a)

/* ========================================================================= */
/** @} */
#endif
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef __EG_LPNUM_MPQ__
#define __EG_LPNUM_MPQ__
#ifdef HAVE_LIBGMP
/** @file
 * @brief Interface for rational implementation of the EGlpNum_t type.
 * @par History
 * - 2006-02-01
 * 					- Add verbosity flag for continued fraction conversions.
 * @ingroup EGlpNum */
/** @addtogroup EGlpNum */
/** @{ */
/* ========================================================================= */
/** extern definitions of constaants for different set-ups */
extern const mpq_t __zeroLpNum_mpq__;
extern const mpq_t __oneLpNum_mpq__;
extern const mpq_t __MaxLpNum_mpq__;
extern const mpq_t __MinLpNum_mpq__;
#define mpq_zeroLpNum __zeroLpNum_mpq__
#define mpq_oneLpNum  __oneLpNum_mpq__
#define mpq_epsLpNum  __zeroLpNum_mpq__
#define mpq_MaxLpNum  __MaxLpNum_mpq__
#define mpq_MinLpNum  __MinLpNum_mpq__

/* ========================================================================= */
/** @brief This function read a number in float form and store it in an mpq_t
 * variable, returning how many chars read to create the number, the twist is
 * that it does an 'exact' transformation, in the sense that 0.33333333 will be
 * stored as 33333333/100000000.
 * @param str input string.
 * @param var variable where we will store the number as rational.
 * @return number of reade chars.
 * @par Descriptiom:
 * If the input string doesn't contain a number, 'var' will be set to zero, and
 * the number of readed chars will be zero, we assume that there are no leading
 * empty spaces, (nor tabs), no eschape characters, and trailing zeros are
 * considered as readed, but no the following spaces. 
 * @note
 * This function will only read number in decimal base, in a future release we
 * may include a more general reader. */
int mpq_EGlpNumReadStrXc (mpq_t var,
													char const *str);

/* ========================================================================= */
/** @brief Read from a string a number and store it in the given mpq_t, return
 * the number of chars readed from the input string */
#define mpq_EGlpNumReadStr(a,str) mpq_EGlpNumReadStrXc(a,str)

/* ========================================================================= */
/** @brief given a mpq_t, write it to a string (to be allocated internally), 
 * and return it. */
#define mpq_EGlpNumGetStr(a) ({\
	const size_t __sz = mpz_sizeinbase(mpq_numref(a),10) + mpz_sizeinbase(mpq_denref(a),10) + 3;\
	char *__str=EGsMalloc(char,__sz);\
	mpq_get_str(__str,10,a);})

/* ========================================================================= */
/** @brief given an array of type mpq_t, free it, if the pointer is NULL
 * nothing happen. */
#define mpq_EGlpNumFreeArray(ea) ({\
	size_t __sz = __EGlpNumArraySize(ea);\
	mpq_t* __ptr__ = (ea);\
	while(__sz--) mpq_clear(__ptr__[__sz]);\
	__EGlpNumFreeArray(ea);})


/* ========================================================================= */
/** @brief Reallocate and initialize (if needed) 'size' elements of type 
 * mpq_t and return it, if no more memory, exit(1) */
#define mpq_EGlpNumReallocArray(lptr, lsize) ({\
	mpq_t **__ptr__ = (lptr);\
	size_t *__ntmp__ = (size_t *) *__ptr__, __sz__ = (lsize);\
	size_t __psz__;\
	/* if no memory allocated before we just call the regular allocator */\
	if (!*__ptr__)\
		*__ptr__ = mpq_EGlpNumAllocArray (__sz__);\
	else\
	{\
		/* first check that the previous size is not larger than the current */\
		__ntmp__--;\
		__psz__ = __ntmp__[0];\
		if (__psz__ < __sz__)\
		{\
			/* now we have to do the reallocation */\
			*__ptr__ = (mpq_t *) __ntmp__;\
			*__ptr__ = EGrealloc(*__ptr__,sizeof(mpq_t) * __sz__ + sizeof(size_t));\
			__ntmp__ = (size_t *) *__ptr__;\
			__ntmp__[0] = __sz__;\
			__ntmp__++;\
			*__ptr__ = (mpq_t *) __ntmp__;\
			for (; __psz__ < __sz__; __psz__++) mpq_init ((*__ptr__)[__psz__]);\
		}\
	}\
})

/* ========================================================================= */
/** @brief Allocate and initialize (if needed) 'size' elements of type mpq_t
 * and return it, if no more memory, exit(1) */
#define mpq_EGlpNumAllocArray(size) ({\
	size_t __i__ = (size);\
	mpq_t *__res = __EGlpNumAllocArray(mpq_t,__i__);\
	while(__i__--) mpq_init(__res[__i__]);\
	__res;})

/* ========================================================================= */
/** @brief set the given rational number , to the value to the value of the 
 * given mpf_t, this conversion is done using the continuous fraction method.
 * @param var mpq_t where we will store the value.
 * @param flt mpf_t value to be stored in 'var'.
 * @par Description:
 * This function is intended to set initial values to variables. Note also 
 * that if the number is
 * writen in the form \f$x=\bar{x}\cdot 2^e\f$ with \f$0.5<|\bar{x}|<1\f$, 
 * then \f$\left|x-\frac{p}{q}\right|<2^{e-EGLPNUM_PRECISION}\f$.
 * */
void mpq_EGlpNumSet_mpf (mpq_t var,
												 mpf_t flt);

/* ========================================================================= */
/** @brief set the given number pointer, set its value to the given double.
 * @param var mpq_t where we will store the double value.
 * @param dbl double value to be stored in 'var'.
 * @par Description:
 * This function is intended to set initial values to variables; note that the
 * double is a number and not a pointer to that value, be carefull with this
 * detail. Also, due to implementation details this function can't deal with
 * numbers above 1e158 or smaller than 1e-158. Note also that if the number is
 * writen in the form \f$x=\bar{x}\cdot 2^e\f$ with \f$0.5<|\bar{x}|<1\f$, 
 * then \f$\left|x-\frac{p}{q}\right|<2^{e-64}\f$.
 * */
void mpq_EGlpNumSet (mpq_t var,
										 const double dbl);

/* ========================================================================= */
/** @brief Stores in the first number the ceil value of the second number, i.e.
 * EGlpNumCeil(a,b) <==> a= ceil(b) */
#define mpq_EGlpNumCeil(a, b) ({\
	mpz_cdiv_q (mpq_numref (a), mpq_numref (b), mpq_denref (b));\
	mpz_set_ui (mpq_denref (a), (unsigned long int)1);\
})

/* ========================================================================= */
/** @brief Stores in the first number the floor value of the second number, i.e.
 * EGlpNumFloor(a,b) <==> a= floor(b) */
#define mpq_EGlpNumFloor(a, b) ({\
	mpz_fdiv_q (mpq_numref (a), mpq_numref (b), mpq_denref (b));\
	mpz_set_ui (mpq_denref (a), (unsigned long int)1);\
})

/* ========================================================================= */
/** @brief store the (multiplicative) inverse of a number to itself, i.e.
 * implement a = 1/a.
 * @param a the number to be inverted. */
#define mpq_EGlpNumInv(a) mpq_inv(a,a)

/* ========================================================================= */
/** @brief Compare if two numbers are equal within a maximum error.
 * @param a mpq_t first number to compare.
 * @param b mpq_t second number to compare.
 * @return int one in success, zero oterwise.
 * @par Description:
 * Given two numbers 'a','b' return 1 if a == b, otherwise it return 0
 * */
#define mpq_EGlpNumIsEqqual(a,b) (mpq_equal(a,b))

/* ========================================================================= */
/** @brief Compare if two numbers are equal within a maximum error.
 * @param a mpq_t first number to compare.
 * @param b mpq_t second number to compare.
 * @param error mpq_t maximum difference allowed between both
 * numbers.
 * @return int one in success, zero oterwise.
 * @par Description:
 * Given two numbers 'a','b' and a tolerance 'error',
 * return 1 if |a-b|<= error, otherwise it return 0.
 * */
#define mpq_EGlpNumIsEqual(a,b,error) (mpq_equal(a,b))
#define mpq_EGlpNumIsNeq(a,b,error)   (!(mpq_equal(a,b)))
#define mpq_EGlpNumIsNeqq(a,b)        (!(mpq_equal(a,b)))
#define mpq_EGlpNumIsNeqZero(a,error) (mpq_sgn(a))
#define mpq_EGlpNumIsNeqqZero(a)      (mpq_sgn(a))

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a mpq_t the first number.
 * @param b mpq_t the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a < b, zero
 * otherwise.
 * */
#define mpq_EGlpNumIsLess(a,b) (mpq_cmp(a,b) < 0)

/* ========================================================================= */
/** @brief test if a number is greater than zero
 * @param a number to test
 * @return int one if success, zero otherwise.
 * */
#define mpq_EGlpNumIsGreatZero(a) (mpq_sgn(a) > 0)

/* ========================================================================= */
/** @brief test if a number is less than zero
 * @param a number to test
 * @return int one if success, zero otherwise.
 * */
#define mpq_EGlpNumIsLessZero(a) (mpq_sgn(a) < 0)

/* ========================================================================= */
/** @brief test if the sum of the first two numbers is less thatn the third
 * number.
 * @param a mpq_t the first number.
 * @param b mpq_t the second number
 * @param c mpq_t the third number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given a,b, and c, return nonzero if (a + b < c), zero toherwise.
 * */
#define mpq_EGlpNumIsSumLess(a, b, c) ({\
	mpq_t __lpnum__;int __res__=0;mpq_init(__lpnum__);\
	mpq_add(__lpnum__,a,b);\
	__res__=(mpq_cmp (__lpnum__, c) < 0);\
	mpq_clear(__lpnum__);\
	__res__;\
})

/* ========================================================================= */
/** @brief test if the diference of the first two numbers is less thatn the 
 * third number.
 * @param a mpq_t the first number.
 * @param b mpq_t the second number
 * @param c mpq_t the third number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given a,b, and c, return nonzero if (a - b < c), zero toherwise.
 * */
#define mpq_EGlpNumIsDiffLess(a, b, c) ({\
	mpq_t __lpnum__;int __res__=0;mpq_init(__lpnum__);\
	mpq_sub (__lpnum__, a, b);\
	__res__=(mpq_cmp (__lpnum__, c) < 0);\
	mpq_clear(__lpnum__);\
	__res__;\
})

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a mpq_t the first number.
 * @param b double the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a < b, zero
 * otherwise.
 * */
#define mpq_EGlpNumIsLessDbl(a,b) (mpq_get_d(a) < b)

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a mpq_t the first number.
 * @param b double the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a > b, zero
 * otherwise.
 * */
#define mpq_EGlpNumIsGreaDbl(a,b) (mpq_get_d(a) > b)

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a mpq_t the first number.
 * @param b mpq_t the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a <= b, zero
 * otherwise.
 * */
#define mpq_EGlpNumIsLeq(a,b) (mpq_cmp(a,b) <= 0)

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param a mpq_t source number (it won't change value).
 * @param b mpq_t source number (it won't change value).
 * @param c mpq_t denominator of the difference (it won't change value).
 * @param d mpq_t where to store the value .
 * @par Description:
 * Set @f$a = \frac{b - c}{d} @f$ */
#define mpq_EGlpNumCopyDiffRatio(a, b, c, d) ({\
	mpq_sub (a, b, c);\
	mpq_div (a, a, d);\
})

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param a mpq_t source number (it won't change value).
 * @param b mpq_t source number (it won't change value).
 * @param dest mpq_t where to store the value stored in 'orig'.
 * @par Description:
 * Set dest = a - b */
#define mpq_EGlpNumCopyDiff(dest,a,b) mpq_sub(dest,a,b)

/* ========================================================================= */
/** @brief copy the value of the sum of the second and third parameter
 * @param a mpq_t source number (it won't change value).
 * @param b mpq_t source number (it won't change value).
 * @param dest mpq_t where to store the sum.
 * @par Description:
 * Set dest = a + b */
#define mpq_EGlpNumCopySum(dest,a,b) mpq_add(dest,a,b)

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param orig mpq_t source number (it won't change value).
 * @param dest mpq_t where to store the value stored in 'orig'.
 * @par Description:
 * Given two numbers copy the values in 'orig', into 'dest'.
 * */
#define mpq_EGlpNumCopy(dest,orig) mpq_set(dest,orig)

/* ========================================================================= */
/** @brief change the fist number to the maximum between itself and the 
 * absolute value of the second.
 * @param orig mpq_t source number (it won't change value).
 * @param dest mpq_t where to store the value stored in 'orig'.
 * @par Description:
 * implement dest = max(dest,abs(orig))
 * */
#define mpq_EGlpNumSetToMaxAbs(dest, orig) ({\
	mpq_t __lpnum__;mpq_init(__lpnum__);\
	mpq_abs (__lpnum__, orig);\
	if (mpq_cmp (dest, __lpnum__) < 0)\
		mpq_set (dest, __lpnum__);\
	mpq_clear(__lpnum__);\
})

#define mpq_EGlpNumSetToMinAbs(dest, orig) ({\
	mpq_t __lpnum__;mpq_init(__lpnum__);\
	mpq_abs (__lpnum__, orig);\
	if (mpq_cmp (dest, __lpnum__) > 0)\
		mpq_set (dest, __lpnum__);\
	mpq_clear(__lpnum__);\
})

/* ========================================================================= */
/** @brief copy the square of the second argument, divided by the third 
 * argument into the first argument.
 * @param dest mpq_t where to store the result
 * @param orig mpq_t second parameter
 * @param den mpq_t third parameter
 * @par Description:
 * compute dest = (orig*orig)/den
 * */
#define mpq_EGlpNumCopySqrOver(dest, orig, den) ({\
	mpq_mul (dest, orig, orig);\
	mpq_div (dest, dest, den);\
})

/* ========================================================================= */
/** @brief copy the value of the absolute value of the second parameter to the 
 * first parameter.
 * @param orig mpq_t source number (it won't change value).
 * @param dest mpq_t where to store the absolute value stored
 * in 'orig'.
 * @par Description:
 * Given a number 'orig', copy its absolute value to 'dest'. i.e.
 * dest = |orig|
 * */
#define mpq_EGlpNumCopyAbs(dest,orig) mpq_abs(dest,orig)

/* ========================================================================= */
/** @brief copy minus the value of the second parameter to the 
 * first parameter.
 * @param orig mpq_t the source number (it won't change value).
 * @param dest mpq_t where to store minus the value stored
 * in 'orig'.
 * @par Description:
 * Given a number 'orig', copy minus the value to 'dest'. i.e.
 * dest = -orig
 * */
#define mpq_EGlpNumCopyNeg(dest,orig) mpq_neg(dest,orig)

/* ========================================================================= */
/** @brief Set des = op1/op2.
 * @param dest mpq_t where we will store the result.
 * @param op1 mpq_t numerator of the fraction (possibly non an integer)
 * @param op2 mpq_t denominator of the fraction (possibly non an integer)
 * @par Description:
 *  Set des = op1/op2
 * */
#define mpq_EGlpNumCopyFrac(dest,op1,op2) mpq_div(dest,op1,op2)

/* ========================================================================= */
/** @brief copy the first 'size' values in the second array to the first array.
 * @param orig mpq_t* pointer to the array from where we will copy the
 * values (it won't change value).
 * @param dest mpq_t* pointer to where to store the first 'size' values 
 * stored in 'orig'.
 * @param size unsigned int specifying how many values of 'orig' will be copied
 * onto 'dest'
 * @par Description:
 * This function is provided to (possible) make fast copies of arrays of
 * numbers, the arrays should be of length at least 'size', and the resulting
 * copy is absolutely independent froom the original, any change in one vale of
 * one array won't change values on the other array.
 * */
#define mpq_EGlpNumCopyArray(dest,orig,size) {\
	register unsigned int __i__ = size;\
	for(;__i__--;)\
	{\
		mpq_set(dest[__i__],orig[__i__]);\
	}\
}

/* ========================================================================= */
/** @brief Sub to a given number the product of two numbers.
 * @param a mpq_t the number that we are going to Sub to.
 * @param b mpq_t value to be multiplyed.
 * @param c mpq_t value to be multiplyed.
 * @par Description:
 * This function implements a = a - b*c, and clearly don't change the value
 * stored in 'b' nor in 'c'.
 * */
#define mpq_EGlpNumSubInnProdTo(a, b, c) ({\
	mpq_t __lpnum__;mpq_init(__lpnum__);\
	mpq_mul (__lpnum__, b, c);\
	mpq_sub (a, a, __lpnum__);\
	mpq_clear(__lpnum__);\
})

/* ========================================================================= */
/** @brief Add to a given number the product of two numbers.
 * @param a mpq_t the number that we are going to add to.
 * @param b mpq_t value to be multiplyed.
 * @param c mpq_t value to be multiplyed.
 * @par Description:
 * This function implements a = a + b*c, and clearly don't change the value
 * stored in 'b' nor in 'c'.
 * */
#define mpq_EGlpNumAddInnProdTo(a, b, c) ({\
	mpq_t __lpnum__;mpq_init(__lpnum__);\
	mpq_mul (__lpnum__, b, c);\
	mpq_add (a, a, __lpnum__);\
	mpq_clear(__lpnum__);\
})

/* ========================================================================= */
/** @brief Substract to a given number the value of the second number.
 * @param a mpq_t the number that we are going to substract to.
 * @param b unsigned int value to be substracted to 'a'.
 * @par Description:
 * This function implements a = a - b, and clearly don't change the value
 * stored in 'b'.
 * */
#define mpq_EGlpNumSubUiTo(a,b) mpz_submul_ui(mpq_numref(a),mpq_denref(a),(unsigned long int)b)

/* ========================================================================= */
/** @brief Add to a given number the value of the second number.
 * @param a mpq_t the number that we are going to add to.
 * @param b unsigned int value to be added to 'a'.
 * @par Description:
 * This function implements a = a + b, and clearly don't change the value
 * stored in 'b'.
 * */
#define mpq_EGlpNumAddUiTo(a,b) mpz_addmul_ui(mpq_numref(a),mpq_denref(a),(unsigned long int)b)

/* ========================================================================= */
/** @brief Add to a given number the value of the second number.
 * @param a mpq_t the number that we are going to add to.
 * @param b mpq_t value to be added to 'a'.
 * @par Description:
 * This function implements a = a + b, and clearly don't change the value
 * stored in 'b'.
 * */
#define mpq_EGlpNumAddTo(a,b) mpq_add(a,a,b)

/* ========================================================================= */
/** @brief Substract to a given number the value of the second number.
 * @param a mpq_t the number that we are going to substract
 * from.
 * @param b mpq_t value to be substracted to 'a'.
 * @par Description:
 * This function implements a = a - b, and clearly don't change the value
 * stored in 'b'.
 * */
#define mpq_EGlpNumSubTo(a,b) mpq_sub(a,a,b)

/* ========================================================================= */
/** @brief Multiply a given number by the value of the second number.
 * @param a mpq_t the number that we are going to multiply by
 * the second number and store the result.
 * @param b mpq_t value to be multyply to 'a'.
 * @par Description:
 * This function implements a = a * b, and clearly don't change the value
 * stored in 'b'.
 * */
#define mpq_EGlpNumMultTo(a,b) mpq_mul(a,a,b)

/* ========================================================================= */
/** @brief Divide a given number by the value of the second number.
 * @param a mpq_t the number that we are going to divide by
 * the second number and store the result.
 * @param b mpq_t value to be divide to 'a'.
 * @par Description:
 * This function implements a = a / b, and clearly don't change the value
 * stored in 'b'.
 * */
#define mpq_EGlpNumDivTo(a,b) mpq_div(a,a,b)

/* ========================================================================= */
/** @brief Divide a given number by the value of the second number.
 * @param a mpq_t the number that we are going to divide by
 * the second number and store the result.
 * @param b unsigned int value to be divided to 'a'.
 * @par Description:
 * This function implements a = a / b, and don't change the value
 * stored in 'b'.
 * */
#define mpq_EGlpNumDivUiTo(a,b) do{mpz_mul_ui(mpq_denref(a),mpq_denref(a),(unsigned long)b);mpq_canonicalize(a);}while(0)

/* ========================================================================= */
/** @brief Multiply a given number by the value of the second number.
 * @param a mpq_t the number that we are going to multiply by
 * the second number and store the result.
 * @param b unsigned int value to be multyply to 'a'.
 * @par Description:
 * This function implements a = a * b, and clearly don't change the value
 * stored in 'b'.
 * */
#define mpq_EGlpNumMultUiTo(a,b) do{mpz_mul_ui(mpq_numref(a),mpq_numref(a),(unsigned long int)b);mpq_canonicalize(a);}while(0)

/* ========================================================================= */
/** @brief Reset the value of the pointed number to zero.
 * @param a mpq_t the value to be set to zero.
 * @par Descrpition:
 * Reset a to zero, i.e. implements a = 0;
 * */
#define mpq_EGlpNumZero(a) mpq_set_ui(a,(unsigned long)0,(unsigned long)1)

/* ========================================================================= */
/** @brief Reset the value of the pointed number to one.
 * @param a mpq_t value to be set to one.
 * @par Descrpition:
 * Reset a to zero, i.e. implements a = 1;
 * */
#define mpq_EGlpNumOne(a) mpq_set_ui(a,(unsigned long)1,(unsigned long)1)

/* ========================================================================= */
/** @brief Change the sign of the number.
 * @param a mpq_t number we will change sign.
 * @par Descrpition:
 * Change the sign of the given number, i.e. implements a = -a
 * */
#define mpq_EGlpNumSign(a) mpq_neg(a,a)

/* ========================================================================= */
/** @brief return the closest double value of the given pointer number.
 * @param a mpq_t number that we will be transformed to double.
 * @return double the closest double representation of the given number.
 * par Description:
 * return the double number closest in value to the value stored in a.
 * */
#define mpq_EGlpNumToLf(a) mpq_get_d(a)

/* ========================================================================= */
/** @brief initialize the internal memory of a given variable */
#define mpq_EGlpNumInitVar(a) mpq_init(a)

/* ========================================================================= */
/** @brief free the internal memory of a given variable */
#define mpq_EGlpNumClearVar(a) mpq_clear(a)

/* ========================================================================= */
/** @} */
#endif
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef __EG_LPNUM_MPZ__
#define __EG_LPNUM_MPZ__
#ifdef HAVE_LIBGMP
/** @file
 * @ingroup EGlpNum */
/** @addtogroup EGlpNum */
/** @{ */
/* ========================================================================= */
/** extern definitions of constaants for different set-ups */
extern const mpz_t __zeroLpNum_mpz__;
extern const mpz_t __oneLpNum_mpz__;
extern const mpz_t __MinLpNum_mpz__;
extern const mpz_t __MaxLpNum_mpz__;
#define mpz_zeroLpNum __zeroLpNum_mpz__
#define mpz_oneLpNum  __oneLpNum_mpz__
#define mpz_MaxLpNum  __MaxLpNum_mpz__
#define mpz_MinLpNum  __MinLpNum_mpz__
#define mpz_epsLpNum  __zeroLpNum_mpz__

/* ========================================================================= */
/** @brief Read from a string a number and store it in the given mpz_t, return
 * the number of chars readed from the input string */
int mpz_EGlpNumReadStr (mpz_t a,
												const char *const str);

/* ========================================================================= */
/** @brief given a mpz_t, write it to a string (to be allocated internally), 
 * and return it. */
#define mpz_EGlpNumGetStr(a) ({\
	const size_t __sz = mpz_sizeinbase (a, 10)+3;\
	char *__str=EGsMalloc(char,__sz);\
	__str = mpz_get_str(__str,10,a);\
	__str;})

/* ========================================================================= */
/** @brief given an array of type mpz_t, free it, if the pointer is NULL
 * nothing happen. */
#define mpz_EGlpNumFreeArray(ea) ({\
	size_t __sz = __EGlpNumArraySize(ea);\
	mpz_t* __ptr__ = (ea);\
	while(__sz--) mpz_clear(__ptr__[__sz]);\
	__EGlpNumFreeArray(ea);})


/* ========================================================================= */
/** @brief Reallocate and initialize (if needed) 'size' elements of type 
 * mpz_t and return it, if no more memory, exit(1) */
#define mpz_EGlpNumReallocArray(lptr, lsize) ({\
	mpz_t **__ptr__ = (lptr);\
	size_t *__ntmp__ = (size_t *) *__ptr__, __sz__ = (lsize);\
	size_t __psz__;\
	/* if no memory allocated before we just call the regular allocator */\
	if (!*__ptr__)\
		*__ptr__ = mpz_EGlpNumAllocArray (__sz__);\
	else\
	{\
		/* first check that the previous size is not larger than the current */\
		__ntmp__--;\
		__psz__ = __ntmp__[0];\
		if (__psz__ < __sz__)\
		{\
			/* now we have to do the reallocation */\
			*__ptr__ = (mpz_t *) __ntmp__;\
			*__ptr__ = EGrealloc(*__ptr__,sizeof(mpz_t) * __sz__ + sizeof(size_t));\
			__ntmp__ = (size_t *) *__ptr__;\
			__ntmp__[0] = __sz__;\
			__ntmp__++;\
			*__ptr__ = (mpz_t *) __ntmp__;\
			for (; __psz__ < __sz__; __psz__++) mpz_init ((*__ptr__)[__psz__]);\
		}\
	}\
})

/* ========================================================================= */
/** @brief Allocate and initialize (if needed) 'size' elements of type mpz_t
 * and return it, if no more memory, exit(1) */
#define mpz_EGlpNumAllocArray(size) ({\
	size_t __i__ = (size);\
	mpz_t *__res = __EGlpNumAllocArray(mpz_t,__i__);\
	while(__i__--) mpz_init(__res[__i__]);\
	__res;})

/* ========================================================================= */
/** @brief set the given number pointer, set its value to the given double.
 * @param var mpz_t where we will store the double value.
 * @param dbl double value to be stored in 'var'.
 * @par Description:
 * This function is intended to set initial values to variables; note that the
 * double is a number and not a pointer to that value, be carefull with this
 * detail. Also, due to implementation details this function can't deal with
 * numbers above 1e158 or smaller than 1e-158. Note also that if the number is
 * writen in the form \f$x=\bar{x}\cdot 2^e\f$ with \f$0.5<|\bar{x}|<1\f$, 
 * then \f$\left|x-\frac{p}{q}\right|<2^{e-64}\f$.
 * */
#define mpz_EGlpNumSet (var, dbl) mpz_set_d(var,dbl)

/* ========================================================================= */
/** @brief Stores in the first number the ceil value of the second number, i.e.
 * EGlpNumCeil(a,b) <==> a= ceil(b) */
#define mpz_EGlpNumCeil(a, b) ({\
	mpz_cdiv_qr (mpz_numref (a), mpz_denref (a), mpz_numref (b), mpz_denref (b));\
	mpz_set_ui (mpz_denref (a), 1);\
})

/* ========================================================================= */
/** @brief Stores in the first number the floor value of the second number, i.e.
 * EGlpNumFloor(a,b) <==> a= floor(b) */
#define mpz_EGlpNumFloor(a, b) ({\
	mpz_fdiv_q (mpz_numref (a), mpz_numref (b), mpz_denref (b));\
	mpz_set_ui (mpz_denref (a), 1);\
})

/* ========================================================================= */
/** @brief store the (multiplicative) inverse of a number to itself, i.e.
 * implement a = 1/a.
 * @param a the number to be inverted. */
#define mpz_EGlpNumInv(a) mpz_inv(a,a)

/* ========================================================================= */
/** @brief Compare if two numbers are equal within a maximum error.
 * @param a mpz_t first number to compare.
 * @param b mpz_t second number to compare.
 * @return int one in success, zero oterwise.
 * @par Description:
 * Given two numbers 'a','b' return 1 if a == b, otherwise it return 0
 * */
#define mpz_EGlpNumIsEqqual(a,b) (mpz_equal(a,b))

/* ========================================================================= */
/** @brief Compare if two numbers are equal within a maximum error.
 * @param a mpz_t first number to compare.
 * @param b mpz_t second number to compare.
 * @param error mpz_t maximum difference allowed between both
 * numbers.
 * @return int one in success, zero oterwise.
 * @par Description:
 * Given two numbers 'a','b' and a tolerance 'error',
 * return 1 if |a-b|<= error, otherwise it return 0.
 * */
#define mpz_EGlpNumIsEqual(a,b,error) (mpz_equal(a,b))
#define mpz_EGlpNumIsNeq(a,b,error)   (!(mpz_equal(a,b)))
#define mpz_EGlpNumIsNeqq(a,b)        (!(mpz_equal(a,b)))
#define mpz_EGlpNumIsNeqZero(a,error) (!(mpz_sgn(a)))
#define mpz_EGlpNumIsNeqqZero(a)      (!(mpz_sgn(a)))

/* ========================================================================= */
/** @brief test if the number is greater than zero
 * @param a number to test
 * @return int one if success, zero otherwise.
 * */
#define mpz_EGlpNumIsGreatZero(a) (mpz_sgn(a) > 0)

/* ========================================================================= */
/** @brief test if the number is less than zero
 * @param a number to test
 * @return int one if success, zero otherwise.
 * */
#define mpz_EGlpNumIsLessZero(a) (mpz_sgn(a) < 0)

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a mpz_t the first number.
 * @param b mpz_t the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a < b, zero
 * otherwise.
 * */
#define mpz_EGlpNumIsLess(a,b) (mpz_cmp(a,b) < 0)

/* ========================================================================= */
/** @brief test if the sum of the first two numbers is less thatn the third
 * number.
 * @param a mpz_t the first number.
 * @param b mpz_t the second number
 * @param c mpz_t the third number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given a,b, and c, return nonzero if (a + b < c), zero toherwise.
 * */
#define mpz_EGlpNumIsSumLess(a, b, c) ({\
	mpz_t __lpnum; int __res=0;mpz_init(__lpnum);\
	mpz_add (__lpnum, a, b);\
	res=(mpz_cmp (__lpnum, c) < 0);\
	mpz_clear(__lpnum);__res;\
})

/* ========================================================================= */
/** @brief test if the diference of the first two numbers is less thatn the 
 * third number.
 * @param a mpz_t the first number.
 * @param b mpz_t the second number
 * @param c mpz_t the third number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given a,b, and c, return nonzero if (a - b < c), zero toherwise.
 * */
#define mpz_EGlpNumIsDiffLess(a, b, c) ({\
	mpz_t __lpnum;int __res=0; mpz_init(__lpnum);\
	mpz_sub (__lpnum, a, b);\
	res=(mpz_cmp (__lpnum, c) < 0);\
	mpz_clear(__lpnum);__res;\
})

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a mpz_t the first number.
 * @param b double the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a < b, zero
 * otherwise.
 * */
#define mpz_EGlpNumIsLessDbl(a,b) (mpz_get_d(a) < b)

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a mpz_t the first number.
 * @param b double the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a > b, zero
 * otherwise.
 * */
#define mpz_EGlpNumIsGreaDbl(a,b) (mpz_get_d(a) > b)

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a mpz_t the first number.
 * @param b mpz_t the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a <= b, zero
 * otherwise.
 * */
#define mpz_EGlpNumIsLeq(a,b) (mpz_cmp(a,b) <= 0)

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param a mpz_t source number (it won't change value).
 * @param b mpz_t source number (it won't change value).
 * @param c mpz_t denominator of the difference (it won't change value).
 * @param d mpz_t where to store the value .
 * @par Description:
 * Set @f$a = \frac{b - c}{d} @f$ */
#define mpz_EGlpNumCopyDiffRatio(a, b, c, d) ({\
	mpz_sub (a, b, c);\
	mpz_div (a, a, d);\
})

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param a mpz_t source number (it won't change value).
 * @param b mpz_t source number (it won't change value).
 * @param __dest mpz_t where to store the value stored in '__orig'.
 * @par Description:
 * Set __dest = a - b */
#define mpz_EGlpNumCopyDiff(__dest,a,b) mpz_sub(__dest,a,b)

/* ========================================================================= */
/** @brief copy the value of the sum of the second and third parameter
 * @param a mpz_t source number (it won't change value).
 * @param b mpz_t source number (it won't change value).
 * @param __dest mpz_t where to store the sum.
 * @par Description:
 * Set __dest = a + b */
#define mpz_EGlpNumCopySum(__dest,a,b) mpz_add(__dest,a,b)

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param __orig mpz_t source number (it won't change value).
 * @param __dest mpz_t where to store the value stored in '__orig'.
 * @par Description:
 * Given two numbers copy the values in '__orig', into '__dest'.
 * */
#define mpz_EGlpNumCopy(__dest,__orig) mpz_set(__dest,__orig)

/* ========================================================================= */
/** @brief change the fist number to the maximum between itself and the 
 * absolute value of the second.
 * @param __orig mpz_t source number (it won't change value).
 * @param __dest mpz_t where to store the value stored in '__orig'.
 * @par Description:
 * implement __dest = max(__dest,abs(__orig))
 * */
#define mpz_EGlpNumSetToMaxAbs(__dest, __orig) ({\
	if (mpz_cmpabs (__dest, __orig) < 0)\
		mpz_abs (__dest, __orig);\
})

#define mpz_EGlpNumSetToMinAbs(__dest, __orig) ({\
	if (mpz_cmpabs (__dest, __orig) > 0)\
		mpz_abs (__dest, __orig);\
})

/* ========================================================================= */
/** @brief copy the square of the second argument, divided by the third 
 * argument into the first argument.
 * @param __dest mpz_t where to store the result
 * @param __orig mpz_t second parameter
 * @param __den mpz_t third parameter
 * @par Description:
 * compute __dest = (__orig*__orig)/__den
 * */
#define mpz_EGlpNumCopySqrOver(__dest, __orig, __den) ({\
	mpz_mul(__dest,__orig,__orig);\
	mpz_div(__dest,__dest,__den);\
})

/* ========================================================================= */
/** @brief copy the value of the absolute value of the second parameter to the 
 * first parameter.
 * @param __orig mpz_t source number (it won't change value).
 * @param __dest mpz_t where to store the absolute value stored
 * in '__orig'.
 * @par Description:
 * Given a number '__orig', copy its absolute value to '__dest'. i.e.
 * __dest = |__orig|
 * */
#define mpz_EGlpNumCopyAbs(__dest,__orig) mpz_abs(__dest,__orig)

/* ========================================================================= */
/** @brief copy minus the value of the second parameter to the 
 * first parameter.
 * @param __orig mpz_t the source number (it won't change value).
 * @param __dest mpz_t where to store minus the value stored
 * in '__orig'.
 * @par Description:
 * Given a number '__orig', copy minus the value to '__dest'. i.e.
 * __dest = -__orig
 * */
#define mpz_EGlpNumCopyNeg(__dest,__orig) mpz_neg(__dest,__orig)

/* ========================================================================= */
/** @brief Set des = op1/op2.
 * @param __dest mpz_t where we will store the result.
 * @param op1 mpz_t numerator of the fraction (possibly non an integer)
 * @param op2 mpz_t denominator of the fraction (possibly non an integer)
 * @par Description:
 *  Set des = op1/op2
 * */
#define mpz_EGlpNumCopyFrac(__dest,op1,op2) mpz_div(__dest,op1,op2)

/* ========================================================================= */
/** @brief copy the first 'size' values in the second array to the first array.
 * @param __orig mpz_t* pointer to the array from where we will copy the
 * values (it won't change value).
 * @param __dest mpz_t* pointer to where to store the first 'size' values 
 * stored in '__orig'.
 * @param size unsigned int specifying how many values of '__orig' will be copied
 * onto '__dest'
 * @par Description:
 * This function is provided to (possible) make fast copies of arrays of
 * numbers, the arrays should be of length at least 'size', and the resulting
 * copy is absolutely independent froom the original, any change in one vale of
 * one array won't change values on the other array.
 * */
#define mpz_EGlpNumCopyArray(__dest,__orig,size) {\
	register unsigned int __i__ = size;\
	for(;__i__--;)\
	{\
		mpz_set(__dest[__i__],__orig[__i__]);\
	}\
}

/* ========================================================================= */
/** @brief Sub to a given number the product of two numbers.
 * @param a mpz_t the number that we are going to Sub to.
 * @param b mpz_t value to be multiplyed.
 * @param c mpz_t value to be multiplyed.
 * @par Description:
 * This function implements a = a - b*c, and clearly don't change the value
 * stored in 'b' nor in 'c'.
 * */
#define mpz_EGlpNumSubInnProdTo(a, b, c) mpz_submul(a,b,c)

/* ========================================================================= */
/** @brief Add to a given number the product of two numbers.
 * @param a mpz_t the number that we are going to add to.
 * @param b mpz_t value to be multiplyed.
 * @param c mpz_t value to be multiplyed.
 * @par Description:
 * This function implements a = a + b*c, and clearly don't change the value
 * stored in 'b' nor in 'c'.
 * */
#define mpz_EGlpNumAddInnProdTo(a, b, c) mpz_addmul(a,b,c)

/* ========================================================================= */
/** @brief Substract to a given number the value of the second number.
 * @param a mpz_t the number that we are going to substract to.
 * @param b unsigned int value to be substracted to 'a'.
 * @par Description:
 * This function implements a = a - b, and clearly don't change the value
 * stored in 'b'.
 * */
#define mpz_EGlpNumSubUiTo(a,b) mpz_sub_ui(a,b)

/* ========================================================================= */
/** @brief Add to a given number the value of the second number.
 * @param a mpz_t the number that we are going to add to.
 * @param b unsigned int value to be added to 'a'.
 * @par Description:
 * This function implements a = a + b, and clearly don't change the value
 * stored in 'b'.
 * */
#define mpz_EGlpNumAddUiTo(a,b) (mpz_addmul_ui(mpz_numref(a),mpz_denref(a),b),mpz_canonicalize(a))

/* ========================================================================= */
/** @brief Add to a given number the value of the second number.
 * @param a mpz_t the number that we are going to add to.
 * @param b mpz_t value to be added to 'a'.
 * @par Description:
 * This function implements a = a + b, and clearly don't change the value
 * stored in 'b'.
 * */
#define mpz_EGlpNumAddTo(a,b) mpz_add(a,a,b)

/* ========================================================================= */
/** @brief Substract to a given number the value of the second number.
 * @param a mpz_t the number that we are going to substract
 * from.
 * @param b mpz_t value to be substracted to 'a'.
 * @par Description:
 * This function implements a = a - b, and clearly don't change the value
 * stored in 'b'.
 * */
#define mpz_EGlpNumSubTo(a,b) mpz_sub(a,a,b)

/* ========================================================================= */
/** @brief Multiply a given number by the value of the second number.
 * @param a mpz_t the number that we are going to multiply by
 * the second number and store the result.
 * @param b mpz_t value to be multyply to 'a'.
 * @par Description:
 * This function implements a = a * b, and clearly don't change the value
 * stored in 'b'.
 * */
#define mpz_EGlpNumMultTo(a,b) mpz_mul(a,a,b)

/* ========================================================================= */
/** @brief Divide a given number by the value of the second number.
 * @param a mpz_t the number that we are going to divide by
 * the second number and store the result.
 * @param b mpz_t value to be divide to 'a'.
 * @par Description:
 * This function implements a = a / b, and clearly don't change the value
 * stored in 'b'.
 * */
#define mpz_EGlpNumDivTo(a,b) mpz_div(a,a,b)

/* ========================================================================= */
/** @brief Divide a given number by the value of the second number.
 * @param a mpz_t the number that we are going to divide by
 * the second number and store the result.
 * @param b unsigned int value to be divided to 'a'.
 * @par Description:
 * This function implements a = a / b, and don't change the value
 * stored in 'b'.
 * */
#define mpz_EGlpNumDivUiTo(a,b) (mpz_mul_ui(mpz_denref(a),mpz_denref(a),b),mpz_canonicalize(a))

/* ========================================================================= */
/** @brief Multiply a given number by the value of the second number.
 * @param a mpz_t the number that we are going to multiply by
 * the second number and store the result.
 * @param b unsigned int value to be multyply to 'a'.
 * @par Description:
 * This function implements a = a * b, and clearly don't change the value
 * stored in 'b'.
 * */
#define mpz_EGlpNumMultUiTo(a,b) (mpz_mul_ui(mpz_numref(a),mpz_numref(a),b),mpz_canonicalize(a))

/* ========================================================================= */
/** @brief Reset the value of the pointed number to zero.
 * @param a mpz_t the value to be set to zero.
 * @par Descrpition:
 * Reset a to zero, i.e. implements a = 0;
 * */
#define mpz_EGlpNumZero(a) mpz_set_ui(a,0U,1U)

/* ========================================================================= */
/** @brief Reset the value of the pointed number to one.
 * @param a mpz_t value to be set to one.
 * @par Descrpition:
 * Reset a to zero, i.e. implements a = 1;
 * */
#define mpz_EGlpNumOne(a) mpz_set_ui(a,1U,1U)

/* ========================================================================= */
/** @brief Change the sign of the number.
 * @param a mpz_t number we will change sign.
 * @par Descrpition:
 * Change the sign of the given number, i.e. implements a = -a
 * */
#define mpz_EGlpNumSign(a) mpz_neg(a,a)

/* ========================================================================= */
/** @brief return the closest double value of the given pointer number.
 * @param a mpz_t number that we will be transformed to double.
 * @return double the closest double representation of the given number.
 * par Description:
 * return the double number closest in value to the value stored in a.
 * */
#define mpz_EGlpNumToLf(a) mpz_get_d(a)

/* ========================================================================= */
/** @brief initialize the internal memory of a given variable */
#define mpz_EGlpNumInitVar(a) mpz_init(a)

/* ========================================================================= */
/** @brief free the internal memory of a given variable */
#define mpz_EGlpNumClearVar(a) mpz_clear(a)

/* ========================================================================= */
/** @} */
#endif
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef __EG_LPNUM_FLOAT128__
#define __EG_LPNUM_FLOAT128__
#ifdef HAVE_SOFTFLOAT
#if HAVE_SOFTFLOAT
/** @file
 * @ingroup EGlpNum */
/** @addtogroup EGlpNum */
/** @{ */
/* ========================================================================= */
/** @brief This is the smallest difference (with the current precision) that can
 * be distinguished betwen 1.0 and it's clossest representable number, in some
 * sense it is the absolute minimum epsilon for comparisons */
extern float128 float128_eps;

/* ========================================================================= */
/** @brief union to conver C doubles to float64 types as provided by SoftFloat.
 * This is needed because the default conversion does not apply. */
typedef union
{
	float64 fl;
	double dbl;
}
f64dbl_t;

/* ========================================================================= */
/** extern definitions of constants for different set-ups */
extern const float128 __zeroLpNum_float128__;
extern const float128 __oneLpNum_float128__;
extern const float128 __MaxLpNum_float128__;
extern const float128 __MinLpNum_float128__;
#define float128_zeroLpNum __zeroLpNum_float128__
#define float128_oneLpNum  __oneLpNum_float128__
#define float128_epsLpNum  float128_eps
#define float128_MaxLpNum	__MaxLpNum_float128__
#define float128_MinLpNum	__MinLpNum_float128__

/* ========================================================================= */
/** @brief Given a double exp, compute \f$ e^{exp} \f$ and store it in the given
 * float128 number.
 * @param exp double exponent to be used.
 * @param num float128 number where to store the result.
 * */
#define float128_EGlpNumEpow(num,exp) ({\
	unsigned int __i = 0;\
	const f64dbl_t __exp = {.dbl = (exp)};\
	int __lsgn = __exp.dbl <0 ? 1:0;\
	float128 __ntmp,__res,__lexp,__err,__fint;\
	__lext = float64_to_float128(__exp.fl);\
	__lexp.high &= 0x7fffffffffffffffLL;\
	__ntmp = int32_to_float128(1);\
	__res = int32_to_float128(1);\
	__err = float128_div(__ntmp,__res);\
	while(float128_lt(float128_eps,__err))\
	{\
		__ntmp = float128_mul(__ntmp,__lexp);\
		__fint = int32_to_float128(++__i);\
		__ntmp = float128_div(__ntmp,__fint);\
		__res = float128_add(__res,__ntmp);\
		__err = float128_div(__ntmp,__res);\
	}\
	if(__lsgn) num = float128_div(float128_oneLpNum,__res);\
	else num = __res;})

/* ========================================================================= */
/** @brief Read from a string a number and store it in the given float128, 
 * @return the number of chars readed from the input string */
#define float128_EGlpNumReadStr(a,str) ({\
	int __i =0;\
	f64dbl_t __tmp;\
	sscanf(str,"%lf%n",&(__tmp.dbl),&__i);\
	(a) = float64_to_float128(__tmp.fl);\
	__i;})

/* ========================================================================= */
/** @brief given a float128, write it to a string (to be allocated internally), 
 * and return it. */
#define float128_EGlpNumGetStr(a) ({\
	const f64dbl_t __tmp = {.fl = float128_to_float64(a)};\
	char *__str=0;\
	size_t __i = snprintf(__str,(size_t)0,"%.7lg",__tmp.dbl);\
	__str = EGsMalloc(char,__i+1);\
	snprintf(__str,__i+1,"%.7lg",__tmp.dbl);\
	__str;})

/* ========================================================================= */
/** @brief given an array of type float128, free it, if the pointer is NULL
 * nothing happen. */
#define float128_EGlpNumFreeArray(ea) __EGlpNumFreeArray(ea)

/* ========================================================================= */
/** @brief Reallocate and initialize (if needed) 'size' elements of type 
 * float128 and return it, if no more memory, exit(1) */
#define float128_EGlpNumReallocArray(lptr, lsize) ({ \
	float128** __ptr__ = (lptr); \
	size_t __sz__ = (lsize); \
	size_t *__ntmp__ = (size_t *) *__ptr__; \
	size_t __psz__; \
	/* if no memory allocated before we just call the regular allocator */ \
	if (!*__ptr__) *__ptr__ = float128_EGlpNumAllocArray (__sz__); \
	else \
	{ \
		/* first check that the previous size is not larger than the current */ \
		__ntmp__--; \
		__psz__ = __ntmp__[0]; \
		if (__psz__ < __sz__) \
		{ \
			/* now we have to do the reallocation */ \
			*__ptr__ = (float128 *) __ntmp__; \
			*__ptr__ = EGrealloc(*__ptr__, sizeof(float128) * __sz__ +sizeof(size_t));\
			__ntmp__ = (size_t *) *__ptr__; \
			__ntmp__[0] = __sz__; \
			__ntmp__++; \
			*__ptr__ = (float128 *) __ntmp__; \
			for (; __psz__ < __sz__; __psz__++) (*__ptr__)[__psz__] = (float128){0,0}; \
		} \
	} \
})

/* ========================================================================= */
/** @brief Allocate and initialize (if needed) 'size' elements of type float128
 * and return it, if no more memory, exit(1) */
#define float128_EGlpNumAllocArray(size) __EGlpNumAllocArray(float128,(size))

/* ========================================================================= */
/** @brief set the given number pointer, set its value to the given double.
 * @param var float128 where we will store the double value.
 * @param edbl double value to be stored in 'var'.
 * @par Description:
 * This function is intended to set initial values to variables; note that the
 * double is a number and not a pointer to that value, be carefull with this
 * detail. Also, due to implementation details this function can't deal with
 * numbers above 1e158 or smaller than 1e-158. Note also that if the number is
 * writen in the form \f$x=\bar{x}\cdot 2^e\f$ with \f$0.5<|\bar{x}|<1\f$, 
 * then \f$\left|x-\frac{p}{q}\right|<2^{e-64}\f$.
 * */
#define float128_EGlpNumSet(var, edbl) ({\
	f64dbl_t __tmp = {.dbl = (edbl)};\
	var = float64_to_float128(__tmp.fl);})

/* ========================================================================= */
/** @brief Stores in the first number the ceil value of the second number, i.e.
 * EGlpNumCeil(a,b) <==> a= ceil(b) */
#define float128_EGlpNumCeil(a, b) do{\
	(a) = float128_round_to_int(b);\
	if(float128_lt(a,b)) (a) = float128_add((a),float128_oneLpNum);} while(0)

/* ========================================================================= */
/** @brief Stores in the first number the floor value of the second number, i.e.
 * EGlpNumFloor(a,b) <==> a= floor(b) */
#define float128_EGlpNumFloor(a, b) do{\
	(a) = float128_round_to_int(b);\
	if(float128_lt(b,a)) (a) = float128_sub((a),float128_oneLpNum);} while(0)

/* ========================================================================= */
/** @brief store the (multiplicative) inverse of a number to itself, i.e.
 * implement a = 1/a.
 * @param a the number to be inverted. */
#define float128_EGlpNumInv(a) ((a) = float128_div(float128_oneLpNum,a))

/* ========================================================================= */
/** @brief Compare if two numbers are equal within a maximum error.
 * @param a float128 first number to compare.
 * @param b float128 second number to compare.
 * @return int one in success, zero oterwise.
 * @par Description:
 * Given two numbers 'a','b' return 1 if a == b, otherwise it return 0
 * */
#define float128_EGlpNumIsEqqual(a,b) (float128_eq(a,b))

/* ========================================================================= */
/** @brief Compare if two numbers are equal within a maximum error.
 * @param a float128 first number to compare.
 * @param b float128 second number to compare.
 * @param error float128 maximum difference allowed between both
 * numbers.
 * @return int one in success, zero oterwise.
 * @par Description:
 * Given two numbers 'a','b' and a tolerance 'error',
 * return 1 if |a-b|<= error, otherwise it return 0.
 * */
#define float128_EGlpNumIsEqual(a,b,error) ({\
	float128 __lpnum__= float128_sub (a, b);\
	__lpnum__.high &= 0x7fffffffffffffffLL;\
	float128_le(__lpnum__, error);\
})

#define float128_EGlpNumIsNeq(a,b,error) ({\
	float128 __lpnum__= float128_sub(a, b);\
	__lpnum__.high &= 0x7fffffffffffffffLL;\
	float128_lt(error,__lpnum__);})

#define float128_EGlpNumIsNeqZero(a,error) ({\
	float128 __lpnum__= (a);\
	__lpnum__.high &= 0x7fffffffffffffffLL;\
	float128_lt(error,__lpnum__);\
})

#define float128_EGlpNumIsNeqqZero(a)     	(!float128_eq(a,float128_zeroLpNum))
#define float128_EGlpNumIsNeqq(a,b)        (!float128_eq(a,b))

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a float128 the first number.
 * @param b float128 the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a < b, zero
 * otherwise.
 * */
#define float128_EGlpNumIsLess(a,b) (float128_lt(a,b))

/* ========================================================================= */
/** @brief test if the first number is greater than zero
 * @param a number to compare.
 * @return int one if success, zero otherwise.
 * */
#define float128_EGlpNumIsGreatZero(a) (!float128_le(a,float128_zeroLpNum))

/* ========================================================================= */
/** @brief test if the first number is less than zero
 * @param a number to compare.
 * @return int one if success, zero otherwise.
 * */
#define float128_EGlpNumIsLessZero(a) (float128_lt(a,float128_zeroLpNum))

/* ========================================================================= */
/** @brief test if the sum of the first two numbers is less thatn the third
 * number.
 * @param a float128 the first number.
 * @param b float128 the second number
 * @param c float128 the third number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given a,b, and c, return nonzero if (a + b < c), zero toherwise.
 * */
#define float128_EGlpNumIsSumLess(a, b, c) ({\
	float128 __lpnum__= float128_add( a, b);\
	float128_lt(__lpnum__, c);\
})

/* ========================================================================= */
/** @brief test if the diference of the first two numbers is less thatn the 
 * third number.
 * @param a float128 the first number.
 * @param b float128 the second number
 * @param c float128 the third number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given a,b, and c, return nonzero if (a - b < c), zero toherwise.
 * */
#define float128_EGlpNumIsDiffLess(a, b, c) ({\
	float128 __lpnum__= float128_sub (a, b);\
	float128_lt(__lpnum__, c);\
})

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a float128 the first number.
 * @param b double the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a < b, zero
 * otherwise.
 * */
#define float128_EGlpNumIsLessDbl(a,b) ({\
	f64dbl_t __tmp = {.dbl = (b)};\
	float128 __lpnum__= float64_to_float128(__tmp.fl);\
	float128_lt(a,__lpnum__);})

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a float128 the first number.
 * @param b double the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a > b, zero
 * otherwise.
 * */
#define float128_EGlpNumIsGreaDbl(a,b) ({\
	f64dbl_t __tmp = {.dbl = (b)};\
	float128 __lpnum__= float64_to_float128(__tmp.fl);\
	float128_lt(__lpnum__,a);})

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a float128 the first number.
 * @param b float128 the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a <= b, zero
 * otherwise.
 * */
#define float128_EGlpNumIsLeq(a,b) float128_le(a,b)

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param a float128 source number (it won't change value).
 * @param b float128 source number (it won't change value).
 * @param c float128 denominator of the difference (it won't change value).
 * @param d float128 where to store the value .
 * @par Description:
 * Set @f$a = \frac{b - c}{d} @f$ */
#define float128_EGlpNumCopyDiffRatio(a, b, c, d) ({\
	float128 __lpnum__= float128_sub (b, c);\
	a = float128_div (__lpnum__, d);\
})

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param a float128 source number (it won't change value).
 * @param b float128 source number (it won't change value).
 * @param dest float128 where to store the value stored in 'orig'.
 * @par Description:
 * Set dest = a - b */
#define float128_EGlpNumCopyDiff(dest,a,b) (dest = float128_sub(a,b))

/* ========================================================================= */
/** @brief copy the value of the sum of the second and third parameter
 * @param a float128 source number (it won't change value).
 * @param b float128 source number (it won't change value).
 * @param dest float128 where to store the sum.
 * @par Description:
 * Set dest = a + b */
#define float128_EGlpNumCopySum(dest,a,b) (dest = float128_add(a,b))

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param orig float128 source number (it won't change value).
 * @param dest float128 where to store the value stored in 'orig'.
 * @par Description:
 * Given two numbers copy the values in 'orig', into 'dest'.
 * */
#define float128_EGlpNumCopy(dest,orig) (dest=orig)

/* ========================================================================= */
/** @brief change the fist number to the maximum between itself and the 
 * absolute value of the second.
 * @param orig float128 source number (it won't change value).
 * @param dest float128 where to store the value stored in 'orig'.
 * @par Description:
 * implement dest = max(dest,abs(orig))
 * */
#define float128_EGlpNumSetToMaxAbs(dest, orig) ({\
	float128 __lpnum__= (orig);\
	__lpnum__.high &= 0x7fffffffffffffffLL;\
	if (float128_lt(dest, __lpnum__)) (dest) = __lpnum__;})

#define float128_EGlpNumSetToMinAbs(dest, orig) ({\
	float128 __lpnum__=(orig);\
	__lpnum__.high &= 0x7fffffffffffffffLL;\
	if (float128_lt( __lpnum__, dest)) (dest) = __lpnum__;})

/* ========================================================================= */
/** @brief copy the square of the second argument, divided by the third 
 * argument into the first argument.
 * @param dest float128 where to store the result
 * @param orig float128 second parameter
 * @param den float128 third parameter
 * @par Description:
 * compute dest = (orig*orig)/den
 * */
#define float128_EGlpNumCopySqrOver(dest, orig, den) ({\
	float128 __lpnum__= float128_mul (orig, orig);\
	(dest) = float128_div ( __lpnum__, den);\
})

/* ========================================================================= */
/** @brief copy the value of the absolute value of the second parameter to the 
 * first parameter.
 * @param orig float128 source number (it won't change value).
 * @param dest float128 where to store the absolute value stored
 * in 'orig'.
 * @par Description:
 * Given a number 'orig', copy its absolute value to 'dest'. i.e.
 * dest = |orig|
 * */
#define float128_EGlpNumCopyAbs(dest,orig) ({\
	(dest) = (orig);\
	(dest).high &= 0x7fffffffffffffffLL;})

/* ========================================================================= */
/** @brief copy minus the value of the second parameter to the 
 * first parameter.
 * @param orig float128 the source number (it won't change value).
 * @param dest float128 where to store minus the value stored
 * in 'orig'.
 * @par Description:
 * Given a number 'orig', copy minus the value to 'dest'. i.e.
 * dest = -orig
 * */
#define float128_EGlpNumCopyNeg(dest,orig) ({\
	(dest) = (orig);\
	(dest).high ^= 0x8000000000000000LL;})

/* ========================================================================= */
/** @brief Set des = op1/op2.
 * @param dest float128 where we will store the result.
 * @param op1 float128 numerator of the fraction (possibly non an integer)
 * @param op2 float128 denominator of the fraction (possibly non an integer)
 * @par Description:
 *  Set des = op1/op2
 * */
#define float128_EGlpNumCopyFrac(dest,op1,op2) ((dest) = float128_div(op1,op2))

/* ========================================================================= */
/** @brief copy the first 'size' values in the second array to the first array.
 * @param orig float128* pointer to the array from where we will copy the
 * values (it won't change value).
 * @param dest float128* pointer to where to store the first 'size' values 
 * stored in 'orig'.
 * @param size unsigned int specifying how many values of 'orig' will be copied
 * onto 'dest'
 * @par Description:
 * This function is provided to (possible) make fast copies of arrays of
 * numbers, the arrays should be of length at least 'size', and the resulting
 * copy is absolutely independent froom the original, any change in one vale of
 * one array won't change values on the other array.
 * */
#define float128_EGlpNumCopyArray(dest,orig,size) memcpy(dest,orig,sizeof(float128)*(size))

/* ========================================================================= */
/** @brief Sub to a given number the product of two numbers.
 * @param a float128 the number that we are going to Sub to.
 * @param b float128 value to be multiplyed.
 * @param c float128 value to be multiplyed.
 * @par Description:
 * This function implements a = a - b*c, and clearly don't change the value
 * stored in 'b' nor in 'c'.
 * */
#define float128_EGlpNumSubInnProdTo(a, b, c) ({\
	float128 __lpnum__= float128_mul(b, c);\
	(a) = float128_sub(a, __lpnum__);\
})

/* ========================================================================= */
/** @brief Add to a given number the product of two numbers.
 * @param a float128 the number that we are going to add to.
 * @param b float128 value to be multiplyed.
 * @param c float128 value to be multiplyed.
 * @par Description:
 * This function implements a = a + b*c, and clearly don't change the value
 * stored in 'b' nor in 'c'.
 * */
#define float128_EGlpNumAddInnProdTo(a, b, c) ({\
	float128 __lpnum__= float128_mul ( b, c);\
	(a) = float128_add (a, __lpnum__);\
})

/* ========================================================================= */
/** @brief Substract to a given number the value of the second number.
 * @param a float128 the number that we are going to substract to.
 * @param b unsigned int value to be substracted to 'a'.
 * @par Description:
 * This function implements a = a - b, and clearly don't change the value
 * stored in 'b'.
 * */
#define float128_EGlpNumSubUiTo(a,b) ({\
	float128 __lpnum__= int64_to_float128((long long)(b));\
	(a) = float128_sub(a,__lpnum__);})

/* ========================================================================= */
/** @brief Add to a given number the value of the second number.
 * @param a float128 the number that we are going to add to.
 * @param b unsigned int value to be added to 'a'.
 * @par Description:
 * This function implements a = a + b, and clearly don't change the value
 * stored in 'b'.
 * */
#define float128_EGlpNumAddUiTo(a,b) ({\
	float128 __lpnum__= int64_to_float128((long long)(b));\
	(a) = float128_add(a,__lpnum__);})

/* ========================================================================= */
/** @brief Add to a given number the value of the second number.
 * @param a float128 the number that we are going to add to.
 * @param b float128 value to be added to 'a'.
 * @par Description:
 * This function implements a = a + b, and clearly don't change the value
 * stored in 'b'.
 * */
#define float128_EGlpNumAddTo(a,b) ((a) = float128_add(a,b))

/* ========================================================================= */
/** @brief Substract to a given number the value of the second number.
 * @param a float128 the number that we are going to substract
 * from.
 * @param b float128 value to be substracted to 'a'.
 * @par Description:
 * This function implements a = a - b, and clearly don't change the value
 * stored in 'b'.
 * */
#define float128_EGlpNumSubTo(a,b) ((a) = float128_sub(a,b))

/* ========================================================================= */
/** @brief Multiply a given number by the value of the second number.
 * @param a float128 the number that we are going to multiply by
 * the second number and store the result.
 * @param b float128 value to be multyply to 'a'.
 * @par Description:
 * This function implements a = a * b, and clearly don't change the value
 * stored in 'b'.
 * */
#define float128_EGlpNumMultTo(a,b) ((a) = float128_mul(a,b))

/* ========================================================================= */
/** @brief Divide a given number by the value of the second number.
 * @param a float128 the number that we are going to divide by
 * the second number and store the result.
 * @param b float128 value to be divide to 'a'.
 * @par Description:
 * This function implements a = a / b, and clearly don't change the value
 * stored in 'b'.
 * */
#define float128_EGlpNumDivTo(a,b) ((a) = float128_div(a,b))

/* ========================================================================= */
/** @brief Divide a given number by the value of the second number.
 * @param a float128 the number that we are going to divide by
 * the second number and store the result.
 * @param b unsigned int value to be divided to 'a'.
 * @par Description:
 * This function implements a = a / b, and don't change the value
 * stored in 'b'.
 * */
#define float128_EGlpNumDivUiTo(a,b) ({\
	float128 __lpnum__= int64_to_float128((long long)(b));\
	(a) = float128_div(a,__lpnum__);})

/* ========================================================================= */
/** @brief Multiply a given number by the value of the second number.
 * @param a float128 the number that we are going to multiply by
 * the second number and store the result.
 * @param b unsigned int value to be multyply to 'a'.
 * @par Description:
 * This function implements a = a * b, and clearly don't change the value
 * stored in 'b'.
 * */
#define float128_EGlpNumMultUiTo(a,b) ({\
	float128 __lpnum__= int64_to_float128((long long)(b));\
	(a) = float128_mul(a,__lpnum__);})

/* ========================================================================= */
/** @brief Reset the value of the pointed number to zero.
 * @param a float128 the value to be set to zero.
 * @par Descrpition:
 * Reset a to zero, i.e. implements a = 0;
 * */
#define float128_EGlpNumZero(a) ((a) = (float128){0,0})

/* ========================================================================= */
/** @brief Reset the value of the pointed number to one.
 * @param a float128 value to be set to one.
 * @par Descrpition:
 * Reset a to zero, i.e. implements a = 1;
 * */
#define float128_EGlpNumOne(a) ((a) = (float128){.high = 0x3fff000000000000LL, .low = 0})

/* ========================================================================= */
/** @brief Change the sign of the number.
 * @param a float128 number we will change sign.
 * @par Descrpition:
 * Change the sign of the given number, i.e. implements a = -a
 * */
#define float128_EGlpNumSign(a) ((a).high ^= 0x8000000000000000LL)

/* ========================================================================= */
/** @brief return the closest double value of the given pointer number.
 * @param a float128 number that we will be transformed to double.
 * @return double the closest double representation of the given number.
 * par Description:
 * return the double number closest in value to the value stored in a.
 * */
#define float128_EGlpNumToLf(a) ({\
	const f64dbl_t __tmp = {.fl = float128_to_float64(a)};\
	__tmp.dbl;})

/* ========================================================================= */
/** @brief initialize the internal memory of a given variable */
#define float128_EGlpNumInitVar(a) (a = (float128){0,0})

/* ========================================================================= */
/** @brief free the internal memory of a given variable */
#define float128_EGlpNumClearVar(a)

/* ========================================================================= */
/** @} */
#endif
#endif
#endif
#ifdef HAVE_SOFTFLOAT
#if HAVE_SOFTFLOAT
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef float128___EG_DMATRIX_H__
#define float128___EG_DMATRIX_H__

/* ========================================================================= */
/** @defgroup EGdMatrix Dense Matrices
 * Here we define a common interface for dense matrices (i.e. a structure), and
 * some common operations over dense matrices. The definition uses EGlpNum as
 * reference number type, this allow for template initializations.
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2005-10-27
 *  					- First implementation.
 * */
/** @{*/
/** @file
 * @brief This file provide the user interface and function definitions for
 * Dense Matrices.
 * */
/** @example float128_eg_dmatrix.ex.c */
/* ========================================================================= */
/** @brief structure to hold a dense matrix, we choose a row representation
 * of the matrix, and we allow row and column permutations. All actual values 
 * in the matrix are stored in #float128_EGdMatrix_t::matval, and the rows in
 * #float128_EGdMatrix_t::matrow. */
typedef struct float128_EGdMatrix_t
{
	size_t col_sz;		/**< @brief Number of columns in the matrix. */
	size_t row_sz;		/**< @brief Number of rows in the matrix */
	float128 **matrow;
										/**< @brief Array of size #float128_EGdMatrix_t::row_sz containing 
												 all rows of the matrix */
	float128 *matval;/**< @brief Values for all entries */
	int *col_ord;			/**< @brief Array of size at least #float128_EGdMatrix_t::col_sz 
												 containing the order ammong all columns i.e. it is a 
												 permutation of {0,....,col_sz-1} which is how the 
												 matrix is treated internally */
	int *row_ord;			/**< @brief Array of size at least #float128_EGdMatrix_t::row_sz 
												 containing the order ammong all rows, i.e. it is a 
												 permutation of {0,...,row_sz-1} which is how the 
												 matrix is treated internally */
}
float128_EGdMatrix_t;

/* ========================================================================= */
/** @brief Initialize (as a dense matrix of dimension 0x0) an #float128_EGdMatrix_t
 * structure.
 * @param __dmatrix dense matrix structure pointer.
 * */
#define float128_EGdMatrixInit(__dmatrix) memset(__dmatrix,0,sizeof(float128_EGdMatrix_t))

/* ========================================================================= */
/** @brief Clear a dense matrix structure, i.e. free all internally allocated
 * data of the structure. Note that no further use of the structure can be made
 * unless it is re-initialized and set to a suitable size.
 * @param __dmatrix dense matrix structure pointer.
 * */
#define float128_EGdMatrixClear(__dmatrix) do{\
	float128_EGdMatrix_t*const __EGdm = (__dmatrix);\
	float128_EGlpNumFreeArray(__EGdm->matval);\
	EGfree(__EGdm->matrow);\
	int_EGlpNumFreeArray(__EGdm->col_ord);\
	int_EGlpNumFreeArray(__EGdm->row_ord);} while(0)

/* ========================================================================= */
/** @brief Set new dimensions for a dense matrix structure.
 * @param __dmatrix dense matrix structure pointer.
 * @param __nnewrows number of rows in the matrix.
 * @param __nnewcols number of columns in the matrix.
 * @note Take care that the values stored in the matrix are not initialized to
 * any particular number. Also the ordering (for both column and row) is reset
 * to the standard ordering 0,....,n.
 * */
#define float128_EGdMatrixSetDimension(__dmatrix,__nnewrows,__nnewcols) do{\
	float128_EGdMatrix_t*const __EGdm = (__dmatrix);\
	register int __EGdmi;\
	__EGdm->col_sz = (__nnewcols);\
	__EGdm->row_sz = (__nnewrows);\
	float128_EGlpNumReallocArray(&(__EGdm->matval),__EGdm->col_sz * __EGdm->row_sz);\
	EGrealloc(__EGdm->matrow,__EGdm->row_sz * sizeof(float128*));\
	int_EGlpNumReallocArray(&(__EGdm->col_ord),__EGdm->col_sz);\
	int_EGlpNumReallocArray(&(__EGdm->row_ord),__EGdm->row_sz);\
	__EGdmi = (int)(__EGdm->col_sz);\
	while(__EGdmi--) __EGdm->col_ord[__EGdmi] = __EGdmi;\
	__EGdmi = (int)(__EGdm->row_sz);\
	while(__EGdmi--) \
		__EGdm->matrow[__EGdmi] = __EGdm->matval + ((size_t)(__EGdmi) * __EGdm->col_sz);\
	__EGdmi = (int)(__EGdm->row_sz);\
	while(__EGdmi--) __EGdm->row_ord[__EGdmi] = __EGdmi;} while(0)

/* ========================================================================= */
/** @brief Display a given #float128_EGdMatrix_t structure contents.
 * @param __dmatrix dense matrix structure pointer.
 * @param __nat_order if set to one, display the matrix using the natural 
 * internal order, i.e. we discard the order of columns and rows as defined in
 * #float128_EGdMatrix_t::col_ord and #float128_EGdMatrix_t::row_ord. Otherwise, use such orders.
 * @param __ofile pointer to a FILE structure where we want the output to be
 * printed.
 * */
#define float128_EGdMatrixDisplay(__dmatrix,__nat_order,__ofile) do{\
	float128_EGdMatrix_t*const __EGdm = (__dmatrix);\
	char* __EGdmstr = 0;\
	size_t __EGdmi, __EGdmj;\
	fprintf(__ofile,"Matrix %p\nDimensions: %zd rows, %zd columns\n", (void*)__EGdm, __EGdm->row_sz, __EGdm->col_sz);\
	if(__nat_order){\
		for(__EGdmi = 0 ; __EGdmi < __EGdm->row_sz ; __EGdmi++){\
			for(__EGdmj = 0 ; __EGdmj < __EGdm->col_sz ; __EGdmj++){\
				__EGdmstr = float128_EGlpNumGetStr(__EGdm->matrow[__EGdmi][__EGdmj]);\
				fprintf(__ofile,"%10s ", __EGdmstr);\
				EGfree(__EGdmstr);\
			}\
			fprintf(__ofile,"\n");}\
	} else {\
		for(__EGdmi = 0 ; __EGdmi < __EGdm->row_sz ; __EGdmi++){\
			for(__EGdmj = 0 ; __EGdmj < __EGdm->col_sz ; __EGdmj++){\
				__EGdmstr = float128_EGlpNumGetStr(__EGdm->matrow[__EGdm->row_ord[__EGdmi]][__EGdm->col_ord[__EGdmj]]);\
				fprintf(__ofile,"%10s ", __EGdmstr);\
				EGfree(__EGdmstr);\
			}\
			fprintf(__ofile,"\n");}\
	}} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set rows 
 * '__dest' to '__dest' + '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in row '__dest', and note that rows '__orig' and '__dest' should be different.
 * This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the row whose multiple will be added to the '__dest'
 * row.
 * @param '__dest' row to be replaced by '__dest' + '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' row.
 * @note The index of the row are taken as internal index, i.e. if we give row
 * 'k' we will use the row stored in #float128_EGdMatrix_t::matrow[k], wich does not
 * mean that we will access the k-th row in the matrix (wich would need to use
 * as index the value #float128_EGdMatrix_t::row_ord[k] instead). Note that we don't
 * test wether the given multiple is zero or not. we always perform the
 * operation.
 * */
#define float128_EGdMatrixAddRowMultiple(__dmatrix,__dest,__orig,__num) do{\
	float128_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (size_t)(__dest);\
	const size_t __EGori = (size_t)(__orig);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) \
		float128_EGlpNumAddInnProdTo(__EGdm->matrow[__EGdest][__EGdmj],\
												__EGdm->matrow[__EGori][__EGdmj],__num);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set rows 
 * '__dest' to '__dest' - '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in row '__dest', and note that rows '__orig' and '__dest' should be different.
 * This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the row whose multiple will be added to the '__dest'
 * row.
 * @param '__dest' row to be replaced by '__dest' - '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' row.
 * @note The index of the row are taken as internal index, i.e. if we give row
 * 'k' we will use the row stored in #float128_EGdMatrix_t::matrow[k], wich does not
 * mean that we will access the k-th row in the matrix (wich would need to use
 * as index the value #float128_EGdMatrix_t::row_ord[k] instead). Note that we don't
 * test wether the given multiple is zero or not. we always perform the
 * operation.
 * */
#define float128_EGdMatrixSubRowMultiple(__dmatrix,__dest,__orig,__num) do{\
	float128_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (__dest);\
	const size_t __EGori = (__orig);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) \
		float128_EGlpNumSubInnProdTo(__EGdm->matrow[__EGdest][__EGdmj],\
												__EGdm->matrow[__EGori][__EGdmj],__num);\
	} while(0)
/* ========================================================================= */
/** @brief Given a number and a row, multiply the complete row by the given
 * number. Note that the number MUST_NOT be stored in the row being multiplied,
 * this is because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param row_ind index of the row being multiplied, note that we will multiply
 * the row stored in #float128_EGdMatrix_t::matrow[row_ind], wich is different to say
 * that we multiply the row in the row_ind-th position in the row ordering (to
 * do that, then row_ind should be #float128_EGdMatrix_t::row_ord[k]).
 * @param multiple constant to be multiply to the row.
 * */
#define float128_EGdMatrixMultiplyRow(__dmatrix,row_ind,multiple) do{\
	float128_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdmi = (row_ind);\
	size_t __EGdmj = __EGdm->col_sz;\
	while(__EGdmj--) float128_EGlpNumMultTo(__EGdm->matrow[__EGdmi][__EGdmj],multiple);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set columns 
 * '__dest' to '__dest' + '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in column '__dest', and note that columns '__orig' and '__dest' should be 
 * different. This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the column whose multiple will be added to the '__dest'
 * column.
 * @param '__dest' column to be replaced by '__dest' + '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' column.
 * @note The index of the column are taken as internal index, i.e. if we give 
 * column 'k' we will use the column stored in #float128_EGdMatrix_t::matrow[*][k], 
 * wich does not mean that we will access the k-th column in the matrix (wich
 * would need to use as index the value #float128_EGdMatrix_t::row_ord[k] instead). 
 * Note that we don't test wether the given multiple is zero or not. we 
 * always perform the operation.
 * */
#define float128_EGdMatrixAddColMultiple(__dmatrix,__dest,__orig,__num) do{\
	float128_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (__dest);\
	const size_t __EGori = (__orig);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) \
		float128_EGlpNumAddInnProdTo(__EGdm->matrow[__EGdmj][__EGdest],\
												__EGdm->matrow[__EGdmj][__EGori],__num);\
	} while(0)

/* ========================================================================= */
/** @brief Given a number '__num' and a two rows '__orig', '__dest', set columns 
 * '__dest' to '__dest' - '__orig' * '__num'. Note that the number MUST_NOT be stored 
 * in column '__dest', and note that columns '__orig' and '__dest' should be 
 * different. This is needed because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param '__orig' index of the column whose multiple will be added to the '__dest'
 * column.
 * @param '__dest' column to be replaced by '__dest' - '__orig' * '__num'.
 * @param '__num' constant to be multiply to the '__orig' and be added to the 
 * '__dest' column.
 * @note The index of the column are taken as internal index, i.e. if we give 
 * column 'k' we will use the column stored in #float128_EGdMatrix_t::matrow[*][k], 
 * wich does not mean that we will access the k-th column in the matrix (wich 
 * would need to use as index the value #float128_EGdMatrix_t::col_ord[k] instead). 
 * Note that we don't test wether the given multiple is zero or not. we 
 * always perform the operation.
 * */
#define float128_EGdMatrixSubColMultiple(__dmatrix,__dest,__orig,__num) do{\
	float128_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdest = (size_t)(__dest);\
	const size_t __EGori = (size_t)(__orig);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) \
		float128_EGlpNumSubInnProdTo(__EGdm->matrow[__EGdmj][__EGdest],\
												__EGdm->matrow[__EGdmj][__EGori],__num);\
	} while(0)
/* ========================================================================= */
/** @brief Given a number and a column, multiply the complete column by the 
 * given number. Note that the number MUST_NOT be stored in the column being 
 * multiplied, this is because of the way GNU_MP interface works.
 * @param __dmatrix dense matrix structure pointer.
 * @param __colind index of the column being multiplied, note that we will 
 * multiply the column stored in #float128_EGdMatrix_t::matrow[*][__colind], wich is 
 * different to say that we multiply the column in the __colind-th position in
 * the column ordering (to do that, then __colind should be 
 * #float128_EGdMatrix_t::col_ord[k]).
 * @param __mult constant to be multiply to the column.
 * */
#define float128_EGdMatrixMultiplyCol(__dmatrix,__colind,__mult) do{\
	float128_EGdMatrix_t*const __EGdm = (__dmatrix);\
	const size_t __EGdmi = (__colind);\
	size_t __EGdmj = __EGdm->row_sz;\
	while(__EGdmj--) float128_EGlpNumMultTo(__EGdm->matrow[__EGdmj][__EGdmi],__mult);\
	} while(0)


/* ========================================================================= */
/** @brief This function performs gaussian elimination to the given matrix,
 * depending on the given options it may do row/columns permutations allong the
 * way to improve numerical stabillity.
 * @param __dmatrix dense matrix structure pointer.
 * @param do_col_perm if set to one, the try columns permutation to improve
 * numericall stabillity, otherwise, not do column permutations at all.
 * @param do_row_perm if set to one, try row permutations to improve numericall
 * stabillity, otherwise, not do row permutations at all.
 * @param status pointer to where return an status, if the procedure finish all
 * the way (i.e. the matrix is full rank), then we return #EG_ALGSTAT_SUCCESS,
 * if the matrix is found to be partial rank, the status is
 * #EG_ALGSTAT_PARTIAL, otherwise, we return #EG_ALGSTAT_NUMERROR, wich means
 * that we stoped because a zero pivot was found (after checking for allowed
 * row/collumns permmutations).
 * @param rank where to return the (proven) rank of the matrix. This number is
 * accurate if the status is #EG_ALGSTAT_SUCCESS, or #EG_ALGSTAT_PARTIAL, but
 * is just a lower bound if the status is #EG_ALGSTAT_NUMERROR
 * @param zero_tol What is the threshold for a value to be considered zero.
 * @return if no error happen, we return zero, otherwise a non-zero valued is
 * returned. Note that the algorithm status is independent of the return value,
 * non zero values araise only if an error happen during execution, wich is
 * different to say that the algorithm didn't finish correctly. */
int float128_EGdMatrixGaussianElimination (float128_EGdMatrix_t * const __dmatrix,
																	const unsigned do_col_perm,
																	const unsigned do_row_perm,
																	unsigned *const rank,
																	const float128 zero_tol,
																	int *const status);

/* ========================================================================= */
/** @}*/
#endif
#endif
#endif
#ifdef HAVE_SOFTFLOAT
#if HAVE_SOFTFLOAT
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef float128___EG_DBASIS_REDUCTION__
#define float128___EG_DBASIS_REDUCTION__
/* ========================================================================= */
/** @defgroup EGdBasisRed LLL Basis Reduction
 * Here we define a common interface for dense matrices (i.e. a structure), and
 * some common operations over dense matrices. The definition uses EGlpNum as
 * reference number type, this allow for template initializations.
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2005-10-28
 *  					- First implementation.
 * */
/**  @{ */
/** @file
 * @brief This file provide the user interface and function definitions for
 * the so-called LLL Basis Reduction Algorithm. This algorithm was first
 * presented in the paper "Factoring polynomials with rational coefficients",
 * Mathematische Annalen 261 (1981), p515-534. and has been extensivelly
 * studied elsewere. for more details just Google-it.
 * */
/** @example float128_eg_dmatrix.ex.c */
/* ========================================================================= */
/** @brief verbosity level */
#define float128_EG_DBSRED_VERBOSE 0

/* ========================================================================= */
/** @name Profiling structures and functions for the basis reduction algorithm.
 * */
/* @{ */
/* ========================================================================= */
/** @brief where to hold the profile information */
extern uintmax_t float128_EGdBsRedStats[10];

/* ========================================================================= */
/** @brief where we store the number of calls to #float128_EGdBsRed */
#define float128_EG_BSRED_CALLS 0

/* ========================================================================= */
/** @brief where we store the total number of size reductions performed in 
 * #float128_EGdBsRed */
#define float128_EG_BSRED_SZRED 1

/* ========================================================================= */
/** @brief where we store the total number of interchanges performed in 
 * #float128_EGdBsRed */
#define float128_EG_BSRED_INTR 2

/* ========================================================================= */
/** @brief where we store the total number of innermost loops performed in 
 * #float128_EGdBsRed */
#define float128_EG_BSRED_ITT 3

/* ========================================================================= */
/** @brief Print into the given file stream, the current statistics related
 * to the #float128_EGdBsRed algorithm. And reset all counters to zero.
 * @param __ofile where we want to print the profile information. */
#define float128_EGdBsRedProfile(__ofile) do{\
	fprintf(__ofile,"LLL Basis Reduction Statistics:\n");\
	fprintf(__ofile,"\tNumber Calls    : %ju\n", float128_EGdBsRedStats[float128_EG_BSRED_CALLS]);\
	fprintf(__ofile,"\tLoops           : %ju\n", float128_EGdBsRedStats[float128_EG_BSRED_ITT]);\
	fprintf(__ofile,"\tSize Reductions : %ju\n", float128_EGdBsRedStats[float128_EG_BSRED_SZRED]);\
	fprintf(__ofile,"\tInterchanges    : %ju\n", float128_EGdBsRedStats[float128_EG_BSRED_INTR]);\
	memset(float128_EGdBsRedStats,0,sizeof(float128_EGdBsRedStats));} while(0)

/* @} */

/* ========================================================================= */
/** @brief Value used in condition two of the LLL algorithm, remember that this
 * number should be between \f$(1/4,1)\f$. By default we choose \f$\lambda =
 * \frac{2^{20}-1}{2^{20}} \approx .99999904632568359375 \f$. */
#define float128_EG_DBSRED_ALPHA 0x7ffffp-20

/* ========================================================================= */
/** @brief structure to hold all necesary data to perform the LLL's basis
 * reduction algorithm. */
typedef struct float128_EGdBsRed_t
{
	size_t dim;				/**< @brief Number of elements in the basis */
	size_t length;		/**< @brief Length of the vectors in the basis, note that
												 it should be that length >= dim */
	size_t basis_sz;	/**< @brief Actual length of the #float128_EGdBsRed_t::basis 
												 array */
	float128 **basis;/**< @brief array of pointers to arrays containing the 
												 vector basis in extended (including zero coef) form. 
												 The vectors themselves are considered as allocated 
												 outside. everything else is considered as internally
												 allocated. */
	float128_EGdMatrix_t GM;		/**< @brief Here we store and compute the Gram-Schmidt 
												 needed for the LLL basis reduction algorithm */
}
float128_EGdBsRed_t;

/* ========================================================================= */
/** @brief Initialize an #float128_EGdBsRed_t structure, as a basis with zero elements
 * of dimension zero.
 * @param __bsred pointer to an #float128_EGdBsRed_t structure.
 * */
#define float128_EGdBsRedInit(__bsred) do{\
	float128_EGdBsRed_t*const __EGdbs = (__bsred);\
	memset(__EGdbs,0,sizeof(float128_EGdBsRed_t));\
	float128_EGdMatrixInit(&(__EGdbs->GM));} while(0)

/* ========================================================================= */
/** @brief Free any internally allocated memory in a #float128_EGdBsRed_t structure.
 * @param __bsred pointer to an #float128_EGdBsRed_t structure.
 * */
#define float128_EGdBsRedClear(__bsred) do{\
	float128_EGdBsRed_t*const __EGdbs = (__bsred);\
	if(__EGdbs->basis) EGfree(__EGdbs->basis);\
	float128_EGdMatrixClear(&(__EGdbs->GM));} while(0)

/* ========================================================================= */
/** @brief reset an #float128_EGdBsRed_t structure as a basis without elements (note
 * that we do not reset the length of the vectors, just the number of vectors 
 * in the basis).
 * @param __bsred pointer to an #float128_EGdBsRed_t structure.
 * */
#define float128_EGdBsRedReset(__bsred) ((__bsred)->dim = 0)

/* ========================================================================= */
/** @brief set the length of the vectors used in the basis for an #float128_EGdBsRed_t
 * structure.
 * @param __bsred pointer to an #float128_EGdBsRed_t structure.
 * @param __new_length length of the vectors in the basis.
 * */
#define float128_EGdBsRedSetLength(__bsred,__new_length) ((__bsred)->length = (__new_length))

/* ========================================================================= */
/** @brief add a new vector to the basis.
 * @param __bsred pointer to an #float128_EGdBsRed_t structure.
 * @param __new_elem new vector to add to the basis.
 * */
#define float128_EGdBsRedAddElement(__bsred,__new_elem) do{\
	float128_EGdBsRed_t*const __EGdbs = (__bsred);\
	if(__EGdbs->basis_sz <= __EGdbs->dim){\
		__EGdbs->basis_sz += 10U;\
		EGrealloc(__EGdbs->basis,sizeof(float128*)*__EGdbs->basis_sz);}\
	__EGdbs->basis[__EGdbs->dim++] = (__new_elem);} while(0)

/* ========================================================================= */
/** @brief This function performs the so-called LLL basis reduction algorithm.
 * @param __bsred pointer to an #float128_EGdBsRed_t structure.
 * @param status where we return the status of the algorithm, if the algorithm
 * finish with non-zero reduced elements, the status is #EG_ALGSTAT_SUCCESS. if
 * the algorithm finish with some zero reduced vector, the status is
 * #EG_ALGSTAT_PARTIAL. if the algorithm stop because of numerical problems,
 * the status is #EG_ALGSTAT_NUMERROR.
 * @param zero_tol threshold for a number to be considered as zero.
 * @param dim pointer to a number where we return the dimension of the basis
 * that the algorithm could prove before running in any numerical problem. If
 * the algorithm stop with status #EG_ALGSTAT_SUCCESS, then this number should
 * be equal to #float128_EGdBsRed_t::dim. The vectors that we finish reducing are stored
 * in #float128_EGdMatrix_t::row_ord[0], ... , #float128_EGdMatrix_t::row_ord[dim], in the
 * #float128_EGdBsRed_t::GM matrix.
 * @return zero if the algorithm finish, non-zero if an unforeseen error occure
 * during execution. 
 * @par Details:
 * The implementation that we use introduce (as an heuristic step) the sorting
 * of the original basis vectors in increasing order according to their norms,
 * this simple step reduced the total running time of the algorithm, but does
 * not improve the theoretical running time. A second detail is that we only
 * compute the Gram-Schmidth coefficients only once (at the beggining of the
 * program), and then, we only update the changed entries for both operations
 * \a size \a reduction and \a interchange. The advantage of the approach is
 * that we save most Gram-Schmidth computations and also all the recomputations
 * of the inner products of the elements currently in the basis. Again, this
 * are improvements form the practical point of view, but not in practice. The
 * dissadvantage of this approach is that we do accumulate rounding errors in
 * the Gram-Schmidth coefficients allong the way, but if all original vectors
 * coefficients where integer (and not too big), then the error should not grow
 * too much. Still this may happen if the input basis is ill conditioned.
 * */
int float128_EGdBsRed (float128_EGdBsRed_t * const __bsred,
							unsigned *const dim,
							const float128 zero_tol,
							int *const status);

/* ========================================================================= */
/**  @} */
#endif
#endif
#endif
#ifdef HAVE_SOFTFLOAT
#if HAVE_SOFTFLOAT
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGeHeap EGeHeap
 *
 * Here we define the basic interface for d-heaps as an embeded structure.
 * In this implementation the heap does not grow on the fly, meaning that it 
 * may fills-up during an add call, to avoid that, the user must call 
 * re-allocate when necesary. the heap start as a heap of size zero. 
 * This implementatioon is a minimum-heap implementatiton. Note also that the
 * internal connector array is shifted one position to the left. This is done 
 * so that the first element is in position 1, this also speed-up the 
 * computation of the parent and childrens of a given position.
 *
 * @version 0.0.1
 * @par History:
 * - 2010-09-05
 * 						- float128_EGeHeapClear will free any internal memory (even if it was
 * 						asked for by the user).
 * - 2005-07-14
 * 						- Add float128_EGeHeapEmpty to empty the heap (but keep its maximum
 * 							size)
 * 						- Add float128_EGeHeapIsFull to test wether a heap is full or not.
 * - 2005-07-07
 * 						- First Implementation
 * @note 
 * This implementatiton is designed as a template using as base the types of
 * @ref EGlpNum
 * */
/** @file 
 * @ingroup EGeHeap */
/** @addtogroup EGeHeap */
/** @{ */
/** @example float128_eg_eheap.ex.c
 * This is a simple example of the usage of heaps using @ref EGeHeap */
/* ========================================================================= */
#ifndef float128___EG_EHEAP__
#define float128___EG_EHEAP__
/* ========================================================================= */
/** @brief Debug level for the heap */
#ifndef float128_EG_EHEAP_DEBUG
#define float128_EG_EHEAP_DEBUG 1000
#endif

/* ========================================================================= */
/** @name Test macros, enabled only if debug level is high enough. */
/** @{ */
#if float128_EG_EHEAP_DEBUG <= DEBUG
#define float128_EGeHeapCHECK_CN(__hp2,__hcn2) EXIT(__hcn2->pos>=__hp2->sz,"Heap Connector possition %d out of range [0,%d]",__hcn2->pos,__hp2->sz)
#define float128_EGeHeapCHECK_NF(__hp2) EXIT(__hp2->sz >= __hp2->max_sz,"Heap "#__hp2" Is full, can't add an element")
#else
#define float128_EGeHeapCHECK_CN(__hp,__hcn) 
#define float128_EGeHeapCHECK_NF(__hp) 
#endif
/** @} */
/* ========================================================================= */
/** @brief Structure to store the information relevant to an element in the
 * heap. */
typedef struct 
{
	float128 val;		/**< Value of this node in the heap */
	unsigned int pos;	/**< Position in the heap array for this node, if set to
												 #float128_EG_EHEAP_POISON, then the connector is not in any 
												 heap.*/
}
float128_EGeHeapCn_t;

/* ========================================================================= */
/** @brief Poison position for heap connector not in a heap. */
#define float128_EG_EHEAP_POISON UINT_MAX

/* ========================================================================= */
/** @brief Initialize a heap conector structure. This function will allocate any
 * interal memory not allocated by the user, it should be called only once, or
 * after a clear function call.
 * @param __hcn conector to initialize.
 * */
#define float128_EGeHeapCnInit(__hcn) ({float128_EGlpNumInitVar((__hcn)->val);(__hcn)->pos = float128_EG_EHEAP_POISON;})

/* ========================================================================= */
/** @brief Reset a heap conector to the same state as after an init call, this
 * function is provided only for completness.
 * @param __hcn conector to reset
 * */
#define float128_EGeHeapCnReset(__hcn) ((__hcn)->pos = float128_EG_EHEAP_POISON)

/* ========================================================================= */
/** @brief Free all internal memory used by this structured not allocated by the
 * user. This function should be called after an init call, and only once.
 * @param __hcn conector to clear.
 * */
#define float128_EGeHeapCnClear(__hcn) float128_EGlpNumClearVar((__hcn)->val)

/* ========================================================================= */
/** @brief Structure to hold a whole heap structure, this structure is designed
 * so that it can grow on the fly with a low cost */
typedef struct 
{
	float128_EGeHeapCn_t **cn;
	unsigned int d;
	unsigned int sz;
	unsigned int max_sz;
}
float128_EGeHeap_t;

/* ========================================================================= */
/** @brief Return one if the heap is full, zero otherwise.
 * @param __hp heat to check */
#define float128_EGeHeapIsFull(__hp) ({float128_EGeHeap_t*const __EGehp = (__hp); __EGehp->sz == __EGehp->max_sz;})

/* ========================================================================= */
/** @brief set the number of elements in hte heap to zero.
 * @param __hp heap to empty.
 * */
#define float128_EGeHeapEmpty(__hp) ((__hp)->sz = 0)

/* ========================================================================= */
/** @brief Initialize a heap as an empty heap (with no space for conectors).
 * @param __hp heap to initialize.
 * */
#define float128_EGeHeapInit(__hp) (*(__hp) = (float128_EGeHeap_t){0,0,0,0})

/* ========================================================================= */
/** @brief Reset the given heap as an empty heap (just as returned by the init
 * call.
 * @param __hp heap to reset 
 * */
#define float128_EGeHepReset(__hp) float128_EGeHeapResize(__hp,0)

/* ========================================================================= */
/** @brief Clear a heap structure, and free any internal memory (not allocated
 * by the user).
 * @param __hp heap to clear.
 * */
#define float128_EGeHeapClear(__hp) float128_EGeHeapResize(__hp,0)

/* ========================================================================= */
/** @brief get the minimum value in the heap.
 * @param __hp heap where we are working.
 * @param number where to store the result
 * @return zero on success, non-zero otherwise.
 * */
#define float128_EGeHeapGetMinVal(__hp,number) ({\
	float128_EGeHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? (float128_EGlpNumCopy(number,__EGehp->cn[0]->val),0):1;})

/* ========================================================================= */
/** @brief get the minimum conector in the heap, if the heap is empty, return
 * NULL.
 * @param __hp eap where we are working.
 * @return pointer to the minimum element in the heap.
 * */
#define float128_EGeHeapGetMin(__hp) ({\
	float128_EGeHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? __EGehp->cn[0] : 0;})

/* ========================================================================= */
/** @brief resize the heap cn array to the given size, if the new size is zero,
 * it is equivalent to free the internal memory, and left the heap as an empty
 * heap with zero space.
 * @param __hp heap where we are working.
 * @param new_sz new size for the  cn array .
 * */
#define float128_EGeHeapResize(__hp,new_sz) ({\
	float128_EGeHeap_t*const __EGehp = (__hp);\
	const size_t __EGehp_nsz = (size_t)(new_sz);\
	__EGehp->cn = EGrealloc((__EGehp->cn), __EGehp_nsz * sizeof(float128_EGeHeapCn_t*));\
	__EGehp->max_sz = (unsigned int)(__EGehp_nsz);})

/* ========================================================================= */
/** @brief return the index of the father of the given index.
 * @param __d breadth of the heap.
 * @param __id position in the array to wich we want to compute it's father.
 * */
#define float128_EGeHeapFatherId(__d,__id) ((__id)?(((__id)-1)/(__d)):0)

/* ========================================================================= */
/** @brief move an element in the heap up in the heap (position 0 is the top,
 * this kind of move is neded whenever we decrease the value in a heap element).
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * */
#define float128_EGeHeapSiftUp(__hp,__hcn) ({\
	float128_EGeHeap_t*const __EGehp = (__hp);\
	float128_EGeHeapCn_t*const __EGecn = (__hcn);\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfpos = float128_EGeHeapFatherId(__EGehp->d,__EGcpos);\
	float128_EGeHeapCn_t*__EGfcn = __EGehp->cn[__EGfpos];\
	float128_EGeHeapCHECK_CN(__EHehp,__EGecn);\
	while(__EGcpos && \
				float128_EGlpNumIsLess(__EGecn->val,__EGfcn->val))\
	{\
		__EGfcn->pos = __EGcpos;\
		__EGehp->cn[__EGcpos] = __EGfcn;\
		__EGcpos = __EGfpos;\
		__EGfpos = float128_EGeHeapFatherId(__EGehp->d,__EGcpos);\
		__EGfcn = __EGehp->cn[__EGfpos];\
	}\
	__EGecn->pos = __EGcpos;\
	__EGehp->cn[__EGcpos] = __EGecn;\
	0;})

/* ========================================================================= */
/** @brief Add an element to the heap
 * @param __hp heap where to add the element.
 * @param __hcn element to be added.
 * @return zero on success, non-zero otherwise.
 * */
#define float128_EGeHeapAdd(__hp,__hcn) ({\
	float128_EGeHeap_t*const __EGlhp = (__hp);\
	float128_EGeHeapCn_t*const __EGlcn = (__hcn);\
	float128_EGeHeapCHECK_NF(__EGlhp);\
	__EGlcn->pos = __EGlhp->sz, \
	__EGlhp->cn[__EGlhp->sz] = __EGlcn;\
	__EGlhp->sz +=1, \
	float128_EGeHeapSiftUp(__EGlhp,__EGlcn), 0;})

/* ========================================================================= */
/** @brief Give the first child for a given position.
 * @param __id position that we want to get the first child.
 * @param __d breath of the heap. */
#define float128_EGeHeapFirstChildId(__d,__id) ((__d)*(__id)+1)

/* ========================================================================= */
/** @brief Move an element down in the heap (position 0 is the
 * top), this kind of operation is needed whenever we increase the value in a
 * heap element.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define float128_EGeHeapSiftDown(__hp,__hcn) ({\
	float128_EGeHeap_t*const __EGehp = (__hp);\
	float128_EGeHeapCn_t*const __EGecn = (__hcn);\
	const unsigned int __EGhsz = __EGehp->sz;\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfchd = float128_EGeHeapFirstChildId(__EGehp->d,__EGcpos);\
	unsigned int __EGlchd = __EGfchd + __EGehp->d;\
	float128_EGeHeapCn_t*__EGcchd = 0;\
	register unsigned int __EGehi = 0;\
	float128_EGeHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGfchd < __EGhsz)\
	{\
		/* detect the minimum child */\
		__EGcchd = __EGehp->cn[__EGfchd];\
		for(__EGehi = __EGlchd > __EGhsz ? __EGhsz-1 : __EGlchd-1 ;\
			__EGehi > __EGfchd ; __EGehi--)\
			if(float128_EGlpNumIsLess(__EGehp->cn[__EGehi]->val,__EGcchd->val))\
				__EGcchd = __EGehp->cn[__EGehi];\
		/* if the minimum child is less than the current position, move the minimum\
		 * child to the position of the current element */\
		if(float128_EGlpNumIsLess(__EGcchd->val,__EGecn->val))\
		{\
			__EGfchd = __EGcchd->pos;\
			__EGcchd->pos = __EGcpos;\
			__EGehp->cn[__EGcpos] = __EGcchd;\
			__EGecn->pos = __EGcpos = __EGfchd;\
			__EGehp->cn[__EGcpos] = __EGecn;\
			__EGfchd = float128_EGeHeapFirstChildId(__EGehp->d,__EGcpos);\
			__EGlchd = __EGfchd + __EGehp->d;\
		}\
		/* else we exit the main loop */\
		else __EGfchd = UINT_MAX;\
	}\
	0;})

/* ========================================================================= */
/** @brief Change the value of an element in the heap.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap that we are going to change it's value.
 * @param __new_val new value for the element.
 * @return zero on success, non-zero otherwise.
 * */
#define float128_EGeHeapChangeVal(__hp,__hcn,__new_val) ({\
	(float128_EGlpNumIsLess(__new_val,(__hcn)->val)) ? (float128_EGlpNumCopy((__hcn)->val,__new_val),float128_EGeHeapSiftUp(__hp,__hcn)) : (float128_EGlpNumCopy((__hcn)->val,__new_val),float128_EGeHeapSiftDown(__hp,__hcn));})

/* ========================================================================= */
/** @brief Eliminate an element from the heap, note that the position stored in
 * the eliminated element is reset to zero.
 * @param __hp heap where we are working.
 * @param __hcn element to eliminate from the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define float128_EGeHeapDel(__hp,__hcn) ({\
	float128_EGeHeap_t*const __EGlhp = (__hp);\
	float128_EGeHeapCn_t*const __EGlhpcn = (__hcn);\
	unsigned int const __EGlcn = __EGlhpcn->pos;\
	unsigned int const __EGlhsz = __EGlhp->sz - 1;\
	__EGlhpcn->pos = float128_EG_EHEAP_POISON;\
	__EGlhp->sz = __EGlhsz;\
	if(__EGlhsz && __EGlhsz != __EGlcn){\
		__EGlhp->cn[__EGlcn] = __EGlhp->cn[__EGlhp->sz];\
		__EGlhp->cn[__EGlcn]->pos = __EGlcn;\
		float128_EGeHeapSiftDown(__EGlhp,__EGlhp->cn[__EGlcn]);}\
	__EGlhp->cn[__EGlhp->sz] = 0;})

/* ========================================================================= */
/** @brief Check the integrity of the given heap.
 * @param __hp heap to check.
 * @return zero on success, non-zero otherwise.
 * */
#if float128_EG_EHEAP_DEBUG <= DEBUG
#define float128_EGeHeapCheck(__hp) ({\
	float128_EGeHeap_t*const __EGehp = (__hp);\
	register unsigned int __EGehi = __EGehp->sz;\
	if(__EGehi)\
		while(--__EGehi)\
			if(__EGehp->cn[__EGehi]->pos != __EGehi || float128_EGlpNumIsLess( __EGehp->cn[\
				 __EGehi]->val,__EGehp->cn[float128_EGeHeapFatherId(__EGehp->d,__EGehi)]->val))\
			{\
				MESSAGE(float128_EG_EHEAP_DEBUG,"Element %u is wrong, pos %u val [%lf,%lf]"\
							 ,__EGehi, __EGehp->cn[__EGehi]->pos, \
							 float128_EGlpNumToLf(__EGehp->cn[__EGehi]->val), \
							 float128_EGlpNumToLf(__EGehp->cn[float128_EGeHeapFatherId(__EGehp->d,__EGehi)]->val));\
				break;\
			}\
	__EGehi;})
#else
#define float128_EGeHeapCheck(__hp) 0
#endif

/* ========================================================================= */
/** @brief set the breath of the heap, this function must be called only when
 * the heap is empty.
 * @param __hp heap to set breath.
 * @param __width new with for the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define float128_EGeHeapChangeD(__hp,__width) ({\
	float128_EGeHeap_t*const __EGehp = (__hp);\
	EXIT((__width)<2,"Width should be at least 2 for heaps");\
	__EGehp->sz ? 1 : (__EGehp->d = (__width), 0);})

/* ========================================================================= */
/** @} */
/* end of float128_eg_eheap.h */
#endif
#endif
#endif
#ifdef HAVE_SOFTFLOAT
#if HAVE_SOFTFLOAT
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGeKHeap EGeKHeap
 *
 * Here we define the basic interface for d-heaps with an array of values with
 * the lexicographic order for vectors as an embeded structure.
 * In this implementation the heap does not grow on the fly, meaning that it 
 * may fill-up during an add call, to avoid that, the user must call 
 * re-allocate when necesary. the heap start as a heap of size zero. 
 * This implementatioon is a minimum-heap implementatiton. Note also that the
 * internal connector array is shifted one position to the left. This is done 
 * so that the first element is in position 1, this also speed-up the 
 * computation of the parent and childrens of a given position.
 *
 * @version 0.0.1
 * @par History:
 * - 2010-09-05
 * 						- Change implementation of float128_EGeKHeapClear to free all internal
 * 						memory, including the one asked for the user during a
 * 						float128_EGeKHeapResize call.
 * - 2008-07-30
 * 						- First implementation
 * @note 
 * This implementatiton is designed as a template using as base the types of
 * @ref EGlpNum
 * */
/** @file 
 * @ingroup EGeKHeap */
/** @addtogroup EGeKHeap */
/** @{ */
/** @example float128_eg_ekheap.ex.c
 * This is a simple example of the usage of heaps using @ref EGeKHeap */
/* ========================================================================= */
#ifndef float128___EG_EKHEAP__
#define float128___EG_EKHEAP__
/* ========================================================================= */
/** @brief Debug level for the heap */
#ifndef float128_EG_EKHEAP_DEBUG
#define float128_EG_EKHEAP_DEBUG 100
#endif

/* ========================================================================= */
/** @name Test macros, enabled only if debug level is high enough. */
/** @{ */
#if float128_EG_EKHEAP_DEBUG <= DEBUG
#define float128_EGeKHeapCHECK_CN(__hp2,__hcn2) EXIT(__hcn2->pos>=__hp2->sz,"Heap Connector possition %d out of range [0,%d]",__hcn2->pos,__hp2->sz)
#define float128_EGeKHeapCHECK_NF(__hp2) EXIT(__hp2->sz >= __hp2->max_sz,"Heap "#__hp2" Is full, can't add an element")
#else
#define float128_EGeKHeapCHECK_CN(__hp,__hcn) 
#define float128_EGeKHeapCHECK_NF(__hp) 
#endif
/** @} */
/* ========================================================================= */
/** @brief number of maximum entries in the vector values */
#ifndef float128_EG_EKHEAP_ENTRY
#define float128_EG_EKHEAP_ENTRY 3
#endif
/* ========================================================================= */
/** @brief Structure to store the information relevant to an element in the
 * heap. */
typedef struct
{
	float128 val[float128_EG_EKHEAP_ENTRY];/**< Value of this node in the heap */
	unsigned int pos;	/**< Position in the heap array for this node, if set to
												 #float128_EG_EKHEAP_POISON, then the connector is not in any 
												 heap.*/
}
float128_EGeKHeapCn_t;

/* ========================================================================= */
/** @brief Poison position for heap connector not in a heap. */
#define float128_EG_EKHEAP_POISON UINT_MAX

/* ========================================================================= */
/** @brief Initialize a heap conector structure. This function will allocate any
 * interal memory not allocated by the user, it should be called only once, or
 * after a clear function call.
 * @param __hcn conector to initialize.
 * */
#define float128_EGeKHeapCnInit(__hcn) do{\
	float128_EGeKHeapCn_t*const __EKHcn = (__hcn);\
	int __EKHi = float128_EG_EKHEAP_ENTRY;\
	memset(__EKHcn,0,sizeof(float128_EGeKHeapCn_t));\
	for( ; __EKHi-- ; ){float128_EGlpNumInitVar(__EKHcn->val[__EKHi]);}\
	__EKHcn->pos = float128_EG_EKHEAP_POISON;}while(0)

/* ========================================================================= */
/** @brief Reset a heap conector to the same state as after an init call, this
 * function is provided only for completness.
 * @param __hcn conector to reset
 * */
#define float128_EGeKHeapCnReset(__hcn) ((__hcn)->pos = float128_EG_EKHEAP_POISON)

/* ========================================================================= */
/** @brief Free all internal memory used by this structured not allocated by the
 * user. This function should be called after an init call, and only once.
 * @param __hcn conector to clear.
 * */
#define float128_EGeKHeapCnClear(__hcn) do{\
	float128_EGeKHeapCn_t*const __EKHcn = (__hcn);\
	int __EKHi = float128_EG_EKHEAP_ENTRY;\
	for( ; __EKHi-- ; ){float128_EGlpNumClearVar(__EKHcn->val[__EKHi]);}}while(0)

/* ========================================================================= */
/** @brief Structure to hold a whole heap structure, this structure is designed
 * so that it can grow on the fly with a low cost */
typedef struct
{
	float128_EGeKHeapCn_t **cn;
	unsigned int d;
	unsigned int sz;
	unsigned int max_sz;
}
float128_EGeKHeap_t;

/* ========================================================================= */
/** @brief Return one if the heap is full, zero otherwise.
 * @param __hp heat to check */
#define float128_EGeKHeapIsFull(__hp) ({float128_EGeKHeap_t*const __EGekhp = (__hp); __EGekhp->sz == __EGekhp->max_sz;})

/* ========================================================================= */
/** @brief set the number of elements in hte heap to zero.
 * @param __hp heap to empty.
 * */
#define float128_EGeKHeapEmpty(__hp) ((__hp)->sz = 0)

/* ========================================================================= */
/** @brief Initialize a heap as an empty heap (with no space for conectors).
 * @param __hp heap to initialize.
 * */
#define float128_EGeKHeapInit(__hp) (*(__hp) = (float128_EGeKHeap_t){0,0,0,0})

/* ========================================================================= */
/** @brief Reset the given heap as an empty heap (just as returned by the init
 * call.
 * @param __hp heap to reset 
 * */
#define float128_EGeKHepReset(__hp) float128_EGeKHeapResize(__hp,0)

/* ========================================================================= */
/** @brief Clear a heap structure, and free any internal memory (not allocated
 * by the user).
 * @param __hp heap to clear.
 * */
#define float128_EGeKHeapClear(__hp) float128_EGeKHeapResize(__hp,0)

/* ========================================================================= */
/** @brief get the minimum value in the heap, note that since we are dealing
 * with a vector of values sorted lexicographically, the value is the value in
 * the first coordinate, other values can be accesses through
 * float128_EGeKHeapGetMinKVal function.
 * @param __hp heap where we are working.
 * @param __number where to store the result
 * @return zero on success, non-zero otherwise.
 * */
#define float128_EGeKHeapGetMinVal(__hp,__number) ({\
	float128_EGeKHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? (float128_EGlpNumCopy(__number,__EGehp->cn[0]->val[0]),0):1;})

/* ========================================================================= */
/** @brief get the k-th value of the first element in the heap.
 * @param __hp heap where we are working.
 * @param __number where to store the result.
 * @param __k which value to get (between 0 and float128_EG_EKHEAP_ENTRY.
 * @return zero on success, non-zero otherwise.
 * */
#define float128_EGeKHeapGetMinKVal(__hp,__k,__number) ({\
	float128_EGeKHeap_t*const __EGehp = (__hp);\
	const int __EGki = (__k);\
	EXITL(float128_EG_EKHEAP_DEBUG,(__EGki >= float128_EG_EKHEAP_ENTRY) || (__EGki <0),\
				"K=%d out of range in float128_EGeKHeapGetMinKVal", __EGki);\
	__EGehp->sz ? (float128_EGlpNumCopy(__number,__EGehp->cn[0]->val[__EGki]),0):1;})

/* ========================================================================= */
/** @brief get the minimum conector in the heap, if the heap is empty, return
 * NULL.
 * @param __hp eap where we are working.
 * @return pointer to the minimum element in the heap.
 * */
#define float128_EGeKHeapGetMin(__hp) ({\
	float128_EGeKHeap_t*const __EGehp = (__hp);\
	__EGehp->sz ? __EGehp->cn[0] : 0;})

/* ========================================================================= */
/** @brief resize the heap cn array to the given size, if the new size is zero,
 * it is equivalent to free the internal memory, and left the heap as an empty
 * heap with zero space.
 * @param __hp heap where we are working.
 * @param __new_sz new size for the  cn array .
 * */
#define float128_EGeKHeapResize(__hp,__new_sz) ({\
	float128_EGeKHeap_t*const __EGehp = (__hp);\
	const size_t __EGehp_nsz = (size_t)(__new_sz);\
	__EGehp->cn = EGrealloc((__EGehp->cn), __EGehp_nsz * sizeof(float128_EGeKHeapCn_t*));\
	__EGehp->max_sz = (unsigned int)(__EGehp_nsz);})

/* ========================================================================= */
/** @brief return the index of the father of the given index.
 * @param __d breadth of the heap.
 * @param __id position in the array to wich we want to compute it's father.
 * */
#define float128_EGeKHeapFatherId(__d,__id) ((__id)?(((__id)-1)/(__d)):0)

/* ========================================================================= */
/** @brief given two heap connectors, return one if the first is less than the
 * second (in  lexicographic order).
 * @param __hcn1 first vector array.
 * @param __hcn2 second vector array.
 * @return one if __hcn1 <_LEX __hcn2 */
#define float128_EGeKHeapIsLess(__hcn1,__hcn2) ({\
	float128*const __EGEKH1 = (__hcn1);\
	float128*const __EGEKH2 = (__hcn2);\
	int __EGEKHj = 0, __EGEKHrval = 0;\
	for( ; __EGEKHj < float128_EG_EKHEAP_ENTRY ; __EGEKHj++)\
	{\
		if(float128_EGlpNumIsLess(__EGEKH1[__EGEKHj], __EGEKH2[__EGEKHj])){\
			__EGEKHrval = 1; break;}\
		else if (float128_EGlpNumIsNeq(__EGEKH1[__EGEKHj], __EGEKH2[__EGEKHj],float128_epsLpNum)){\
			__EGEKHrval = 0; break;}\
	}\
	__EGEKHrval;})

/* ========================================================================= */
/** @brief copy two vector of values (only  float128_EG_EKHEAP_ENTRY positions) from the
 * rource to the destination.
 * @param src float128_source array.
 * @param dst destination array.
 * */
void float128_EGeKHeapCopyVal(float128*const dst, const float128*const src);

/* ========================================================================= */
/** @brief move an element in the heap up in the heap (position 0 is the top,
 * this kind of move is neded whenever we decrease the value in a heap element).
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define float128_EGeKHeapSiftUp(__hp,__hcn) ({\
	float128_EGeKHeap_t*const __EGehp = (__hp);\
	float128_EGeKHeapCn_t*const __EGecn = (__hcn);\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfpos = float128_EGeKHeapFatherId(__EGehp->d,__EGcpos);\
	float128_EGeKHeapCn_t*__EGfcn = __EGehp->cn[__EGfpos];\
	float128_EGeKHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGcpos && \
				float128_EGeKHeapIsLess(__EGecn->val,__EGfcn->val))\
	{\
		__EGfcn->pos = __EGcpos;\
		__EGehp->cn[__EGcpos] = __EGfcn;\
		__EGcpos = __EGfpos;\
		__EGfpos = float128_EGeKHeapFatherId(__EGehp->d,__EGcpos);\
		__EGfcn = __EGehp->cn[__EGfpos];\
	}\
	__EGecn->pos = __EGcpos;\
	__EGehp->cn[__EGcpos] = __EGecn;\
	0;})

/* ========================================================================= */
/** @brief Add an element to the heap
 * @param __hp heap where to add the element.
 * @param __hcn element to be added.
 * @return zero on success, non-zero otherwise.
 * */
#define float128_EGeKHeapAdd(__hp,__hcn) ({\
	float128_EGeKHeap_t*const __EGlhp = (__hp);\
	float128_EGeKHeapCn_t*const __EGlcn = (__hcn);\
	float128_EGeKHeapCHECK_NF(__EGlhp);\
	__EGlcn->pos = __EGlhp->sz, \
	__EGlhp->cn[__EGlhp->sz] = __EGlcn, \
	__EGlhp->sz +=1, \
	float128_EGeKHeapSiftUp(__EGlhp,__EGlcn), 0;})

/* ========================================================================= */
/** @brief Give the first child for a given position.
 * @param __id position that we want to get the first child.
 * @param __d breath of the heap. */
#define float128_EGeKHeapFirstChildId(__d,__id) ((__d)*(__id)+1)

/* ========================================================================= */
/** @brief Move an element down in the heap (position 0 is the
 * top), this kind of operation is needed whenever we increase the value in a
 * heap element.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap to move.
 * @return zero on success, non-zero otherwise.
 * */
#define float128_EGeKHeapSiftDown(__hp,__hcn) ({\
	float128_EGeKHeap_t*const __EGehp = (__hp);\
	float128_EGeKHeapCn_t*const __EGecn = (__hcn);\
	const unsigned int __EGhsz = __EGehp->sz;\
	unsigned int __EGcpos = __EGecn->pos;\
	unsigned int __EGfchd = float128_EGeKHeapFirstChildId(__EGehp->d,__EGcpos);\
	unsigned int __EGlchd = __EGfchd + __EGehp->d;\
	float128_EGeKHeapCn_t*__EGcchd = 0;\
	register unsigned int __EGehi = 0;\
	float128_EGeKHeapCHECK_CN(__EGehp,__EGecn);\
	while(__EGfchd < __EGhsz)\
	{\
		/* detect the minimum child */\
		__EGcchd = __EGehp->cn[__EGfchd];\
		for(__EGehi = __EGlchd > __EGhsz ? __EGhsz-1 : __EGlchd-1 ;\
			__EGehi > __EGfchd ; __EGehi--)\
			if(float128_EGeKHeapIsLess(__EGehp->cn[__EGehi]->val,__EGcchd->val))\
				__EGcchd = __EGehp->cn[__EGehi];\
		/* if the minimum child is less than the current position, move the minimum\
		 * child to the position of the current element */\
		if(float128_EGeKHeapIsLess(__EGcchd->val,__EGecn->val))\
		{\
			__EGfchd = __EGcchd->pos;\
			__EGcchd->pos = __EGcpos;\
			__EGehp->cn[__EGcpos] = __EGcchd;\
			__EGecn->pos = __EGcpos = __EGfchd;\
			__EGehp->cn[__EGcpos] = __EGecn;\
			__EGfchd = float128_EGeKHeapFirstChildId(__EGehp->d,__EGcpos);\
			__EGlchd = __EGfchd + __EGehp->d;\
		}\
		/* else we exit the main loop */\
		else __EGfchd = UINT_MAX;\
	}\
	0;})

/* ========================================================================= */
/** @brief Change the value of an element in the heap.
 * @param __hp heap where we are working.
 * @param __hcn element in the heap that we are going to change it's value.
 * @param __new_val new value for the element (note this is an array of size at
 * least float128_EG_EKHEAP_ENTRY.
 * @return zero on success, non-zero otherwise.
 * */
#define float128_EGeKHeapChangeVal(__hp,__hcn,__new_val) ({\
	float128_EGeKHeapCn_t*const __EGEKHcn = (__hcn);\
	(float128_EGeKHeapIsLess(__new_val,(__EGEKHcn)->val)) ? (float128_EGeKHeapCopyVal((__EGEKHcn)->val,__new_val),float128_EGeKHeapSiftUp(__hp,__EGEKHcn)) : (float128_EGeKHeapCopyVal((__EGEKHcn)->val,__new_val),float128_EGeKHeapSiftDown(__hp,__EGEKHcn));})

/* ========================================================================= */
/** @brief Eliminate an element from the heap, note that the position stored in
 * the eliminated element is reset to zero.
 * @param __hp heap where we are working.
 * @param __hcn element to eliminate from the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define float128_EGeKHeapDel(__hp,__hcn) ({\
	float128_EGeKHeap_t*const __EGlhp = (__hp);\
	float128_EGeKHeapCn_t*const __EGlhpcn = (__hcn);\
	unsigned int const __EGlcn = __EGlhpcn->pos;\
	unsigned int const __EGlhsz = __EGlhp->sz - 1;\
	__EGlhpcn->pos = float128_EG_EKHEAP_POISON;\
	__EGlhp->sz = __EGlhsz;\
	if(__EGlhsz && __EGlhsz != __EGlcn){\
		__EGlhp->cn[__EGlcn] = __EGlhp->cn[__EGlhp->sz];\
		__EGlhp->cn[__EGlcn]->pos = __EGlcn;\
		float128_EGeKHeapSiftDown(__EGlhp,__EGlhp->cn[__EGlcn]);}\
	__EGlhp->cn[__EGlhp->sz] = 0;})

/* ========================================================================= */
/** @brief Check the integrity of the given heap.
 * @param __hp heap to check.
 * @return zero on success, non-zero otherwise.
 * */
#if float128_EG_EKHEAP_DEBUG <= DEBUG
#define float128_EGeKHeapCheck(__hp) ({\
	float128_EGeKHeap_t*const __EGehp = (__hp);\
	register unsigned int __EGehi = __EGehp->sz;\
	if(__EGehi)\
		while(--__EGehi)\
			if(__EGehp->cn[__EGehi]->pos != __EGehi || \
				float128_EGeKHeapIsLess( __EGehp->cn[__EGehi]->val,\
												__EGehp->cn[float128_EGeKHeapFatherId(__EGehp->d,__EGehi)]->val))\
			{\
				MESSAGE(float128_EG_EKHEAP_DEBUG,"Element %u is wrong, pos %u val [%lf,%lf]"\
							 ,__EGehi, __EGehp->cn[__EGehi]->pos, \
							 float128_EGlpNumToLf(__EGehp->cn[__EGehi]->val[0]), \
							 float128_EGlpNumToLf(__EGehp->cn[float128_EGeKHeapFatherId(__EGehp->d,__EGehi)]->val[0]));\
				break;\
			}\
	__EGehi;})
#else
#define float128_EGeKHeapCheck(__hp) 0
#endif

/* ========================================================================= */
/** @brief set the breath of the heap, this function must be called only when
 * the heap is empty.
 * @param __hp heap to set breath.
 * @param __width new with for the heap.
 * @return zero on success, non-zero otherwise.
 * */
#define float128_EGeKHeapChangeD(__hp,__width) ({\
	float128_EGeKHeap_t*const __EGehp = (__hp);\
	EXIT((__width)<2,"Width should be at least 2 for heaps");\
	__EGehp->sz ? 1 : (__EGehp->d = (__width), 0);})

/* ========================================================================= */
/** @} */
/* end of float128_eg_ekheap.h */
#endif
#endif
#endif
#ifdef HAVE_SOFTFLOAT
#if HAVE_SOFTFLOAT
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGsrkGraph EGsrkGraph
 * This is a group of functions, macros and types designed to work with
 * graphs that are shrinkable, meaning that we can take two nodes in the
 * (current) graph, and shrink them into a single node, and at the same time
 * collapse all edges that become loops and if two edges are parallel, keep
 * just one (but keep a reference to the collapsed edge). At the same time the
 * shrunken nodes keep a list to the nodes 'embeded' or 'shrunken' into the
 * given node. More details in the structure definition and in the example.
 * Note that this implementation only support undirected graphs with actual
 * weights on the edges, the weights must be of type float128, and their
 * values are updated during the shrinking procedure, so if anyone want to
 * have the original values omewere else, they will have to keep an extra copy
 * outside. Most of the ideas used in this implementation come from CONCORDE.
 * 
 * @version 0.0.1
 * @par History:
 * - 2005-06-01
 * 						- First Implementation.
 * */
/** @file
 * @ingroup EGsrkGraph */
/** @addtogroup EGsrkGraph */
/** @{ */
/** @example float128_eg_shrink_graph.ex.c */
/* ========================================================================= */

#ifndef float128__EGshrinkGraph_h__
#define float128__EGshrinkGraph_h__
#ifndef float128_EG_SRK_DEBUG
/* ========================================================================= */
/** @brief debuigging level, the lower the more debugging is carried out */
#define float128_EG_SRK_DEBUG 100
#endif

/* ========================================================================= */
/** @brief Edge structure for shrinkable graphs */
typedef struct float128_EGsrkEdge_t
{
	EGeUgraphEdge_t edge;	/**< Actual edge structure for the graph */
	EGeList_t members;		/**< list of other edges shrunken within this edge */
	unsigned int mmb_sz;	/**< length of the members list (without including the 
														 edge itsself */
	float128 weight;			/**< Weight for the edge */
}
float128_EGsrkEdge_t;

/* ========================================================================= */
/** @brief Node structure for shrinkable graphs */
typedef struct float128_EGsrkNode_t
{
	EGeUgraphNode_t node;	/**< actual node structure for the graph */
	EGeList_t members;		/**< list of other nodes shrunken with this node */
	unsigned int mmb_sz;	/**< length of the members list (without including the
														 node itself */
	EGes_t parent;				/**< If this node is the representant for its class, 
														 then this is a 'parent' node, otherwise, is a 
														 shrunken node */
	float128 weight;			/**< Weight of the @f$\delta(n)@f$ edges for this node
														 (in the shrunken graph), this should be 
														 initialized by the user. */
	float128_EGsrkEdge_t *hit;			/**< used for internal purposes, in particular, while 
														 merging two adjacency lists, this field is used 
														 to store the first edge touching this node, and 
														 then used to retrieve that information. When we 
														 call #float128_EGsrkIdentifyNodes this field is assumed 
														 to be NULL */
}
float128_EGsrkNode_t;

/* ========================================================================= */
/** @brief Graph structure for shrinkable graphs */
typedef struct float128_EGsrkGraph_t
{
	EGeUgraph_t G;					/**< Actual graph structure. */
	unsigned n_onodes;			/**< Number of original nodes */
	unsigned n_oedges;			/**< Number of original edges */
}
float128_EGsrkGraph_t;

/* ========================================================================= */
/** @brief Initialize an edge structure.
 * @param e_edge */
#define float128_EGsrkEdgeInit(e_edge) ({\
	float128_EGsrkEdge_t*const _EGsrkE = (e_edge);\
	EGeUgraphEdgeInit(&(_EGsrkE->edge));\
	EGeListInit(&(_EGsrkE->members));\
	_EGsrkE->mmb_sz = 0;\
	float128_EGlpNumInitVar(_EGsrkE->weight);\
	float128_EGlpNumZero(_EGsrkE->weight);})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of an edge
 * structure.
 * @param e_edge */
#define float128_EGsrkEdgeClear(e_edge) ({\
	EGeUgraphEdgeClear(&((e_edge)->edge));\
	float128_EGlpNumClearVar((e_edge)->weight);})

/* ========================================================================= */
/** @brief Initialize a graph structure 
 * @param graph graph to be initialized */
#define float128_EGsrkGraphInit(graph) ({\
	float128_EGsrkGraph_t*const _EGsrkG = (graph);\
	EGeUgraphInit(&(_EGsrkG->G));\
	_EGsrkG->n_onodes = _EGsrkG->n_oedges = 0;})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a graph
 * structure.
 * @param graph */
#define float128_EGsrkGraphClear(graph) EGeUgraphClear(&((graph)->G))

/* ========================================================================= */
/** @brief Initialize a node structure.
 * @param e_node node to be initialized */
#define float128_EGsrkNodeInit(e_node) ({\
	float128_EGsrkNode_t*const _EGsrkN = (e_node);\
	EGeUgraphNodeInit(&(_EGsrkN->node));\
	EGeListInit(&(_EGsrkN->members));\
	_EGsrkN->mmb_sz = 0;\
	_EGsrkN->hit = 0;\
	EGesInit(&(_EGsrkN->parent));\
	float128_EGlpNumInitVar(_EGsrkN->weight);\
	float128_EGlpNumZero(_EGsrkN->weight);})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a node
 * structure.
 * @param e_node */
#define float128_EGsrkNodeClear(e_node) ({\
	EGeUgraphNodeClear(&((e_node)->node));\
	float128_EGlpNumClearVar((e_node)->weight);})

/* ========================================================================= */
/** @brief Add a #float128_EGsrkNode_t node to a #float128_EGsrkGraph_t graph.
 * @param graph graph were to add the node.
 * @param N node to add to the graph.
 * @return zero on success, non-zero otherwise.
 * */
#define float128_EGsrkAddNode(graph,N) EGeUgraphAddNode(&((graph)->G),&((N)->node))

/* ========================================================================= */
/** @brief Add a #float128_EGsrkEdge_t edge to a #float128_EGsrkGraph_t graph.
 * @param lG graph were to add the edge.
 * @param head_pt head node of the edge.
 * @param tail_pt tail node of the edge.
 * @param E edge to be added with end-points head_pt and tail_pt.
 * Note that this function will update the accumulated weight of both
 * endpoints of the newly added edge according to the value stored in the
 * #float128_EGsrkEdge_t::weight field.
 * */
#define float128_EGsrkAddEdge(lG,head_pt,tail_pt,E) ({\
	float128_EGsrkNode_t*const _EGsrkH = (head_pt);\
	float128_EGsrkNode_t*const _EGsrkT = (tail_pt);\
	float128_EGsrkEdge_t*const _EGsrkE = (E);\
	float128_EGlpNumAddTo(_EGsrkH->weight,_EGsrkE->weight);\
	float128_EGlpNumAddTo(_EGsrkT->weight,_EGsrkE->weight);\
	EGeUgraphAddEdge(&((lG)->G),&(_EGsrkH->node),&(_EGsrkT->node),&(_EGsrkE->edge));})

/* ========================================================================= */
/** @brief Given two nodes in the current shrunken graph, shrunk them into one 
 * node.
 * @param G pointer to the graph where we are working
 * @param base first node.
 * @param srkN second node.
 * @return pointer to the new representing node.
 * @note We assume that the field float128_EGsrkNode_t::hit is identically NULL for all
 * nodes currently in the shrunken graph (including base and srkN). 
 * @note We allways assume that N1 will be the representing node.
 * @note Take note that this structure can't get back the pointer to the srkN
 * node, the user should take care of that if needed.
 * */
float128_EGsrkNode_t *float128_EGsrkIdentifyNodes (float128_EGsrkGraph_t * const G,
																 float128_EGsrkNode_t * const base,
																 float128_EGsrkNode_t * const srkN);

/* ========================================================================= */
/** @} 
 * end of float128_eg_shrink_graph.h */
#endif
#endif
#endif
#ifdef HAVE_SOFTFLOAT
#if HAVE_SOFTFLOAT
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgPushRelabel EGalgPushRelabel
 *
 * Here we implement the push-relabel algorithm as defined in the book "Network 
 * Flows" by Magnanti et. all, in chapter 6,7 and 8. Using the variant
 * "Highest-label preflow-push algorithm" (described on page 230) wich choose
 * the active node from wich to push from as the one with highest distance
 * label. This variant has running time @f$ \mathcal{O}(n^2\sqrt{m}) @f$ where
 * @a n is the number of nodes in the graph, and @a m the number of edges in it.
 * Note that the call to #float128_EGalgPRminSTcut produces a maximum @b pre_flow, to 
 * obtain a flow you should call the #float128_EGalgPRmaxSTflow that takes the graph 
 * produced by #float128_EGalgPRminSTcut and convert the preflow into a real flow. We
 * also choose to use to register the number of nodes with distance labels
 * @f$k,\quad\forall k=1,\ldots,n@f$ where @a n is the number of nodes in the
 * network. This is done because whenever the number of nodes with distance
 * labels @a k is zero, then all nodes with distance labels above @a k can be
 * set to @a n (and thus be added to the partially computed cut-set). This is an
 * (inportant) empirical speed-up, but does not affect the worst case complexity
 * analysis.
 * @version 1.0.0
 * @par History:
 * - 2010-05-07
 * 						- Add implementation using eg_adgraph.h
 * - 2005-06-01
 * 						- Add globla relabeling heuristic.
 * - 2005-05-30
 * 						- Final test results on the TSP x-files, all should be right now.
 * - 2005-05-26
 * 						- First Implementation.
 * @note This algorithm is implemented the embedded structures approach. I will
 * give further details on what this implies.
 *
 * @note It is important to note that this algorithm (as implemented here) 
 * @b WILL @b FAIL if an edge has infinite capacities. To handle that case
 * either we must re-program it, or you can put capacities suficiently large on
 * them (for example 2 times the sum of all bounded capacities) for this
 * algorithm to work.
 *
 * @note This implementation does use global relabeling, namelly, the
 * strategy when once in a while (for example every @a n or @a m relabeling
 * operations) we recompute
 * the exact distance labels. The use of this heuristic (together with the gap
 * heuristic) have been reported to be the most successfull in practice (see "On
 * Implementing Push-Relabel Method For The Maximum FLow Problem" from Boris V.
 * Cherkassy and Andrew V. Goldberg.) and also in the test that we have
 * performed on the fractional solutions of TSP's instances from the TSPLIB set
 * of problems using CONCORDE.
 * */
/** @file 
 * @ingroup EGalgPushRelabel */
/** @addtogroup EGalgPushRelabel */
/** @{ */
/** @example float128_eg_push_relabel.ex.c
 * This is a complete example for the min-cut max-flow problem using the
 * push/relabel implementation offered in EGalgPR. */
#ifndef float128___EG_PUSH_RELABEL_H__
#define float128___EG_PUSH_RELABEL_H__
/* ========================================================================= */

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define float128___PR_DEBUGL__ 100

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define float128___PR_TEST_VERBOSE__ 100

/* ========================================================================= */
/** @brief Level of debugging in the code. */
#define float128___PR_VERBOSE__ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define float128___PR_PROFILE__ 100

/* ========================================================================= */
/** @brief If profiling is enable (i.e. #float128___PR_PROFILE__ <= DEBUG), print 
 * some profiling information of the min s-t cut used up to now, and reset 
 * all internal counters to zero, if profiling is not enabled, nothing 
 * happen. */
/** @{ */
void float128_EGalgPRprofile(void);
/** @} */
/* ========================================================================= */
/** @brief If set to non-zero, use the global relabeling heuristic (to be called
 * every @a n number of relabel operations performed. if set to zero, it won't
 * use this heuristic. Note thought that it has been shown that this is a very
 * efficient heuristic to reduce the total running time, specially in the
 * #float128_EGalgPRminSTcut function call. */
#define float128_EG_PR_RELABEL 1

/* ========================================================================= */
/** @brief If #float128_EG_PR_RELABEL is set to one, then this initeger controls how
 * often we perform the global relabeling heuristic (in multiples of number of
 * nodes), the default value is 1. */
#define float128_EG_PR_RELABEL_FREC 1U

/* ========================================================================= */
/** @brief Node structure neede to run Push-Relabel algorithm on a network.
 * @note Notice that the directed graph part is embeded in this structure as
 * well. Note  that we could define internally space for  LVL_list, 
 * but for the sake of speed we include them in the node structure. */
typedef struct float128_EGalgPRnode_t
{
	EGeDgraphNode_t v;		/**< Actual node structure to work with (EGeDgraph) */
	EGeList_t LVL_list;		/**< Used to store the BFS list used for the first 
														 computations of the exact label distances, and 
														 then to store this node in it's current level list 
														 (this is used to implement the Highest-Label 
														 variant of the Preflow-Push algorithm) */
	EGeList_t T_cut;			/**< Used to speed-up the 'hole' heuristic, it is seted
														 once we enter the algorithm, so their value is 
														 non-important outside the function (but it's 
														 contents will be lost once we enter 
														 #float128_EGalgPRminSTcut). */
	unsigned int d;				/**< Exact label distance for this node. Note that 
														 nodes with distance lables @f$ \geq n @f$ (where 
														 @a n is the number of nodes in the graph) define 
														 the minimum @f$ s-t@f$ cut that we are looking 
														 for. */
	float128 e;					/**< Exess flow in the node. Note that in particular 
														 the excess on node @a t (once #float128_EGalgPRminSTcut 
														 finish) correspond to the minimum cut value. */
}
float128_EGalgPRnode_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an float128_EGalgPRnode_t structure */
#define float128_EGalgPRnodeInit(node_pt) ({\
	float128_EGalgPRnode_t*const __EGalgPR_in = (node_pt);\
	float128_EGlpNumInitVar(__EGalgPR_in->e);\
	EGeDgraphNodeInit(&(__EGalgPR_in->v));})

/* ========================================================================= */
/** @brief Reset the given node pointer (as if it were new).
 * @param node_pt pointer to the node to reset.
 * 
 * This function set the node as an empty node not linked with any graph.
 * */
#define float128_EGalgPRnodeReset(node_pt) EGeDgraphNodeReset(&((node_pt)->v))

/* ========================================================================= */
/** @brief clear a pointer to an float128_EGalgPRnode_t structure, and let it ready to be
 * freed if necesary. */
#define float128_EGalgPRnodeClear(node_pt) ({\
	float128_EGlpNumClearVar((node_pt)->e);\
	EGeDgraphNodeClear(&((node_pt)->v));})

/* ========================================================================= */
/** @brief capacitated edge structure with forward/backward information. */
typedef struct float128_EGalgPRse_t
{
	EGeDgraphEdge_t e;	/**< actual edge information. */
	float128 r;				/**< residual capacity of the edge. */
	float128 u;				/**< maximum capacity on the edge. */
	unsigned char type;	/**< type of edge (0 for forward and 1 for backward */
}
float128_EGalgPRse_t;

/* ========================================================================= */
/** @brief Edge Structure needed to run Push-Relabel algorithm on a network.
 * @note Notice that the this edge actually has actually two capacited edge
  substructures, one for forward edges and one for backward edge, it is assumed
 * that fw.type == 0 and bw.type == 1. This is needed because the algorithm 
 * asumes that both
 * edges exists (althought one may have zero capacity). Moreover, while
 * computing the residual capacities we need to access both edges e_ij and e_ji
 * at the same time, thus our choice to represent both edges in just one
 * structure. We also assume that the lower bound on the flow of all edges is
 * zero. Note that we don't need to keep explicitly the flow on the edges,
 * because given the residual capacity and the capacity on the edge we have that
 * @f$ x_{ij} - x_{ji} = u_{ij} - r_{ij} @f$ and thus we can set @f$ x_{ij} =
 * (u_{ij}-r_{ij})_+ @f$ and @f$ x_{ji} = (r_{ij}-u_{ij})_+ @f$.
 * if we have computed the maximal flow. */
typedef struct float128_EGalgPRedge_t
{
	float128_EGalgPRse_t fw;		/**< forward edge, we assum that fw.type = 0 */
	float128_EGalgPRse_t bw;		/**< backward edge, we assume that bw.type = 1 */
}
float128_EGalgPRedge_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an float128_EGalgPRedge_t structure */
#define float128_EGalgPRedgeInit(edge_pt) ({\
	float128_EGalgPRedge_t*const __EGalgPR_ie = (edge_pt);\
	float128_EGlpNumInitVar(__EGalgPR_ie->fw.r);\
	float128_EGlpNumInitVar(__EGalgPR_ie->fw.u);\
	float128_EGlpNumInitVar(__EGalgPR_ie->bw.r);\
	float128_EGlpNumInitVar(__EGalgPR_ie->bw.u);\
	EGeDgraphEdgeInit(&(__EGalgPR_ie->fw.e));\
	EGeDgraphEdgeInit(&(__EGalgPR_ie->bw.e));\
	__EGalgPR_ie->bw.type = 1;\
	__EGalgPR_ie->fw.type = 0;})

/* ========================================================================= */
/** @brief Reset the given edge pointer (as if it were new).
 * @param edge_pt pointer to the node to reset.
 * 
 * This function set the edge as an empty edge not linked with any graph.
 * */
#define float128_EGalgPRedgeReset(edge_pt) ({\
	float128_EGalgPRedge_t*const __EGalgPR_ie = (edge_pt);\
	EGeDgraphEdgeReset(&(__EGalgPR_ie->fw.e));\
	EGeDgraphEdgeReset(&(__EGalgPR_ie->bw.e));\
	__EGalgPR_ie->bw.type = 1;\
	__EGalgPR_ie->fw.type = 0;})


/* ========================================================================= */
/** @brief clear a pointer to an float128_EGalgPRedge_t structure, and let it ready to be
 * freed if necesary. */
#define float128_EGalgPRedgeClear(edge_pt) ({\
	float128_EGlpNumClearVar((edge_pt)->fw.r);\
	float128_EGlpNumClearVar((edge_pt)->fw.u);\
	float128_EGlpNumClearVar((edge_pt)->bw.r);\
	float128_EGlpNumClearVar((edge_pt)->bw.u);\
	EGeDgraphEdgeClear(&((edge_pt)->fw.e));\
	EGeDgraphEdgeClear(&((edge_pt)->bw.e));})

/* ========================================================================= */
/** @brief Graph structure needed to run Push-Relabel algorithm (with highest
 * label node selection rule). */
typedef struct float128_EGalgPRgraph_t
{
	EGeDgraph_t G;				/**< EGeDgraph structure holding the graph 
														 information. */
}
float128_EGalgPRgraph_t;

/* ========================================================================= */
/** @brief Initialize a pointer to an float128_EGalgPRgraph_t structure */
#define float128_EGalgPRgraphInit(graph_pt) EGeDgraphInit(&((graph_pt)->G))

/* ========================================================================= */
/** @brief Reset the given graph pointer (as if it were new).
 * @param graph_pt pointer to the node to reset.
 * 
 * This function set the graph as an empty graph.
 * */
#define float128_EGalgPRgraphReset(graph_pt) EGeDgraphReset(&((graph_pt)->G))

/* ========================================================================= */
/** @brief clear a pointer to an float128_EGalgPRgraph_t structure, and let it ready 
 * to be freed if necesary. */
#define float128_EGalgPRgraphClear(graph_pt) EGeDgraphClear(&((graph_pt)->G))

/* ========================================================================= */
/** @brief Compute a minimum @f$s-t@f$ cut.
 * @param s pointer to the float128_source node.
 * @param t pointer to the float128_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the float128_EGalgPRgraph_t* in wich we will work.
 * @return zero on success, non-zero otherwise.
 * @par Description:
 * When this funcion finish (successfully) all nodes with field
 * #float128_EGalgPRnode_t::d bigger than or equal to @a n (the number of nodes in the
 * graph) bellong to the @a s cut, while nodes with value strictly less than @a
 * n will bellong to the @a t cut. The residual capacities imply a maximum
 * pre-flow in the network, to get an acutal maximum flow you should run 
 * #float128_EGalgPRmaxSTflow function with imput the output graph of this function 
 * (for an example look at the file float128_eg_push_relabel.ex.c ).
 * @note This implementation uses the @a gap and @a global @a relabeling
 * heuristics to speed-up the computations.
 * */
int float128_EGalgPRminSTcut (float128_EGalgPRgraph_t * const G,
										 float128_EGalgPRnode_t * const s,
										 float128_EGalgPRnode_t * const t);

/* ========================================================================= */
/** @brief Compute a maximum @f$s-t@f$ flow from the ouput produced by
 * EGalgPRminCur.
 * @param s pointer to the float128_EGalgPRnode_t* float128_source node in the network.
 * @param t pointer to the float128_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the float128_EGalgPRgraph_t* in wich we will work.
 * @return zero on success, non-zero otherwise.
 * @par Description:
 * We assume that our input graph is the (unaltered) result of a 
 * call to #float128_EGalgPRminSTcut. Also, note that while computing the actual 
 * max @a s-@a t flow, we don't need to look for @a gap in the array of 
 * distances.
 * Also note that once you call this function, the information in
 * #float128_EGalgPRnode_t::d don't correspond any more to the cut as defined in
 * #float128_EGalgPRminSTcut.
 * */
int float128_EGalgPRmaxSTflow (float128_EGalgPRgraph_t * const G,
											float128_EGalgPRnode_t * const s,
											float128_EGalgPRnode_t * const t);

/* ========================================================================= */
/** @brief Check if the given input graph (with it's residual capacities)
 * represent an optimal solution to the maximum @f$ s-t @f$ flow / minimum
 * capacity @f$ s-t @f$ cut.
 * @param s pointer to the float128_EGalgPRnode_t* float128_source node in the network.
 * @param t pointer to the float128_EGalgPRnode_t* sink node in the network.
 * @param G pointer to the float128_EGalgPRgraph_t* in wich we will work.
 * @param error worst error while checking for optimality conditions.
 * @return zero if all discrepancies are under the #float128_epsLpNum threshold, 
 * otherwise, return the number of conditions that don't hold within that
 * threshold, and report in error the worst error found in any condition.
 * @note The input for this function should be the graph as returned by
 * #float128_EGalgPRmaxSTflow .
 * */
int float128_EGalgPRoptimalityTest (float128_EGalgPRgraph_t * const G,
													 float128_EGalgPRnode_t * const s,
													 float128_EGalgPRnode_t * const t,
													 float128 * error);

/* ========================================================================= */
/* @} */
/* end of float128_eg_push_relabel.h */
#endif
#endif
#endif
#ifdef HAVE_SOFTFLOAT
#if HAVE_SOFTFLOAT
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgMinCut EGalgMinCut
 *
 * Here we implement the min-cut algorithm based on the srinking
 * pre-processing of Padberg And Rinaldi in the paper "An Efficient 
 * Algorithm For The Minimum Capacity Cut Problem", Mathematical Programming
 * 47 (1990) pages 19-36. But using as minimum s-t cut code the Push-Relabel
 * max flow algorithm as implemented in the @ref EGalgPushRelabel module. This 
 * implies that we only support positive edge-weights.
 *
 * This implementation allows uses of diferent numbers as supported by
 * @ref EGlpNum module. And follows the philosophy of embeded structures as in
 * @ref EGalgPushRelabel module. Also, much of the approach used in this 
 * implementation come from CONCORDE's implementation.
 *
 * It is usually the case that the Minimum Cut Problem is just a sub-problem
 * of some larger problem, is for that reason that we implement (just as in
 * CONCORDE) a callback function that is called whenever an improving solution
 * is found, so that the user can do something with the given node-cutset and
 * value. for more details see the definition of #float128_EGalgMCcbk_t .
 *
 * @note 
 * If run with types like EGfp20_t, if the arithmetic produces an overflow,
 * then we are in big trouble, note that the numbers involved in the algorithm
 * may range up to \f$\sum(w_e:e\in E(G))\f$.
 *
 * @version 0.0.1
 * @par History:
 * - 2005-08-19
 * 						- While computing a minimum S-T cut, choose S randomly. and T
 * 							as a node at maximum distance (number of edges) from S.
 * 						- Fix small problem with shrinking level 4
 * - 2005-06-20
 * 						- First Implementation.
 * */
/** @file
 * @ingroup EGalgMinCut */
/** @addtogroup EGalgMinCut */
/** @{ */
/** @example float128_eg_min_cut.ex.c */
/* ========================================================================= */
#ifndef float128__EG_MIN_CUT_H
#define float128__EG_MIN_CUT_H
/* ========================================================================= */
/** @brief Verbosity Level */
#define float128___MC_VRBLVL_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define float128___MC_DEBUG_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define float128___MC_PROFILE_ 0

/* ========================================================================= */
/** If profiling is enable (i.e. #float128___MC_PROFILE_ <= DEBUG), print 
 * some profiling information of the min cut used up to now, and reset 
 * all internal counters to zero, if profiling is not enabled, nothing 
 * happen. */
/** @{ */
void float128_EGalgMCprofile(void);
/** @} */

/* ========================================================================= */
/** @brief Call-back function, it receives as input the weight of the cut, the
 * size of the newly found cut, an array containing the cut (of length at
 * least the number of elements in the cut) as integers (as defined by the 
 * #float128_EGalgMCnode_t::id field), and a pointer to some internal
 * data (as stored in #float128_EGalgMCcbk_t::param). The function should return zero
 * on success, and non-zero if an error ocours, this error will be propagated
 * through the calling functions. */
typedef int (*float128_EGalgMCdo_f) (float128,
														const unsigned int,
														const unsigned int *const,
														void *);

/* ========================================================================= */
/** @brief Call-back structure for use when an improving minimum cut is found.
 * */
typedef struct float128_EGalgMCcbk_t
{
	float128 cutoff;	/**< maximum value for the newly found minimum cut, for 
												 the function to be called. */
	void *param;			/**< external parameter needed by the function */
	float128_EGalgMCdo_f do_fn;/**< actual function to be called if the cut-off condition 
												 holds */
}
float128_EGalgMCcbk_t;

/* ========================================================================= */
/** @brief Initialize a call-back structure.
 * @param cb call-back to be initialized. */
#define float128_EGalgMCcbkInit(cb) ({\
	float128_EGalgMCcbk_t*const _EGalgMCcb = (cb);\
	float128_EGlpNumInitVar(_EGalgMCcb->cutoff);\
	_EGalgMCcb->param = 0;\
	_EGalgMCcb->do_fn = 0;})

/* ========================================================================= */
/** @brief Free all internal memory asociated with this structure (not
 * allocated by the user).
 * @param cb call-back strucure to be cleared */
#define float128_EGalgMCcbkClear(cb) float128_EGlpNumClearVar((cb)->cutoff)

/* ========================================================================= */
/** @brief Node structure for Minimum Cut */
typedef struct float128_EGalgMCnode_t
{
	float128_EGsrkNode_t node;		/**< Actual shrinkable node */
	unsigned int id;		/**< External Identifier for the node */
	EGeList_t lvl_cn;		/**< Connector for the level list */
	unsigned int float128_lvl;		/**< Current node level test to be performed */
	unsigned int new_id;/**< internal data, it's values can be discarded */
	float128_EGsrkEdge_t *hit;		/**< Used to speed-up the Padberg-Rinaldi tests. */
}
float128_EGalgMCnode_t;

/* ========================================================================= */
/** @brief Initialize a node structure for use.
 * @param N node to be initialized */
#define float128_EGalgMCnodeInit(N) ({\
	float128_EGalgMCnode_t*const _EGalgMCn = (N);\
	float128_EGsrkNodeInit(&(_EGalgMCn->node));\
	_EGalgMCn->lvl_cn = (EGeList_t){0,0};\
	_EGalgMCn->float128_lvl = 0;\
	_EGalgMCn->id = UINT_MAX;\
	_EGalgMCn->new_id = UINT_MAX;\
	_EGalgMCn->hit = 0;})

/* ========================================================================= */
/** @brief Clear any internal memory (not allocated by the user) used by this
 * structure.
 * @param N node to be cleared */
#define float128_EGalgMCnodeClear(N) float128_EGsrkNodeClear(&((N)->node))

/* ========================================================================= */
/** @brief Edge structure for the Minimum Cut */
typedef struct float128_EGalgMCedge_t
{
	float128_EGsrkEdge_t edge;	/**< Actual shrinkable edge */
	unsigned int id;	/**< External Identifier for the edge */
}
float128_EGalgMCedge_t;

/* ========================================================================= */
/** @brief Initialize an edge structure for use.
 * @param E edge to be initialized */
#define float128_EGalgMCedgeInit(E) ({\
	float128_EGalgMCedge_t*const _EGalgMCe = (E);\
	float128_EGsrkEdgeInit(&(_EGalgMCe->edge));\
	_EGalgMCe->id = UINT_MAX;})

/* ========================================================================= */
/** @brief Clear any internal memory (not allocated by the user) used by this
 * structure.
 * @param E node to be cleared */
#define float128_EGalgMCedgeClear(E) float128_EGsrkEdgeClear(&((E)->edge))

/* ========================================================================= */
/** @brief Graph Structure for Minimum Cut.
 *
 * Note that this structure also holds some parameters as the epsilon to use
  in the comparisons, the current best cut found (or bound), and the current
 * cut found so-far. As well as an array containing all edges and nodes in
 * thee graph (remember that when we Identify two nodes, we loose any
 * reference to the shrinked node in the graph structure as discussed in
 * #float128_EGsrkIdentifyNodes ) 
 * */
typedef struct float128_EGalgMCgraph_t
{
	float128_EGsrkGraph_t G;						/**< Actual shrinking graph used */
	float128 epsilon;				/**< error tolerance used for equality testing */
	float128 cut_val;				/**< if #float128_EGalgMCgraph_t::cut_sz is not zero, then 
																 this is the value of the (currenlty) best 
																 minimum cut found so far. otherwise is a bound 
																 on the value of the minimum cut (note that this
																 value should be set before actually computing 
																 the minimum cut, and can be set to the value 
																 of @f$\delta(v)@f$ for some node @a v in the 
																 graph. */
	unsigned int cut_sz;			/**< number of nodes in the current best cut, if 
																 set to zero, then no cut has been found 
																 (so far) */
	EGeList_t lvl_list[5];		/**< List of nodes in different levels of tests */
	unsigned int *cut;				/**< Array  storing the current cut, the size of 
																 this array should be at least 
																 #float128_EGsrkGraph_t::n_onodes */
	float128_EGalgMCnode_t *all_nodes;	/**< Array containing all nodes of the graph. */
	float128_EGalgMCedge_t *all_edges;	/**< Array containing all edges of the graph. */
}
float128_EGalgMCgraph_t;

/* ========================================================================= */
/** @brief Initialize a graph structure for use.
 * @param Graph graph to be initialized */
#define float128_EGalgMCgraphInit(Graph) ({\
	float128_EGalgMCgraph_t*const _EGalgMCg = (Graph);\
	float128_EGsrkGraphInit(&(_EGalgMCg->G));\
	float128_EGlpNumInitVar(_EGalgMCg->epsilon);\
	float128_EGlpNumZero(_EGalgMCg->epsilon);\
	float128_EGlpNumInitVar(_EGalgMCg->cut_val);\
	float128_EGlpNumZero(_EGalgMCg->cut_val);\
	_EGalgMCg->cut_sz = 0;\
	EGeListInit(_EGalgMCg->lvl_list);\
	EGeListInit(_EGalgMCg->lvl_list+1);\
	EGeListInit(_EGalgMCg->lvl_list+2);\
	EGeListInit(_EGalgMCg->lvl_list+3);\
	EGeListInit(_EGalgMCg->lvl_list+4);\
	_EGalgMCg->cut = 0;\
	_EGalgMCg->all_nodes = 0;\
	_EGalgMCg->all_edges = 0;})

/* ========================================================================= */
/** @brief Clear internal memory (not allocated by the user) of a graph
 * structure.
 * @param Graph graph to be cleared. */
#define float128_EGalgMCgraphClear(Graph) ({\
	float128_EGsrkGraphClear(&((Graph)->G));\
	float128_EGlpNumClearVar((Graph)->epsilon);\
	float128_EGlpNumClearVar((Graph)->cut_val);})

/* ========================================================================= */
/** @brief Shrink two nodes in the graph, and update internal structures.
 * @param Graph current graph.
 * @param N node to keep in graph.
 * @param M node to shrink within N. */
#define float128_EGalgMCidentifyNodes(Graph,N,M) ({\
	float128_EGalgMCgraph_t*const _EGalgMCg = (Graph);\
	float128_EGalgMCnode_t*const _EGalgMCn = (N), *const _EGalgMCm = (M);\
	MESSAGE(float128___MC_DEBUG_,"Shrinking nodes with weight %lf %lf", \
					float128_EGlpNumToLf(_EGalgMCn->node.weight), \
					float128_EGlpNumToLf(_EGalgMCm->node.weight));\
	float128_EGsrkIdentifyNodes(&(_EGalgMCg->G), &(_EGalgMCn->node), &(_EGalgMCm->node));\
	if(_EGalgMCn->float128_lvl < 5)\
	{\
		EGeListDel(&(_EGalgMCm->lvl_cn));\
		EGeListMoveAfter(&(_EGalgMCn->lvl_cn), _EGalgMCg->lvl_list);\
	}\
	else EGeListAddAfter(&(_EGalgMCn->lvl_cn), _EGalgMCg->lvl_list);\
	_EGalgMCn->float128_lvl = 0;})

/* ========================================================================= */
/** @brief Identify all Padberg and Rinaldy edges. i.e. shrink all edges that
 * satisfy the conditions in their paper. we choose to make tests over pair of
 * nodes linked by an edge. 
 * @param max_lvl set a limit on wich tests to perform. for example, if set to
 * 1, only the first and second tests will be carried out.
 * @param G graph over wich we are working. 
 * @param cb call back structure to use (if set to NULL it is not used).
 * @return zero on success, non-zero otherwise. 
 *
 * Note that while doing this identification process, we update the values of
 * #float128_EGalgMCgraph_t::cut, #float128_EGalgMCgraph_t::cut_sz and #float128_EGalgMCgraph_t::cut_val,
 * as well as performing the actual shrinking procedure.
 *
 * The original theorem (for local conditions on shrinking) is the following:
 * Let @f$ Z @f$ be a proper subset of @f$ V @f$ (the set of all nodes in the
 * graph), @f$ |Z|\geq2 @f$, and let 
 * @f[ P(Z) = \bigcup\left\{ N(u)\cap N(v):u\neq v, u,v\in Z \right\} @f]
 * where @f$ N(u) @f$ if the set of neighbours of @f$ u @f$. If there exists
 * @f$ Y\subseteq P(Z) @f$ such that for every nonempty proper subset @f$ W
 * @f$ of @f$ Z @f$ and for every @f$ T\subseteq Y @f$ either:
 * -# @f$ w(\delta(W))/2 \leq w(W:(Y-T)+(Z-W)) @f$ or
 * -# @f$ w(\delta(Z-W))/2 \leq w(Z-W:T+W) @f$.
 * Then there exists a minimum cut @f$(X:V-X)@f$ such that either @f$
 * Z\subseteq X @f$ or @f$ X\subseteq Z @f$.
 *
 * And the original theorem (in fact is the corollary 3.5 in the paper) 
 * regarding global conditions for shrinking is the following:
 * Let @f$ u\neq v\in V @f$, and let @f$ q @f$ be an upper bound on the
 * minimum cut value, and @f$ lb_{uv} @f$ be a lower bound in the value of a
 * minimum @f$ u-v @f$ cut, then if @f$ lb_{uv}\geq q @f$ the set 
 * @f$ \{u,v\} @f$ is shrinkable.
 * 
 * The actual tests that we perform (for every edge) are the following:
 * -# If @f$ w(\delta(u)) < @f$ #float128_EGalgMCgraph_t::cut_val, update the minimum
 * cut value and set.
 * -# If @f$ w_{uv} \geq \min\{w(\delta(u)),w(\delta(v))\}/2 @f$ then we can 
 * safely shrink edge @f$ uv @f$.
 * -# If we have a triangle @f$ uv,\quad vw,\quad wu  @f$, with 
 * @f$ w_{uv} + w_{vw} \geq w(\delta(v))/2 @f$ and  
 * @f$ w_{uw} + w_{vw} \geq w(\delta(w))/2 @f$ then we can safely shrink edge
 * @f$ wv @f$.
 * -# Compute lower bound on the cut that separates the endpoints of the
 * current edge as :
 * @f[ lb_{uv}=w_{uv}+\sum\limits_{w\in N(u)\cap N(v)}\min\{w_{uw},w_{vw}\} @f]
 * If  @f$ lb_{uv} \geq  @f$ #float128_EGalgMCgraph_t::cut_val , then we can shrink the edge  @f$ uv @f$.
 * -# Consider the edge @f$ uv @f$ and two common neighbours @f$ x,y @f$. If  
 * @f$ w_{ux} + w_{uy} + w_{uv} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{vx} + w_{vy} + w_{vu} \geq w(\delta(v))/2 @f$ and at least one of 
 * @f$ w_{uv} + w_{uy} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{uv} + w_{vx} \geq w(\delta(v))/2 @f$ and at least one of 
 * @f$ w_{uv} + w_{ux} \geq w(\delta(u))/2 @f$ and 
 * @f$ w_{uv} + w_{vy} \geq w(\delta(v))/2 @f$ then we can safely shrink edge
 * @f$ uv @f$.
 *
 * We make thiese tests in order, i.e. first we perform all level 1 tests,
 * then level2, and so on, and whenever two nodes are Identify (shrinked) we
 * set the level of the node to 1 (i.e. in the next test we will test the
 * first condition). This is done using an array of (5) lists, where all nodes
 * are distributed. Originally all nodes should be in the first lists (i.e.
 * all nodes should be tested to improve the current best cut by themselves).
 * */
int float128_EGalgMCidentifyPRedges (float128_EGalgMCgraph_t * const G,
														float128_EGalgMCcbk_t * const cb,
														const unsigned int max_lvl);

/* ========================================================================= */
/** @brief Compute a minimum cut on the given graph. 
 * @param max_lvl set a limit on wich tests to perform during the
 * Padberg-Rinaldy shrinking step. for example, if set to
 * 1, only the first and second tests will be carried out.
 * @param G graph over wich we are working. 
 * @param cb call back structure to use (if set to NULL it is not used).
 * @return zero on success, non-zero otherwise. 
 *
 * This function takes as input a graph, and perform the minimum cut algorithm
 * as described in the paper "An Efficient 
 * Algorithm For The Minimum Capacity Cut Problem", Mathematical Programming
 * 47 (1990) pages 19-36. 
 *
 * Note that the graph should have all fields properly initialized.
 * */
int float128_EGalgMC (float128_EGalgMCgraph_t * const G,
						 float128_EGalgMCcbk_t * const cb,
						 const unsigned int max_lvl);

/* ========================================================================= */
/** @} 
 * end float128_eg_min_cut.h */
#endif
#endif
#endif
#ifdef HAVE_SOFTFLOAT
#if HAVE_SOFTFLOAT
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef float128___EG_NUMUTIL_H__
#define float128___EG_NUMUTIL_H__

/* ========================================================================= */
/** @defgroup EGlpNumUtil General Number Utilities
 * Here we put some utilities common for different number types but thaat we
 * want to implement as templates, like permutation sorting, inner product of
 * vectors, and so-on..
 * 
 * @par History:
 * Revision 0.0.2
 *  - 2007-10-08
 *  					- Separate template file and independet file into eg_nummacros.h
 *  					- Move EGabs, EGswap, EGmin and EGmax to this file
 *  - 2005-10-31
 *  					- First implementation.
 * */
/** @{*/
/** @file
 * @brief This file provide the user interface and function definitions for
 * general number utilities.
 * */
/* ========================================================================= */
/** @brief compute the inner product of two arrays.
 * @param arr1 first array.
 * @param arr2 second array.
 * @param length number of entries to consider in both arrays, from zero to
 * length - 1.
 * @param rop where to store the result.
 * */
#define float128_EGlpNumInnProd(__rop,__arr1,__arr2,__length) float128___EGlpNumInnProd((&(__rop)),__arr1,__arr2,__length)
/* ========================================================================= */
/** @brief internal version, this is done to avoid using stdc99 and rely on
 * more basic stdc89 */
void float128___EGlpNumInnProd(float128*rop,float128*const arr1,float128*const arr2, const size_t length);
/* ========================================================================= */
/** @brief Sort (in increasing order) a sub-set of entries in an array using 
 * quicksort, by permutating the order of the elements in the subset rather 
 * than in the whole original array.
 * @param sz length of the permutation array.
 * @param perm array of indices of elements that we want to sort.
 * @param elem array (of length at least max(perm[k]:k=0,...,sz-1)) containing
 * the elements to be sorted.
 * @note The array of elements is not changed by this function.
 * @note This code is based in concorde's implementation of
 * permutation-quick-sort.
 * */
void float128_EGutilPermSort (const size_t sz,
										 int *const perm,
										 const float128 * const elem);

/* ========================================================================= */
/** @brief Sort (in decreasing order) a sub-set of entries in an array using 
 * quicksort, by permutating the order of the elements in the subset rather 
 * than in the whole original array.
 * @param sz length of the permutation array.
 * @param perm array of indices of elements that we want to sort.
 * @param elem array (of length at least max(perm[k]:k=0,...,sz-1)) containing
 * the elements to be sorted.
 * @note The array of elements is not changed by this function.
 * @note This code is based in concorde's implementation of
 * permutation-quick-sort.
 * */
void float128_EGutilPermSort2 (const size_t sz,
										 int*const perm,
										 const float128*const elem);

/* ========================================================================= */
/** @}*/
#endif
#endif
#endif
#ifdef HAVE_SOFTFLOAT
#if HAVE_SOFTFLOAT
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgDijkstra EGalgDijkstra
 * Dijkstra implementation with 2-heaps
 * */
/** @file
 * @ingroup EGalgDijkstra */
/** @addtogroup EGalgDijkstra */
/** @{ */
/** @example float128_eg_dijkstra.ex.c */
/* ========================================================================= */
#ifndef float128___EG_DIJKSTRA_H
#define float128___EG_DIJKSTRA_H
/* ========================================================================= */
/** @brief Verbosity Level */
#define float128_DJK_VRBLVL_ 100

/* ========================================================================= */
/** @brief Level of profiling in the code. */
#define float128_DJK_DEBUG_ 100

/* ========================================================================= */
/** @brief implement dijkstra.
 * */
int float128_EGalgDJK (
		int32_t const nnodes,
		int32_t const nedges,
		int32_t const*const ou_d,
		int32_t const*const ou_beg,
		int32_t const*const ou_e,
		float128 const*const weight,
		int32_t const s,
		int32_t const nt,
		int32_t const*const t,
		int32_t*const father,
		float128*const dist
		);

/* ========================================================================= */
/** @brief read from a file in .x format (as in the concorde's .x files), the
 * format is as follows:
 * nnodes nedges
 * tail_1 head_1 weight_1
 * ...    ...    ....
 * tail_nnodes head_nnodes weight_nnodes
 * comments are allowed, if they start with % or #.
 * @param input file containing the data
 * @param n where to store the number of nodes
 * @param m where to store the number of edges
 * @param edges pointer to an array where to store the edges, note that memory
 * will be allocated in (*edges)
 * @param weight pointer to the array where we will store the weights, note
 * that this array will be allocated using float128_EGlpNumAllocArray, and should be
 * deallocated using float128_EGlpNumFreeArray.
 * @return zero on success, non-zero otherwise 
 * */
int float128_EGguReadXgraph(
		EGioFile_t*const input,
		int32_t*const n,
		int32_t*const m,
		int32_t**const edges,
		float128**const weight);
/* ========================================================================= */
/** @} 
 * end float128_eg_dijkstra.h */
#endif

#endif
#endif
/* EGlib "Efficient General Library" provides some basic structures and
 * algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2005 Daniel Espinoza and Marcos Goycoolea.
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
#ifndef __EG_LPNUM_LDBL__
#define __EG_LPNUM_LDBL__
#ifdef HAVE_LONG_DOUBLE
/** @file
 * @ingroup EGlpNum */
/** @addtogroup EGlpNum */
/** @{ */
/* ========================================================================= */
/** extern definitions of constaants for different set-ups */
#define ldbl_zeroLpNum 0.0L
#define ldbl_oneLpNum  1.0L
#define ldbl_epsLpNum  LDBL_EPSILON
#define ldbl_MaxLpNum  LDBL_MAX
#define ldbl_MinLpNum  LDBL_MIN

/* ========================================================================= */
/** @brief Read from a string a number and store it in the given long double, 
 * @return the number of chars readed from the input string */
#define ldbl_EGlpNumReadStr(a,str) ({\
	int __i =0;\
	sscanf(str,"%Lf%n",&(a),&__i);\
	__i;})

/* ========================================================================= */
/** @brief given a long double, write it to a string (to be allocated internally), 
 * and return it. */
#define ldbl_EGlpNumGetStr(a) ({\
	char *__str=0;\
	size_t __i=snprintf(__str,(size_t)0,"%Lf",a);\
	__str = EGsMalloc(char,__i+1);\
	snprintf(__str,__i+1,"%Lf",a);\
	__str;})

/* ========================================================================= */
/** @brief given an array of type long double, free it, if the pointer is NULL
 * nothing happen. */
#define ldbl_EGlpNumFreeArray(ea) __EGlpNumFreeArray(ea)

/* ========================================================================= */
/** @brief Reallocate and initialize (if needed) 'size' elements of type 
 * EGlpNum_t and return it, if no more memory, exit(1) */
#define ldbl_EGlpNumReallocArray(lptr, lsize) ({\
	size_t __csz = (lsize), *__usp = 0;\
	size_t __psz = __EGlpNumArraySize(*lptr);\
	long double** __ptr__ = (lptr);\
	if (!__psz) *__ptr__ = ldbl_EGlpNumAllocArray (__csz); \
	else if (__psz < __csz) {\
		__usp = (size_t*)(*__ptr__);\
		__usp--;\
		__usp = EGrealloc(__usp, sizeof(long double)*__csz+sizeof(size_t));\
		__usp[0] = __csz;\
		*__ptr__ = (long double*)(__usp+1);\
	}\
	*__ptr__;})

/* ========================================================================= */
/** @brief Allocate and initialize (if needed) 'size' elements of type long double
 * and return it, if no more memory, exit(1) */
#define ldbl_EGlpNumAllocArray(size) __EGlpNumAllocArray(long double,size)

/* ========================================================================= */
/** @brief set the given number pointer, set its value to the given long double.
 * @param var long double where we will store the long double value.
 * @param ldbl long double value to be stored in 'var'.
 * @par Description:
 * This function is intended to set initial values to variables; note that the
 * long double is a number and not a pointer to that value, be carefull with this
 * detail. Also, due to implementation details this function can't deal with
 * numbers above 1e158 or smaller than 1e-158. Note also that if the number is
 * writen in the form \f$x=\bar{x}\cdot 2^e\f$ with \f$0.5<|\bar{x}|<1\f$, 
 * then \f$\left|x-\frac{p}{q}\right|<2^{e-64}\f$.
 * */
#define ldbl_EGlpNumSet(var, ldbl) ((var) = (ldbl))

/* ========================================================================= */
/** @brief Stores in the first number the ceil value of the second number, i.e.
 * EGlpNumCeil(a,b) <==> a= ceil(b) */
#define ldbl_EGlpNumCeil(a, b) ((a) = ceill(b))

/* ========================================================================= */
/** @brief Stores in the first number the floor value of the second number, i.e.
 * EGlpNumFloor(a,b) <==> a= floor(b) */
#define ldbl_EGlpNumFloor(a, b) ((a) = floorl(b))

/* ========================================================================= */
/** @brief store the (multiplicative) inverse of a number to itself, i.e.
 * implement a = 1/a.
 * @param a the number to be inverted. */
#define ldbl_EGlpNumInv(a) ((a) = 1.0L/(a))

/* ========================================================================= */
/** @brief Compare if two numbers are equal within a maximum error.
 * @param a EGlpNum_t first number to compare.
 * @param b EGlpNum_t second number to compare.
 * @return int one in success, zero oterwise.
 * @par Description:
 * Given two numbers 'a','b' return 1 if a == b, otherwise it return 0
 * */
#define ldbl_EGlpNumIsEqqual(a,b) ((a) == (b))

/* ========================================================================= */
/** @brief Compare if two numbers are equal within a maximum error.
 * @param a EGlpNum_t first number to compare.
 * @param b EGlpNum_t second number to compare.
 * @param error EGlpNum_t maximum difference allowed between both
 * numbers.
 * @return int one in success, zero oterwise.
 * @par Description:
 * Given two numbers 'a','b' and a tolerance 'error',
 * return 1 if |a-b|<= error, otherwise it return 0.
 * */
#define ldbl_EGlpNumIsEqual(a,b,error) (fabsl((a)-(b)) <= (error))
#define ldbl_EGlpNumIsNeq(a,b,error) (((a)-(b) > (error)) || ((b)-(a) > (error)))
#define ldbl_EGlpNumIsNeqq(a,b)  ((a) != (b))
#define ldbl_EGlpNumIsNeqZero(a,error) (((a) > (error)) || (-(a) > (error)))
#define ldbl_EGlpNumIsNeqqZero(a)     	((a) != 0.0)

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a < b, zero
 * otherwise.
 * */
#define ldbl_EGlpNumIsLess(a,b) (a < b)

/* ========================================================================= */
/** @brief test if a number is Greater than zero
 * @param a number to compare
 * @return int one if success, zero otherwise.
 * */
#define ldbl_EGlpNumIsGreatZero(a) (a > 0.0)

/* ========================================================================= */
/** @brief test if a number is less than zero
 * @param a number to compare
 * @return int one if success, zero otherwise.
 * */
#define ldbl_EGlpNumIsLessZero(a) (a < 0.0)

/* ========================================================================= */
/** @brief test if the sum of the first two numbers is less thatn the third
 * number.
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @param c EGlpNum_t the third number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given a,b, and c, return nonzero if (a + b < c), zero toherwise.
 * */
#define ldbl_EGlpNumIsSumLess(a, b, c) ((a) + (b) < (c))

/* ========================================================================= */
/** @brief test if the diference of the first two numbers is less thatn the 
 * third number.
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @param c EGlpNum_t the third number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given a,b, and c, return nonzero if (a - b < c), zero toherwise.
 * */
#define ldbl_EGlpNumIsDiffLess(a, b, c) ((a) - (b) < (c))

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b long double the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a < b, zero
 * otherwise.
 * */
#define ldbl_EGlpNumIsLessDbl(a,b) ((a) < (b))

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b long double the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a > b, zero
 * otherwise.
 * */
#define ldbl_EGlpNumIsGreaDbl(a,b) ((a) > (b))

/* ========================================================================= */
/** @brief test if the first number is bigger to the second number
 * @param a EGlpNum_t the first number.
 * @param b EGlpNum_t the second number
 * @return int one if success, zero otherwise.
 * @par Description:
 * Given two numbers 'a' and 'b', return one if a <= b, zero
 * otherwise.
 * */
#define ldbl_EGlpNumIsLeq(a,b) ((a) <= (b))

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param a EGlpNum_t source number (it won't change value).
 * @param b EGlpNum_t source number (it won't change value).
 * @param den EGlpNum_t denominator of the difference (it won't change value).
 * @param dest EGlpNum_t where to store the value .
 * @par Description:
 * Set dest = (a - b) / den */
#define ldbl_EGlpNumCopyDiffRatio(dest,a, b, den) ((dest) = ((a) - (b)) / (den))

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param a EGlpNum_t source number (it won't change value).
 * @param b EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the value stored in 'orig'.
 * @par Description:
 * Set dest = a - b */
#define ldbl_EGlpNumCopyDiff(dest,a,b) ((dest) = (a) - (b))

/* ========================================================================= */
/** @brief copy the value of the sum of the second and third parameter
 * @param a EGlpNum_t source number (it won't change value).
 * @param b EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the sum.
 * @par Description:
 * Set dest = a + b */
#define ldbl_EGlpNumCopySum(dest,a,b) ((dest) = (a) + (b))

/* ========================================================================= */
/** @brief copy the value of the second number to the first.
 * @param orig EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the value stored in 'orig'.
 * @par Description:
 * Given two numbers copy the values in 'orig', into 'dest'.
 * */
#define ldbl_EGlpNumCopy(dest,orig) ((dest) = (orig))

/* ========================================================================= */
/** @brief change the fist number to the maximum between itself and the 
 * absolute value of the second.
 * @param orig EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the value stored in 'orig'.
 * @par Description:
 * implement dest = max(dest,abs(orig))
 * */
#define ldbl_EGlpNumSetToMaxAbs(dest, orig) if((dest) < fabsl(orig)) \
																							(dest) = fabsl(orig)
#define ldbl_EGlpNumSetToMinAbs(dest, orig) if((dest) > fabsl(orig)) \
																							(dest) = fabsl(orig)

/* ========================================================================= */
/** @brief copy the square of the second argument, divided by the third 
 * argument into the first argument.
 * @param dest EGlpNum_t where to store the result
 * @param orig EGlpNum_t second parameter
 * @param den EGlpNum_t third parameter
 * @par Description:
 * compute dest = (orig*orig)/den
 * */
#define ldbl_EGlpNumCopySqrOver(dest, orig, den) ((dest) = (orig)*(orig)/(den))

/* ========================================================================= */
/** @brief copy the value of the absolute value of the second parameter to the 
 * first parameter.
 * @param orig EGlpNum_t source number (it won't change value).
 * @param dest EGlpNum_t where to store the absolute value stored
 * in 'orig'.
 * @par Description:
 * Given a number 'orig', copy its absolute value to 'dest'. i.e.
 * dest = |orig|
 * */
#define ldbl_EGlpNumCopyAbs(dest,orig) ((dest) = fabsl(orig))

/* ========================================================================= */
/** @brief copy minus the value of the second parameter to the 
 * first parameter.
 * @param orig EGlpNum_t the source number (it won't change value).
 * @param dest EGlpNum_t where to store minus the value stored
 * in 'orig'.
 * @par Description:
 * Given a number 'orig', copy minus the value to 'dest'. i.e.
 * dest = -orig
 * */
#define ldbl_EGlpNumCopyNeg(dest,orig) ((dest) = -(orig))

/* ========================================================================= */
/** @brief Set des = op1/op2.
 * @param dest EGlpNum_t where we will store the result.
 * @param op1 EGlpNum_t numerator of the fraction (possibly non an integer)
 * @param op2 EGlpNum_t denominator of the fraction (possibly non an integer)
 * @par Description:
 *  Set des = op1/op2
 * */
#define ldbl_EGlpNumCopyFrac(dest,op1,op2) ((dest) = (op1)/(op2))

/* ========================================================================= */
/** @brief copy the first 'size' values in the second array to the first array.
 * @param orig EGlpNum_t* pointer to the array from where we will copy the
 * values (it won't change value).
 * @param dest EGlpNum_t* pointer to where to store the first 'size' values 
 * stored in 'orig'.
 * @param size unsigned int specifying how many values of 'orig' will be copied
 * onto 'dest'
 * @par Description:
 * This function is provided to (possible) make fast copies of arrays of
 * numbers, the arrays should be of length at least 'size', and the resulting
 * copy is absolutely independent froom the original, any change in one vale of
 * one array won't change values on the other array.
 * */
#define ldbl_EGlpNumCopyArray(dest,orig,size) memcpy(dest,orig,sizeof(long double)*(size))

/* ========================================================================= */
/** @brief Sub to a given number the product of two numbers.
 * @param a EGlpNum_t the number that we are going to Sub to.
 * @param b EGlpNum_t value to be multiplyed.
 * @param c EGlpNum_t value to be multiplyed.
 * @par Description:
 * This function implements a = a - b*c, and clearly don't change the value
 * stored in 'b' nor in 'c'.
 * */
#define ldbl_EGlpNumSubInnProdTo(a, b, c) ((a) -= (b)*(c))

/* ========================================================================= */
/** @brief Add to a given number the product of two numbers.
 * @param a EGlpNum_t the number that we are going to add to.
 * @param b EGlpNum_t value to be multiplyed.
 * @param c EGlpNum_t value to be multiplyed.
 * @par Description:
 * This function implements a = a + b*c, and clearly don't change the value
 * stored in 'b' nor in 'c'.
 * */
#define ldbl_EGlpNumAddInnProdTo(a, b, c) ((a) += (b)*(c))

/* ========================================================================= */
/** @brief Substract to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to substract to.
 * @param b unsigned int value to be substracted to 'a'.
 * @par Description:
 * This function implements a = a - b, and clearly don't change the value
 * stored in 'b'.
 * */
#define ldbl_EGlpNumSubUiTo(a,b) ((a) -= (b))

/* ========================================================================= */
/** @brief Add to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to add to.
 * @param b unsigned int value to be added to 'a'.
 * @par Description:
 * This function implements a = a + b, and clearly don't change the value
 * stored in 'b'.
 * */
#define ldbl_EGlpNumAddUiTo(a,b) ((a) += (b))

/* ========================================================================= */
/** @brief Add to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to add to.
 * @param b EGlpNum_t value to be added to 'a'.
 * @par Description:
 * This function implements a = a + b, and clearly don't change the value
 * stored in 'b'.
 * */
#define ldbl_EGlpNumAddTo(a,b) ((a) += (b))

/* ========================================================================= */
/** @brief Substract to a given number the value of the second number.
 * @param a EGlpNum_t the number that we are going to substract
 * from.
 * @param b EGlpNum_t value to be substracted to 'a'.
 * @par Description:
 * This function implements a = a - b, and clearly don't change the value
 * stored in 'b'.
 * */
#define ldbl_EGlpNumSubTo(a,b) ((a) -= (b))

/* ========================================================================= */
/** @brief Multiply a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to multiply by
 * the second number and store the result.
 * @param b EGlpNum_t value to be multyply to 'a'.
 * @par Description:
 * This function implements a = a * b, and clearly don't change the value
 * stored in 'b'.
 * */
#define ldbl_EGlpNumMultTo(a,b) ((a) *= (b))

/* ========================================================================= */
/** @brief Divide a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to divide by
 * the second number and store the result.
 * @param b EGlpNum_t value to be divide to 'a'.
 * @par Description:
 * This function implements a = a / b, and clearly don't change the value
 * stored in 'b'.
 * */
#define ldbl_EGlpNumDivTo(a,b) ((a) /= (b))

/* ========================================================================= */
/** @brief Divide a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to divide by
 * the second number and store the result.
 * @param b unsigned int value to be divided to 'a'.
 * @par Description:
 * This function implements a = a / b, and don't change the value
 * stored in 'b'.
 * */
#define ldbl_EGlpNumDivUiTo(a,b) ((a) /= (b))

/* ========================================================================= */
/** @brief Multiply a given number by the value of the second number.
 * @param a EGlpNum_t the number that we are going to multiply by
 * the second number and store the result.
 * @param b unsigned int value to be multyply to 'a'.
 * @par Description:
 * This function implements a = a * b, and clearly don't change the value
 * stored in 'b'.
 * */
#define ldbl_EGlpNumMultUiTo(a,b) ((a) *= (b))

/* ========================================================================= */
/** @brief Reset the value of the pointed number to zero.
 * @param a EGlpNum_t the value to be set to zero.
 * @par Descrpition:
 * Reset a to zero, i.e. implements a = 0;
 * */
#define ldbl_EGlpNumZero(a) ((a) = 0.0L)

/* ========================================================================= */
/** @brief Reset the value of the pointed number to one.
 * @param a EGlpNum_t value to be set to one.
 * @par Descrpition:
 * Reset a to zero, i.e. implements a = 1;
 * */
#define ldbl_EGlpNumOne(a) ((a) = 1.0L)

/* ========================================================================= */
/** @brief Change the sign of the number.
 * @param a EGlpNum_t number we will change sign.
 * @par Descrpition:
 * Change the sign of the given number, i.e. implements a = -a
 * */
#define ldbl_EGlpNumSign(a) ((a) = -(a))

/* ========================================================================= */
/** @brief return the closest long double value of the given pointer number.
 * @param a EGlpNum_t number that we will be transformed to long double.
 * @return long double the closest long double representation of the given number.
 * par Description:
 * return the long double number closest in value to the value stored in a.
 * */
#define ldbl_EGlpNumToLf(a) ((double)(a))

/* ========================================================================= */
/** @brief initialize the internal memory of a given variable */
#define ldbl_EGlpNumInitVar(a) ldbl_EGlpNumZero(a)

/* ========================================================================= */
/** @brief free the internal memory of a given variable */
#define ldbl_EGlpNumClearVar(a)

/* ========================================================================= */
/** @} */
#endif
#endif
/* algorithms commons in many optimization algorithms.
 *
 * Copyright (C) 2010 Daniel Espinoza
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA 
 * */
/* ========================================================================= */
/** @defgroup EGalgMaxClosure Maximum Closure
 *
 * Here we provide a simple interface to use different methods to compute
 * maximum closure in a given graph. The (acyclic) graph is given by the edges,
 * a number of nodes, and values in the nodes (positive and negative).
 * @version 1.0.0
 * @par History:
 * - First implementation using push-relabel algorithm
 * */
/** @file 
 * @ingroup EGalgMaxClosure */
/** @addtogroup EGalgMaxClosure */
/** @{ */
/** @example eg_maxclosure.ex.c */
/* ========================================================================= */
#ifndef __EG_MAXCLOSURE_H__
#define __EG_MAXCLOSURE_H__
/* ========================================================================= */
/** @name Available algorithms to compute maximum closure */
/* @{ */
/** @brief default algorithm */
#define EG_ALG_MAXCLOSURE_DEFAULT 0
/** @brief Push-relabel implementation */
#define EG_ALG_MAXCLOSURE_PR 1
/* @} */
/* ========================================================================= */
/** @brief main interface function.
 * @param algo ID of the algorithm to use.
 * @param n number of nodes in graph
 * @param m number of edges in graph
 * @param edges array of directed edges to use, its length is @f$2m@f$ and
 * position (2k,2k+1) stores the head and tail of the k-th edge.
 * @param weight array of length n with the benefit of each node in the graph
 * @param closure_sz pointer to an integer where we store size of the resulting
 * closure.
 * @param closure array of length (at least) n, where we store the elements in the
 * maximum closure.
 * @param display display level, zero for none
 * @return zero on success, non-zero otherwise */
int EGalgMaxClosure(
		const int algo,
		const int n,
		const int m,
		const int*const edges,
		const double*const weight,
		int*const closure_sz,
		int*const closure,
		const int display);
/* ========================================================================= */
/** @brief version using array-based static graphs 
 * @param algo ID of the algorithm to use.
 * @param weight array of length n with the benefit of each node in the graph
 * @param closure_sz pointer to an integer where we store size of the resulting
 * closure.
 * @param closure array of length (at least) n, where we store the elements in the
 * maximum closure.
 * @param display display level, zero for none
 * @return zero on success, non-zero otherwise */
int EGalgAMaxClosure(
		const int algo,
		const EGaDG_t*const G,
		const double*const weight,
		int*const closure_sz,
		int*const closure,
		const int display);
/* ========================================================================= */
/** @} */
#endif
/* Declares subversion version number */
extern const char*const svn_EGlib;
/* Declares mayor version number */
extern const char*const string_EGlib;
/* Declares compilation date */
extern const char*const date_EGlib;
/* ========================================================================== */
#endif
